<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>叶落阁</title>
  
  
  <link href="http://yelog.org/atom.xml" rel="self"/>
  
  <link href="http://yelog.org/"/>
  <updated>2024-09-30T03:54:09.541Z</updated>
  <id>http://yelog.org/</id>
  
  <author>
    <name>叶落阁</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【禁止血压飙升】如何拥有一个优雅的 controller见过几千行代码的 controller吗？我见过。 见过全是 t - 掘金</title>
    <link href="http://yelog.org/2024/09/30/undefined/"/>
    <id>http://yelog.org/2024/09/30/undefined/</id>
    <published>2024-09-30T03:54:09.541Z</published>
    <updated>2024-09-30T03:54:09.541Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>见过几千行代码的 controller吗？我见过。</p><p>见过全是 try catch 的 controller 吗，我见过。</p><p>见过全是字段校验的 controller 吗，我见过。</p><p>见过全是业务代码的 controller 吗？不好意思，我们公司很多业务写在 controller 的。</p><p>看见这些我真的血压高。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="不优雅的-controller"><a href="#不优雅的-controller" class="headerlink" title="不优雅的 controller"></a>不优雅的 controller</h3><pre><code class="java">@RestController@RequestMapping(&quot;/user/test&quot;)public class UserController &#123;    private static Logger logger = LoggerFactory.getLogger(UserController.class);    @Autowired    private UserService userService;    @Autowired    private AuthService authService;    @PostMapping    public CommonResult userRegistration(@RequestBody UserVo userVo) &#123;        if (StringUtils.isBlank(userVo.getUsername()))&#123;            return CommonResult.error(&quot;用户名不能为空&quot;);        &#125;        if (StringUtils.isBlank(userVo.getPassword()))&#123;            return CommonResult.error(&quot;密码不能为空&quot;);        &#125;        logger.info(&quot;注册用户：&#123;&#125;&quot; , userVo.getUsername());        try &#123;            userService.registerUser(userVo.getUsername());            return CommonResult.ok();        &#125;catch (Exception e)&#123;            logger.error(&quot;注册用户失败：&#123;&#125;&quot;, userVo.getUsername(), e);            return CommonResult.error(&quot;注册失败&quot;);        &#125;    &#125;    @PostMapping(&quot;/login&quot;)    @PermitAll    @ApiOperation(&quot;使用账号密码登录&quot;)    public CommonResult&lt;AuthLoginRespVO&gt; login(@RequestBody AuthLoginReqVO reqVO) &#123;        if (StringUtils.isBlank(reqVO.getUsername()))&#123;            return CommonResult.error(&quot;用户名不能为空&quot;);        &#125;        if (StringUtils.isBlank(reqVO.getPassword()))&#123;            return CommonResult.error(&quot;密码不能为空&quot;);        &#125;        try &#123;            return success(authService.login(reqVO));        &#125;catch (Exception e)&#123;            logger.error(&quot;注册用户失败：&#123;&#125;&quot;, reqVO.getUsername(), e);            return CommonResult.error(&quot;注册失败&quot;);        &#125;    &#125;&#125;</code></pre><h3 id="优雅的controller"><a href="#优雅的controller" class="headerlink" title="优雅的controller"></a>优雅的controller</h3><pre><code class="java">@RestController@RequestMapping(&quot;/user/test&quot;)public class UserController1 &#123;    private static Logger logger = LoggerFactory.getLogger(UserController1.class);    @Autowired    private UserService userService;    @Autowired    private AuthService authService;    @PostMapping(&quot;/userRegistration&quot;)    public CommonResult userRegistration(@RequestBody @Valid UserVo userVo) &#123;        userService.registerUser(userVo.getUsername());        return CommonResult.ok();    &#125;    @PostMapping(&quot;/login&quot;)    @PermitAll    @ApiOperation(&quot;使用账号密码登录&quot;)    public CommonResult&lt;AuthLoginRespVO&gt; login(@RequestBody @Valid AuthLoginReqVO reqVO) &#123;        return success(authService.login(reqVO));    &#125;&#125;</code></pre><blockquote><p>代码量直接减一半呀，这还不算上有些直接把业务逻辑写在 controller 的，看到这些我真的直接吐血</p></blockquote><h3 id="改造流程"><a href="#改造流程" class="headerlink" title="改造流程"></a>改造流程</h3><h4 id="校验方式"><a href="#校验方式" class="headerlink" title="校验方式"></a>校验方式</h4><blockquote><p>这个 if 校验看得我哪哪都不爽。好歹给我写一个断言吧。Assert.notNull(userVo.getUsername(), “用户名不能为空”);</p><p>这不香吗？确实不香。</p><p>使用 spring 提供的@Valid</p></blockquote><ul><li>在入参时使用@Valid注解，并且在 vo 中使用校验注解，如AuthLoginReqVO</li></ul><pre><code class="java">@ApiModel(value = &quot;管理后台 - 账号密码登录 Request VO&quot;)@Data@NoArgsConstructor@AllArgsConstructor@Builderpublic class AuthLoginReqVO &#123;    @ApiModelProperty(value = &quot;账号&quot;, required = true, example = &quot;user&quot;)    @NotEmpty(message = &quot;登录账号不能为空&quot;)    @Length(min = 4, max = 16, message = &quot;账号长度为 4-16 位&quot;)    @Pattern(regexp = &quot;^[A-Za-z0-9]+$&quot;, message = &quot;账号格式为数字以及字母&quot;)    private String username;    @ApiModelProperty(value = &quot;密码&quot;, required = true, example = &quot;password&quot;)    @NotEmpty(message = &quot;密码不能为空&quot;)    @Length(min = 4, max = 16, message = &quot;密码长度为 4-16 位&quot;)    private String password;&#125;</code></pre><h3 id="Valid"><a href="#Valid" class="headerlink" title="@Valid"></a>@Valid</h3><p>在SpringBoot中，@Valid是一个非常有用的注解，主要用于数据校验。以下是关于@Valid的一些详细信息：</p><ol><li><code>为什么使用 @Valid 来验证参数</code>：在编写接口时，我们经常需要验证请求参数。通常，我们可能会写大量的 if 和 if else 代码来进行判断。但这样的代码不仅不优雅，而且如果存在大量的验证逻辑，这会使代码看起来混乱，大大降低代码可读性。为了简化这个过程，我们可以使用 @Valid 注解来帮助我们简化验证逻辑。</li><li><code>@Valid 注解的作用</code>：@Valid 的主要作用是用于数据效验，可以在定义的<code>实体中的属性上</code>，添加不同的注解来完成不同的校验规则，而在接口类中的接收数据参数中添加 @valid 注解，这时你的实体将会开启一个校验的功能。</li><li><code>@Valid 的相关注解</code>：在实体类中不同的属性上添加不同的注解，就能实现不同数据的效验功能。</li><li><code>使用 @Valid 进行参数效验步骤</code>：整个过程如下，用户访问接口，然后进行参数效验，因为 @Valid 不支持平面的参数效验（直接写在参数中字段的效验）所以基于 GET 请求的参数还是按照原先方式进行效验，而 POST 则可以以实体对象为参数，可以使用 @Valid 方式进行效验。如果效验通过，则进入业务逻辑，否则抛出异常，交由全局异常处理器进行处理。</li><li><code>@Validated与@Valid的区别</code>：<code>@Validated</code> 是 <code>@Valid</code> 的变体。通过声明实体中属性的 <code>groups</code> ，再搭配使用 <code>@Validated</code> ，就能决定哪些属性需要校验，哪些不需要校验。</li></ol><h3 id="全局异常处理"><a href="#全局异常处理" class="headerlink" title="全局异常处理"></a>全局异常处理</h3><ul><li>这个全局异常处理，可以根据自己的异常，自定义异常处理，并设置一个兜底的异常处理</li></ul><pre><code class="java">@ResponseBody@RestControllerAdvicepublic class ExceptionHandlerAdvice &#123;    protected Logger logger = LoggerFactory.getLogger(getClass());    @ExceptionHandler(MethodArgumentNotValidException.class)    public CommonResult&lt;Object&gt; handleValidationExceptions(MethodArgumentNotValidException ex) &#123;        logger.error(&quot;[handleValidationExceptions]&quot;, ex);        StringBuilder sb = new StringBuilder();        ex.getBindingResult().getAllErrors().forEach(error -&gt; &#123;            String fieldName = ((org.springframework.validation.FieldError) error).getField();            String errorMessage = error.getDefaultMessage();            sb.append(fieldName).append(&quot;:&quot;).append(errorMessage).append(&quot;;&quot;);        &#125;);        return CommonResult.error(sb.toString());    &#125;    /**     * 处理系统异常，兜底处理所有的一切     */    @ExceptionHandler(value = Exception.class)    public CommonResult&lt;?&gt; defaultExceptionHandler(Throwable ex) &#123;        logger.error(&quot;[defaultExceptionHandler]&quot;, ex);        // 返回 ERROR CommonResult        return CommonResult.error(INTERNAL_SERVER_ERROR.getCode(), INTERNAL_SERVER_ERROR.getMsg());    &#125;&#125;</code></pre><blockquote><p>就这么多，搞定，这样就拥有了漂流优雅的 controller 了</p></blockquote><h2 id="在日常开发中，还有那些血压飙升瞬间"><a href="#在日常开发中，还有那些血压飙升瞬间" class="headerlink" title="在日常开发中，还有那些血压飙升瞬间"></a>在日常开发中，还有那些血压飙升瞬间</h2><ul><li>我拿出下图阁下如何面对</li></ul><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/50e2544fc45f43f59e60864b2ee578fe~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1497&h=708&s=653333&e=png&b=31333e" alt="image-20240411185003067.png"></p><ul><li>这个阁下又如何面对，我不说，你能知道这个什么吗【狗头】</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e7c097401c3485cb3fe3253d9d14e50~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=276&h=108&s=7696&e=png&a=1&b=21252b" alt="image-20240411185134843.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>不是很明白为什么有些喜欢在 controller 写业务逻辑的，曾经有个同事问我（就是喜欢在 controller 写业务的），你这个接口写在那里，我需要调一下你这个接口。我满脸问号？？不是隔壁的模块吗，为什么要调我的接口？直接引用的我的 service 去调方法就好了。</li><li>这个就是痛点，各写各的，冗余代码一堆。</li><li>曾经看到一个同事写一个保存的方法，虽然逻辑挺多，我滑动了好久都还没有方法还没有结束。一个方法整整几百行……</li><li>看过 spring 源码都知道，spring 源码难啃，就是因为 spring 无限往下套娃，基本每个方法干每个方法的事情。比如我保存用户时，就只是保存用户，至于什么校验丢给校验的方法处理，什么发送消息丢给发送消息处理，这些就不能耦合在一起。</li><li>对于看到一些 if 下面一丢逻辑，然后 if 再一丢逻辑，看代码时很多情况不需要知道这个逻辑怎么实现的，知道入参出参就大概这里做什么了。即使想知道详细情况点进去就知道了。突出这个当前方法要做的事情就好了。</li><li>阿里的开发手册就推荐一个方法不能超过 80 行，超过可以根据业务具体调整一下。</li></ul><p>本文收录于以下专栏</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/95414745836549ce9143753e2a30facd~tplv-k3u1fbpfcp-jj:160:120:0:0:q75.avis" alt="cover"></p><p>上一篇</p><p>【事件驱动】两个独立模块如何实现解耦，除了消息队列还有没有其他方式？</p><p>下一篇</p><p>【API 导出工具】将 API 导出到 Excel 的工具类</p><p><img src="https://p3-passport.byteacctimg.com/img/user-avatar/78a01b2ead4e7cea39b7b3465945dec0~70x70.awebp" alt="avatar"></p>]]></content>
    
    
    <summary type="html">见过几千行代码的 controller吗？我见过。 见过全是 try catch 的 controller 吗，我见过。如何拥有一个优雅的 controller 呢？</summary>
    
    
    
    
    <category term="clippings" scheme="http://yelog.org/tags/clippings/"/>
    
  </entry>
  
  <entry>
    <title>字符串规范化(NFC/NFD)问题</title>
    <link href="http://yelog.org/2024/09/30/string-normalize-nfc-nfd/"/>
    <id>http://yelog.org/2024/09/30/string-normalize-nfc-nfd/</id>
    <published>2024-09-30T03:08:31.000Z</published>
    <updated>2024-09-30T03:54:09.921Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近同事在接入西班牙语的数据时, 发现了一个问题, 涉及到西班牙语中包含重音富符号的数据比对出了问题, 同事已经找出可能是字符串规范话(<code>Normalize</code>)的问题, 但是现象很奇怪, 今天就做了一些测试, 将测试结果记录下来. 以供大家参考.</p><p>常用规范化:</p><ul><li>NFC: 规范化组合型, 如 <code>é</code> 是一个字符</li><li>NFD: 规范化分解型, 如 <code>é</code> 是两个字符 <code>e</code> 和 <code>´</code></li><li>NFKC: 兼容性规范化组合型</li><li>NFKD: 兼容性规范化分解型</li></ul><h1 id="先说结论"><a href="#先说结论" class="headerlink" title="先说结论"></a>先说结论</h1><p>在 HTML&#x2F;JavasCript&#x2F;Java&#x2F;PostGreSQL 中, 不会自动对字符串的规范话进行转换, 也就是说, 从前端(html&#x2F;js)传递到后端(java), 再传递到数据库(PostGreSQL)的过程中, 字符串的规范化是不变的, 所以只是文字传递, 不会出现问题.</p><p>出问题的地方是文件系统:</p><ul><li>Windows 文件系统（如 NTFS）通常使用 <code>NFC</code> 形式存储文件名。</li><li>macOS 文件系统（如 HFS+ 或 APFS）通常使用 <code>NFD</code> 形式存储文件名。</li><li>Linux 文件系统（如 ext4）通常使用 <code>NFC</code>，但这也可能因环境和设置而异。</li></ul><p>导致上传文件时, 文件名的规范化不一致, 会导致文件名比对是不一致的.</p><h1 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h1><p>同名的文件名上传时, 会进入数据库比对一下文件名是否存在, 但是由于文件名的规范化不一致, 会导致文件名比对不一致. 从而重复上传文件.</p><p>比如我们做一个简单的测试, 如下代码, 页面上有两个元素, 一个文本输入框, 一个文件上传框, 当文件上传框选择文件后, 会比对文件名和文本输入框的值是否一致, 如果不一致, 则提示文件名不一致.</p><p>我们在本地新建一个文件, 文件名为 <code>é.txt</code>, 这个文件名的文本是 <code>NFC</code> 的形式, 当 <code>MacOS</code> 去页面上传文件, 会提示文件名不一致, windows 则提示文件名一致.</p><p>这是因为 <code>MacOS</code> 文件系统使用 <code>NFD</code> 形式存储文件名, 和文本输入框的值(<code>NFC</code>)不一致, 导致比对不一致.</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;    &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=&quot;text&quot; name=&quot;filename&quot; value=&quot;é.txt&quot; id=&#39;filename&#39;&gt;&lt;input type=&quot;file&quot; multiple accept=&quot;*/*&quot; onchange=&quot;previewFiles()&quot; id=&quot;fileInput&quot;&gt;&lt;/body&gt;&lt;script&gt;    // 监听事件,    const previewFiles = (e) =&gt; &#123;        const files = document.querySelector(&#39;#fileInput&#39;).files;        const filename = document.querySelector(&#39;#filename&#39;).value;        console.log(&#39;filename normalize:&#39;, detectNormalizationForm(filename));        console.log(&#39;file.name normalize:&#39;, detectNormalizationForm(files[0].name));        // 比对 id 为 filename 的值 和 上传的文件名是否一致        if (files.length === 0 || files[0].name !== filename) &#123;            alert(&#39;文件名不一致&#39;);            return;        &#125; else &#123;            alert(&#39;文件名一致&#39;);        &#125;    &#125;    function detectNormalizationForm(str) &#123;        if (str === str.normalize(&#39;NFC&#39;)) &#123;            return &#39;NFC&#39;;        &#125; else if (str === str.normalize(&#39;NFD&#39;)) &#123;            return &#39;NFD&#39;;        &#125; else if (str === str.normalize(&#39;NFKC&#39;)) &#123;            return &#39;NFKC&#39;;        &#125; else if (str === str.normalize(&#39;NFKD&#39;)) &#123;            return &#39;NFKD&#39;;        &#125; else &#123;            return &#39;Unknown&#39;;  // 如果没有匹配的规范化形式        &#125;    &#125;&lt;/script&gt;&lt;/html&gt;</code></pre><h1 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h1><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><p>前端可以在 <code>axios</code>&#x2F;<code>ajax</code> 等统一请求的地方, 对请求的参数进行规范化, 保证传递的参数是 <code>NFC</code> 形式.</p><p>在前端处理是有局限性的, 比如上传文件时, 无法对文件内容进行处理</p><h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><p>后端也有几个地方需要处理</p><ol><li>拦截 <code>Controller</code>, <code>HandlerInterceptor</code> 等请求处理的地方, 对请求参数进行规范化</li><li><code>Excel</code> 工具类, 解析成对象的地方, 对 <code>Excel</code> 中的字符串进行规范化(要求所有上传的 <code>Excel</code> 都使用这个方法进行解析)</li></ol><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>可以在 Mybatis 拦截器中, 对所有的 <code>SQL</code> 进行规范化, 保证数据库中的数据都是 <code>NFC</code> 形式.</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><blockquote><p>如无必要, 勿增实体.</p></blockquote><p>字符串作为系统中最常用的类型, 全部添加规范化会对系统的性能产生一定的影响. 系统如果涉及到重音符号的地方不多, 可以只在必要的地方进行规范化.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近同事在接入西班牙语的数据时, 发现了一个问题, 涉及到西班牙语中包含重音富符号的数据比对出了问题, 同事已经找出可能是字符串规范话(&lt;c</summary>
      
    
    
    
    <category term="大前端" scheme="http://yelog.org/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="java" scheme="http://yelog.org/tags/java/"/>
    
    <category term="javascript" scheme="http://yelog.org/tags/javascript/"/>
    
    <category term="encoding" scheme="http://yelog.org/tags/encoding/"/>
    
  </entry>
  
  <entry>
    <title>最强跳转插件 flash.nvim 在 ideavim 上使用是中什么体验</title>
    <link href="http://yelog.org/2024/09/05/ideavim-flash/"/>
    <id>http://yelog.org/2024/09/05/ideavim-flash/</id>
    <published>2024-09-05T14:47:36.000Z</published>
    <updated>2024-09-30T03:54:09.657Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近两三年都从 <code>Vim</code> 迁移到 <code>NeoVim</code> 之后, 使用到了非常多好用的插件, 尤其是跳转插件 <a href="https://github.com/folke/flash.nvim">folke&#x2F;flash.nvim</a> , 非常方便, 日常文档及一些软件开发(Web, rust, lua, python) 等已经在 <code>NeoVim</code> 下完成了</p><p>但是 <code>Java</code> 一直没有配置到像 <code>IntelijIdea</code> 那么方便, 所以 <code>Java</code> 的开发还是在 <code>IntelijIdea</code> 中完成, 好在有 <code>IdeaVim</code> 这个非常棒的插件, 大部分的 <code>Vim</code> 功能完成度非常高.</p><p>最大的缺点就是没有 <code>Vim</code>, <code>NeoVim</code> 的丰富的插件生态, 尤其是日常使用频率非常高的 <code>flash.nvim</code>, 所以就自己开发了一个在 <code>IdeaVim</code> 上的插件 <a href="https://github.com/yelog/vim-flash">vim-flash</a></p><blockquote><p>题外话: 本来叫 <code>ideavim-flash</code> 的, 在上传插件的时候, 因为存在关键字 <code>idea</code> 被驳回, 所以改名为 <code>vim-flash</code>.</p></blockquote><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="在线安装"><a href="#在线安装" class="headerlink" title="在线安装"></a>在线安装</h2><p>插件市场安装: Setting -&gt; Plugins -&gt; Marketplace -&gt; 搜索 <code>vim-flash</code>, 作者为 <code>yelog</code>, 然后点击安装.</p><p><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/202409052305048.png" alt="插件市场安装"></p><h2 id="离线安装"><a href="#离线安装" class="headerlink" title="离线安装"></a>离线安装</h2><ol><li>到官方仓库的 <code>Release</code> 中下载 <code>vim-flash-xxx.zip</code> 包, 地址 <a href="https://github.com/yelog/vim-flash/releases">vim-flash-release</a></li><li>Idea -&gt; Setting -&gt; Plugins -&gt; Install 旁边的齿轮 -&gt; Install Plugin from disk -&gt; 选择刚刚下载的 <code>vim-flash-xxx.zip</code> 包即可</li></ol><p><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/202409052310873.png" alt="离线安装"></p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>安装完成之后, 点击右下角的 <code>IdeaVim</code> 图标, 点击 <code>Open ~/.ideavimrc</code></p><p><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/202409052311037.png" alt="编辑 ideavimrc"></p><p>添加 <code>map s &lt;Action&gt;(flash.search)</code> 到最后一行, 然后点击右上角的刷新图标</p><p><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/202409052313446.png" alt="添加配置"></p><h1 id="使用和效果"><a href="#使用和效果" class="headerlink" title="使用和效果"></a>使用和效果</h1><h2 id="Normal-Mode"><a href="#Normal-Mode" class="headerlink" title="Normal Mode"></a>Normal Mode</h2><p>打开一个文件, 按 <code>Esc</code> 进入 <code>IdeaVim</code> 的 <code>Normal</code> 模式下, 比如我们要定位到 <code>MarksCanvas</code> 这个单词, 我们可以依次按键盘的字母: <code>smarks</code></p><ol><li>现在所有以包含 <code>marks</code> 的文字都高亮了, 并且后面跟着一个字母, 当我们按下某一个字母后, 就会发现光标到达了这个高亮处, 这就是这个插件的跳转功能.</li><li>有一个高丽是橙色底的, 那是距离我们光标最近的位置, 当我们按下 <strong>回车</strong> 后, 光标会跳转到这个高亮处.</li></ol><p><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/202409052324760.gif" alt="vim-flash-normal-usage"></p><h2 id="Visual-Mode"><a href="#Visual-Mode" class="headerlink" title="Visual Mode"></a>Visual Mode</h2><p>打开一个文件, 按 <code>v</code> 进入 <code>IdeaVim</code> 的 <code>Visual</code> 模式下, 我们可以通过类似于上面的跳转方式, 进行跳转选中</p><p><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/202409052328220.gif" alt="vim-flash-vistual-usage"></p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>我是一个热爱技术, 崇尚效率和善于利用工具的人, 我会持续分享所得, 如果有收获, 请帮忙点赞, 评论,  点 <code>start</code>, 谢谢!!!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近两三年都从 &lt;code&gt;Vim&lt;/code&gt; 迁移到 &lt;code&gt;NeoVim&lt;/code&gt; 之后, 使用到了非常多好用的插件, 尤其是</summary>
      
    
    
    
    <category term="VIM" scheme="http://yelog.org/categories/VIM/"/>
    
    
    <category term="vim" scheme="http://yelog.org/tags/vim/"/>
    
    <category term="neovim" scheme="http://yelog.org/tags/neovim/"/>
    
    <category term="ideavim" scheme="http://yelog.org/tags/ideavim/"/>
    
    <category term="idea" scheme="http://yelog.org/tags/idea/"/>
    
    <category term="jetbrain" scheme="http://yelog.org/tags/jetbrain/"/>
    
    <category term="editor" scheme="http://yelog.org/tags/editor/"/>
    
  </entry>
  
  <entry>
    <title>适合个人开发者的免费软件</title>
    <link href="http://yelog.org/2024/08/30/free-tools/"/>
    <id>http://yelog.org/2024/08/30/free-tools/</id>
    <published>2024-08-30T03:25:56.000Z</published>
    <updated>2024-09-30T03:54:10.878Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇文章是听《硬地骇客》的EP19 “白嫖” SaaS 工具，零成本起步开发一款产品</p><p><a href="https://hardhacker.com/tools">https://hardhacker.com/tools</a></p><h2 id="涉及工具"><a href="#涉及工具" class="headerlink" title="涉及工具"></a>涉及工具</h2><h3 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h3><ol><li>Vercel 快速部署和扩展前端应用<br> a. <a href="https://vercel.com/">https://vercel.com</a><br> b. 100G&#x2F;月<br> c. 免费独立域名</li><li>netlify 托管和部署静态页面 CDN加速<br> a. <a href="https://netlify.com/">https://netlify.com</a><br> b. 100G&#x2F;月<br> c. 免费绑定域名</li></ol><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><ol><li>PlanetScale 数据库服务 vitess， 能够处理大规模数据的存储和查询需求<br> a. 5G存储<br> b. 1B行读取<br> c. 10M行写入<br> d. <a href="https://planetscale.com/">https://planetscale.com</a></li></ol><h3 id="CND"><a href="#CND" class="headerlink" title="CND"></a>CND</h3><ol><li>Cloudfare 网页应用， 提供 CDN加速、DDos攻击防护、SSL加密、防火墙、缓存优化等<br> a. 3个 CDN 页面规则<br> b. SSL证书<br> c. DDos防御<br> d. <a href="https://cloudflare.com/">https://cloudflare.com</a></li></ol><h3 id="权限校验"><a href="#权限校验" class="headerlink" title="权限校验"></a>权限校验</h3><ol><li>Supabase 提供 pgsql 的开发平台，能够快速搭建和扩展应用程序后端， 提供数据库、实施推送、身份验证、文件存储等<br> a. 50000月活用户<br> b. 200并发连接<br> c. <a href="https://supabase.com/">https://supabase.com</a></li><li>clerk 用户验证管理， 集成角色&#x2F;权限管理等<br> a. 5000月活用户<br> b. <a href="https://clerk.com/">https://clerk.com</a></li></ol><h3 id="email"><a href="#email" class="headerlink" title="email"></a>email</h3><ol><li>Amazon SES: 通过简单的 api 调用或 smtp 接口来发送和接收邮件<br> a. 62000封&#x2F;月<br> b. <a href="https://aws.amazon.com/ses/">https://aws.amazon.com/ses/</a></li><li>Resend 简单优雅， 致力于做最好的邮件API<br> a. 3000封&#x2F;月<br> b. <a href="https://resend.com/">https://resend.com</a></li></ol><h3 id="Document"><a href="#Document" class="headerlink" title="Document"></a>Document</h3><ol><li>Notions<br> a. 提供了灵活的工作区， 让用户可以创建和组织各种类型的内容，如文本、表格、任务列表、日历等， 强大的协作功能<br> b. 无限页面<br> c. 10个合作者<br> d. notion.site 域名<br> e. <a href="https://notion.so/">https://notion.so/</a></li></ol><h3 id="Payment"><a href="#Payment" class="headerlink" title="Payment"></a>Payment</h3><ol><li>Stripe 全面的支付服务，支持信用卡、借记卡和其他支付方式<br> a. 费率 2.9% + 30<br> b. <a href="https://stripe.com/">https://stripe.com/</a></li><li>Paypal 广泛使用、电子商务、个人转账和在线付款<br> a. 4.4% + 30<br> b. <a href="https://paypal.com/">https://paypal.com</a></li><li>Lemon Squeezy 简单易用的支付服务商，特点：便捷、灵活、安全。帮用户轻松实现跨境支付<br> a. 5% + 50<br> b. <a href="https://lemonsqueezy.com/">https://lemonsqueezy.com</a></li><li>Paddle 综合解决方案：支付处理、订阅管理、许可证控制和全球化销售<br> a. 5% + 50<br> b. <a href="https://paddle.com/">https://paddle.com/</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本篇文章是听《硬地骇客》的EP19 “白嫖” SaaS 工具，零成本起步开发一款产品&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://har</summary>
      
    
    
    
    <category term="工具" scheme="http://yelog.org/categories/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="软件记录" scheme="http://yelog.org/categories/%E5%B7%A5%E5%85%B7/%E8%BD%AF%E4%BB%B6%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="free" scheme="http://yelog.org/tags/free/"/>
    
    <category term="tools" scheme="http://yelog.org/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>ranger(终端文件管理器)-快捷键</title>
    <link href="http://yelog.org/2024/08/30/ranger-shortcut/"/>
    <id>http://yelog.org/2024/08/30/ranger-shortcut/</id>
    <published>2024-08-30T03:20:40.000Z</published>
    <updated>2024-09-30T03:54:09.805Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ranger"><a href="#ranger" class="headerlink" title="ranger"></a>ranger</h2><table><thead><tr><th align="left">快捷键</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">ra</td><td align="left">启动应用</td></tr><tr><td align="left">q</td><td align="left">退出应用</td></tr><tr><td align="left">zh</td><td align="left">显示&#x2F;隐藏 隐藏文件</td></tr><tr><td align="left">zp</td><td align="left">打开&#x2F;关闭文件预览</td></tr><tr><td align="left">zP</td><td align="left">打开目录预览功能</td></tr><tr><td align="left">w</td><td align="left">打开&#x2F;关闭任务管理器 - 可以通过 dd 取消一个任务（比如正在移动一个大文件，取消之后就相当于没有操作</td></tr></tbody></table><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><table><thead><tr><th align="left">快捷键</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">yy</td><td align="left">复制</td></tr><tr><td align="left">yp</td><td align="left">复制全路径</td></tr><tr><td align="left">pp</td><td align="left">粘贴</td></tr><tr><td align="left">po</td><td align="left">粘贴并替换</td></tr><tr><td align="left">dd</td><td align="left">剪切</td></tr><tr><td align="left">dD</td><td align="left">删除</td></tr><tr><td align="left">cw</td><td align="left">重命名&#x2F;如果选中文件则bulkrename</td></tr><tr><td align="left">o</td><td align="left">排序</td></tr><tr><td align="left">A</td><td align="left">重命名, 在当前文件名基础上，光标在当前文件名后</td></tr><tr><td align="left">I</td><td align="left">重命名，在当前文件看基础上，光标在当前文件名前</td></tr><tr><td align="left">v</td><td align="left">全选&lt;当前目录 切换 如果选中则取消选中；如果没有选中, 则选中&gt;</td></tr><tr><td align="left">uv</td><td align="left">取消所有选中</td></tr><tr><td align="left">space</td><td align="left">选中或取消当前光标所在文件&#x2F;目录</td></tr><tr><td align="left">:bulkrename</td><td align="left">编辑选中的文件名</td></tr><tr><td align="left">C</td><td align="left">压缩文件，file.zip</td></tr><tr><td align="left">X</td><td align="left">解压文件 需要先复制文件在执行</td></tr></tbody></table><table><thead><tr><th align="left">快捷键</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">E</td><td align="left">使用vim编辑光标所在的文件</td></tr><tr><td align="left">V</td><td align="left">使用vim编辑输入的文件（可创建</td></tr><tr><td align="left">r</td><td align="left">选择编辑或运行的命令</td></tr></tbody></table><h3 id="移动跳转"><a href="#移动跳转" class="headerlink" title="移动跳转"></a>移动跳转</h3><table><thead><tr><th align="left">快捷键</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">hjkl</td><td align="left">左(上一层)下上右(下一层)</td></tr><tr><td align="left">[&#x2F;]</td><td align="left">上层目录的上&#x2F;xx</td></tr><tr><td align="left">gg&#x2F;G</td><td align="left">顶部&#x2F;底部</td></tr><tr><td align="left">H&#x2F;L</td><td align="left">回到上次浏览文件夹&#x2F;撤销回退</td></tr><tr><td align="left">f</td><td align="left">模糊搜索当前及递归文件 fzf</td></tr><tr><td align="left">zf</td><td align="left">过滤，只显示搜索匹配的文件</td></tr><tr><td align="left">&#x2F;</td><td align="left">当前目录搜索关键字 输入关键字后可直接 tab 进行查找</td></tr><tr><td align="left">gf</td><td align="left">跳到 f 绑定的目录，这里配置的是 ranger 的配置文件，其他字母可自己配置</td></tr><tr><td align="left">S</td><td align="left">跳到当前文件夹所在的命令行</td></tr></tbody></table><h3 id="标签-tab"><a href="#标签-tab" class="headerlink" title="标签 tab"></a>标签 tab</h3><table><thead><tr><th align="left">快捷键</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">gn</td><td align="left">新建标签</td></tr><tr><td align="left">gc</td><td align="left">删除标签</td></tr><tr><td align="left">tab</td><td align="left">切换标签</td></tr><tr><td align="left">gt</td><td align="left">切换标签 1</td></tr><tr><td align="left">gT</td><td align="left">切换标签 -1</td></tr></tbody></table><h3 id="书签"><a href="#书签" class="headerlink" title="书签"></a>书签</h3><table><thead><tr><th align="left">快捷键</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">&#96;</td><td align="left">显示书签列表&#x2F;打开书签</td></tr><tr><td align="left">m</td><td align="left">新建书签</td></tr><tr><td align="left">um</td><td align="left">删除书签</td></tr><tr><td align="left">V</td><td align="left">vim 文件，可以通过这个快捷键新建文件</td></tr></tbody></table><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>2024-08-30 现在已经转战到了 <a href="https://github.com/sxyazi/yazi">yazi</a> 了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ranger&quot;&gt;&lt;a href=&quot;#ranger&quot; class=&quot;headerlink&quot; title=&quot;ranger&quot;&gt;&lt;/a&gt;ranger&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;快捷键&lt;/th&gt;
&lt;th align=</summary>
      
    
    
    
    <category term="工具" scheme="http://yelog.org/categories/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="软件记录" scheme="http://yelog.org/categories/%E5%B7%A5%E5%85%B7/%E8%BD%AF%E4%BB%B6%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="vim" scheme="http://yelog.org/tags/vim/"/>
    
    <category term="terminal" scheme="http://yelog.org/tags/terminal/"/>
    
    <category term="file-manager" scheme="http://yelog.org/tags/file-manager/"/>
    
  </entry>
  
  <entry>
    <title>Rancher 常用操作</title>
    <link href="http://yelog.org/2024/08/30/rancher-operations/"/>
    <id>http://yelog.org/2024/08/30/rancher-operations/</id>
    <published>2024-08-30T03:17:23.000Z</published>
    <updated>2024-09-30T03:54:09.985Z</updated>
    
    <content type="html"><![CDATA[<h3 id="创建-Rancher-Server-数据副本"><a href="#创建-Rancher-Server-数据副本" class="headerlink" title="创建 Rancher Server 数据副本"></a>创建 Rancher Server 数据副本</h3><pre><code class="bash">docker stop lemes-rancher-2.5docker create --volumes-from lemes-rancher-2.5 --name rancher-data-2023-02-21 rancher/rancher:v2.5.12</code></pre><h3 id="创建备份压缩包"><a href="#创建备份压缩包" class="headerlink" title="创建备份压缩包"></a>创建备份压缩包</h3><pre><code class="bash">docker run --volumes-from rancher-data-2023-02-21 -v $PWD:/backup busybox tar zcvf /backup/rancher-data-backup-2023-02-21.tar.gz /var/lib/rancher</code></pre><h3 id="拉去最新镜像"><a href="#拉去最新镜像" class="headerlink" title="拉去最新镜像"></a>拉去最新镜像</h3><pre><code class="bash">docker pull rancher/rancher:v2.5.12docker run -d --restart=unless-stopped \  --volumes-from rancher-data-backup-2023-02-20 \  -p 80:80 -p 443:443 \  --privileged \  --name=lemes-rancher-2.6 \  rancher/rancher:v2.5.12</code></pre><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="升级镜像"><a href="#升级镜像" class="headerlink" title="升级镜像"></a>升级镜像</h3><pre><code class="bash">curl -k -X GET -H &#39;Accept: application/json&#39; -H &#39;Accept: application/json&#39; -H &#39;Content-Type: application/json&#39; -H &#39;Authorization: Bearer token-fpcvv:6k4s8klp5hg9bmdp25x99hgd5hs7s94rlfsxz7pvn2hfp9sp2xdz6m&#39; &#39;https://10.176.66.20/v3/project/c-b62fg:p-rqhfd/workloads/deployment:default:lemes-auth&#39;curl -k -X PUT -H &#39;Accept: application/json&#39; -H &#39;Accept: application/json&#39; -H &#39;Content-Type: application/json&#39; -H &#39;Authorization: Bearer token-fpcvv:6k4s8klp5hg9bmdp25x99hgd5hs7s94rlfsxz7pvn2hfp9sp2xdz6m&#39; -d &#39;&#123;&quot;actions&quot;:&#123;&quot;pause&quot;:&quot;https://10.176.66.20/v3/project/c-b62fg:p-rqhfd/workloads/deployment:default:lemes-gateway?action=pause&quot;,&quot;redeploy&quot;:&quot;https://10.176.66.20/v3/project/c-b62fg:p-rqhfd/workloads/deployment:default:lemes-gateway?action=redeploy&quot;,&quot;resume&quot;:&quot;https://10.176.66.20/v3/project/c-b62fg:p-rqhfd/workloads/deployment:default:lemes-gateway?action=resume&quot;,&quot;rollback&quot;:&quot;https://10.176.66.20/v3/project/c-b62fg:p-rqhfd/workloads/deployment:default:lemes-gateway?action=rollback&quot;&#125;,&quot;annotations&quot;:&#123;&quot;cattle.io/timestamp&quot;:&quot;2022-04-24T14:29:549+0800&quot;&#125;,&quot;baseType&quot;:&quot;workload&quot;,&quot;containers&quot;:[&#123;&quot;environmentFrom&quot;:[&#123;&quot;optional&quot;:false,&quot;source&quot;:&quot;field&quot;,&quot;sourceName&quot;:&quot;metadata.name&quot;,&quot;targetKey&quot;:&quot;POD_NAME&quot;&#125;,&#123;&quot;optional&quot;:false,&quot;source&quot;:&quot;field&quot;,&quot;sourceName&quot;:&quot;metadata.namespace&quot;,&quot;targetKey&quot;:&quot;POD_NAMESPACE&quot;&#125;,&#123;&quot;optional&quot;:false,&quot;source&quot;:&quot;configMap&quot;,&quot;sourceKey&quot;:&quot;nacos.addr&quot;,&quot;sourceName&quot;:&quot;lemes-cm&quot;,&quot;targetKey&quot;:&quot;NACOS_ADDR&quot;&#125;,&#123;&quot;optional&quot;:false,&quot;source&quot;:&quot;configMap&quot;,&quot;sourceKey&quot;:&quot;nacos.group&quot;,&quot;sourceName&quot;:&quot;lemes-cm&quot;,&quot;targetKey&quot;:&quot;NACOS_GROUP&quot;&#125;,&#123;&quot;optional&quot;:false,&quot;source&quot;:&quot;configMap&quot;,&quot;sourceKey&quot;:&quot;nacos.namespace&quot;,&quot;sourceName&quot;:&quot;lemes-cm&quot;,&quot;targetKey&quot;:&quot;NACOS_NAMESPACE&quot;&#125;,&#123;&quot;optional&quot;:false,&quot;source&quot;:&quot;configMap&quot;,&quot;sourceKey&quot;:&quot;tz&quot;,&quot;sourceName&quot;:&quot;lemes-cm&quot;,&quot;targetKey&quot;:&quot;TZ&quot;&#125;,&#123;&quot;optional&quot;:false,&quot;source&quot;:&quot;configMap&quot;,&quot;sourceKey&quot;:&quot;java.opts&quot;,&quot;sourceName&quot;:&quot;lemes-cm&quot;,&quot;targetKey&quot;:&quot;JAVA_OPTS&quot;&#125;,&#123;&quot;optional&quot;:false,&quot;source&quot;:&quot;configMap&quot;,&quot;sourceKey&quot;:&quot;java.skywalking&quot;,&quot;sourceName&quot;:&quot;lemes-cm&quot;,&quot;targetKey&quot;:&quot;SKYWALKING&quot;&#125;],&quot;image&quot;:&quot;10.176.66.20:5000/lemes-cloud/lemes-gateway:develop-202204241429&quot;,&quot;imagePullPolicy&quot;:&quot;Always&quot;,&quot;initContainer&quot;:false,&quot;livenessProbe&quot;:&#123;&quot;failureThreshold&quot;:10,&quot;initialDelaySeconds&quot;:5,&quot;path&quot;:&quot;/actuator/health/liveness&quot;,&quot;periodSeconds&quot;:5,&quot;port&quot;:80,&quot;scheme&quot;:&quot;HTTP&quot;,&quot;successThreshold&quot;:1,&quot;tcp&quot;:false,&quot;timeoutSeconds&quot;:10,&quot;type&quot;:&quot;/v3/project/schemas/probe&quot;&#125;,&quot;name&quot;:&quot;lemes-gateway&quot;,&quot;ports&quot;:[&#123;&quot;containerPort&quot;:80,&quot;dnsName&quot;:&quot;lemes-gateway&quot;,&quot;hostPort&quot;:0,&quot;kind&quot;:&quot;ClusterIP&quot;,&quot;name&quot;:&quot;80tcp02&quot;,&quot;protocol&quot;:&quot;TCP&quot;,&quot;sourcePort&quot;:0,&quot;type&quot;:&quot;/v3/project/schemas/containerPort&quot;&#125;],&quot;readinessProbe&quot;:&#123;&quot;failureThreshold&quot;:3,&quot;initialDelaySeconds&quot;:5,&quot;path&quot;:&quot;/actuator/health/readiness&quot;,&quot;periodSeconds&quot;:5,&quot;port&quot;:80,&quot;scheme&quot;:&quot;HTTP&quot;,&quot;successThreshold&quot;:1,&quot;tcp&quot;:false,&quot;timeoutSeconds&quot;:10,&quot;type&quot;:&quot;/v3/project/schemas/probe&quot;&#125;,&quot;resources&quot;:&#123;&quot;type&quot;:&quot;/v3/project/schemas/resourceRequirements&quot;&#125;,&quot;restartCount&quot;:0,&quot;stdin&quot;:false,&quot;stdinOnce&quot;:false,&quot;terminationMessagePath&quot;:&quot;/dev/termination-log&quot;,&quot;terminationMessagePolicy&quot;:&quot;File&quot;,&quot;tty&quot;:false,&quot;type&quot;:&quot;/v3/project/schemas/container&quot;,&quot;volumeMounts&quot;:[&#123;&quot;mountPath&quot;:&quot;/sidecar&quot;,&quot;name&quot;:&quot;sidecar&quot;,&quot;readOnly&quot;:false,&quot;type&quot;:&quot;/v3/project/schemas/volumeMount&quot;&#125;]&#125;,&#123;&quot;entrypoint&quot;:[&quot;cp&quot;,&quot;-r&quot;,&quot;/opt/tingyun&quot;,&quot;/sidecar&quot;],&quot;image&quot;:&quot;10.176.66.20:5000/library/tingyun:3.6.1.4&quot;,&quot;imagePullPolicy&quot;:&quot;Always&quot;,&quot;initContainer&quot;:true,&quot;name&quot;:&quot;tingyun&quot;,&quot;ports&quot;:[],&quot;resources&quot;:&#123;&quot;type&quot;:&quot;/v3/project/schemas/resourceRequirements&quot;&#125;,&quot;restartCount&quot;:0,&quot;stdin&quot;:false,&quot;stdinOnce&quot;:false,&quot;terminationMessagePath&quot;:&quot;/dev/termination-log&quot;,&quot;terminationMessagePolicy&quot;:&quot;File&quot;,&quot;tty&quot;:false,&quot;type&quot;:&quot;/v3/project/schemas/container&quot;,&quot;volumeMounts&quot;:[&#123;&quot;mountPath&quot;:&quot;/sidecar&quot;,&quot;name&quot;:&quot;sidecar&quot;,&quot;readOnly&quot;:false,&quot;type&quot;:&quot;/v3/project/schemas/volumeMount&quot;&#125;]&#125;],&quot;created&quot;:&quot;2022-04-12T04:39:45Z&quot;,&quot;createdTS&quot;:1649738385000,&quot;creatorId&quot;:null,&quot;deploymentConfig&quot;:&#123;&quot;maxSurge&quot;:&quot;25%&quot;,&quot;maxUnavailable&quot;:&quot;25%&quot;,&quot;minReadySeconds&quot;:0,&quot;progressDeadlineSeconds&quot;:600,&quot;revisionHistoryLimit&quot;:10,&quot;strategy&quot;:&quot;RollingUpdate&quot;&#125;,&quot;deploymentStatus&quot;:&#123;&quot;availableReplicas&quot;:2,&quot;conditions&quot;:[&#123;&quot;lastTransitionTime&quot;:&quot;2022-04-12T04:41:16Z&quot;,&quot;lastTransitionTimeTS&quot;:1649738476000,&quot;lastUpdateTime&quot;:&quot;2022-04-12T04:41:16Z&quot;,&quot;lastUpdateTimeTS&quot;:1649738476000,&quot;message&quot;:&quot;Deployment has minimum availability.&quot;,&quot;reason&quot;:&quot;MinimumReplicasAvailable&quot;,&quot;status&quot;:&quot;True&quot;,&quot;type&quot;:&quot;Available&quot;&#125;,&#123;&quot;lastTransitionTime&quot;:&quot;2022-04-12T04:39:45Z&quot;,&quot;lastTransitionTimeTS&quot;:1649738385000,&quot;lastUpdateTime&quot;:&quot;2022-04-22T06:34:17Z&quot;,&quot;lastUpdateTimeTS&quot;:1650609257000,&quot;message&quot;:&quot;ReplicaSet \&quot;lemes-gateway-78f8577b78\&quot; has successfully progressed.&quot;,&quot;reason&quot;:&quot;NewReplicaSetAvailable&quot;,&quot;status&quot;:&quot;True&quot;,&quot;type&quot;:&quot;Progressing&quot;&#125;],&quot;observedGeneration&quot;:5,&quot;readyReplicas&quot;:2,&quot;replicas&quot;:2,&quot;type&quot;:&quot;/v3/project/schemas/deploymentStatus&quot;,&quot;unavailableReplicas&quot;:0,&quot;updatedReplicas&quot;:2&#125;,&quot;dnsPolicy&quot;:&quot;ClusterFirst&quot;,&quot;hostIPC&quot;:false,&quot;hostNetwork&quot;:false,&quot;hostPID&quot;:false,&quot;id&quot;:&quot;deployment:default:lemes-gateway&quot;,&quot;labels&quot;:&#123;&quot;app&quot;:&quot;lemes-gateway&quot;&#125;,&quot;links&quot;:&#123;&quot;remove&quot;:&quot;https://10.176.66.20/v3/project/c-b62fg:p-rqhfd/workloads/deployment:default:lemes-gateway&quot;,&quot;revisions&quot;:&quot;https://10.176.66.20/v3/project/c-b62fg:p-rqhfd/workloads/deployment:default:lemes-gateway/revisions&quot;,&quot;self&quot;:&quot;https://10.176.66.20/v3/project/c-b62fg:p-rqhfd/workloads/deployment:default:lemes-gateway&quot;,&quot;update&quot;:&quot;https://10.176.66.20/v3/project/c-b62fg:p-rqhfd/workloads/deployment:default:lemes-gateway&quot;,&quot;yaml&quot;:&quot;https://10.176.66.20/v3/project/c-b62fg:p-rqhfd/workloads/deployment:default:lemes-gateway/yaml&quot;&#125;,&quot;name&quot;:&quot;lemes-gateway&quot;,&quot;namespaceId&quot;:&quot;default&quot;,&quot;paused&quot;:false,&quot;projectId&quot;:&quot;c-b62fg:p-rqhfd&quot;,&quot;publicEndpoints&quot;:[&#123;&quot;addresses&quot;:[&quot;10.122.73.49&quot;],&quot;allNodes&quot;:true,&quot;ingressId&quot;:&quot;default:lemes-gateway-ig&quot;,&quot;nodeId&quot;:null,&quot;path&quot;:&quot;/lemes-api(/|$)(.*)&quot;,&quot;podId&quot;:null,&quot;port&quot;:80,&quot;protocol&quot;:&quot;HTTP&quot;,&quot;serviceId&quot;:&quot;default:lemes-gateway-svc&quot;&#125;,&#123;&quot;addresses&quot;:[&quot;10.122.73.49&quot;],&quot;allNodes&quot;:true,&quot;ingressId&quot;:&quot;default:lemes-gateway-ig&quot;,&quot;nodeId&quot;:null,&quot;path&quot;:&quot;/lemes-api(/|$)(.*)&quot;,&quot;podId&quot;:null,&quot;port&quot;:443,&quot;protocol&quot;:&quot;HTTPS&quot;,&quot;serviceId&quot;:&quot;default:lemes-gateway-svc&quot;&#125;],&quot;restartPolicy&quot;:&quot;Always&quot;,&quot;scale&quot;:2,&quot;scheduling&quot;:&#123;&quot;scheduler&quot;:&quot;default-scheduler&quot;&#125;,&quot;selector&quot;:&#123;&quot;matchLabels&quot;:&#123;&quot;app&quot;:&quot;lemes-gateway&quot;&#125;,&quot;type&quot;:&quot;/v3/project/schemas/labelSelector&quot;&#125;,&quot;state&quot;:&quot;active&quot;,&quot;terminationGracePeriodSeconds&quot;:30,&quot;transitioning&quot;:&quot;no&quot;,&quot;transitioningMessage&quot;:&quot;&quot;,&quot;type&quot;:&quot;deployment&quot;,&quot;uuid&quot;:&quot;3afee259-1c17-48c0-8044-19ef85238736&quot;,&quot;volumes&quot;:[&#123;&quot;emptyDir&quot;:&#123;&quot;type&quot;:&quot;/v3/project/schemas/emptyDirVolumeSource&quot;&#125;,&quot;name&quot;:&quot;sidecar&quot;,&quot;type&quot;:&quot;/v3/project/schemas/volume&quot;&#125;],&quot;workloadAnnotations&quot;:&#123;&quot;deployment.kubernetes.io/revision&quot;:&quot;4&quot;,&quot;kubectl.kubernetes.io/last-applied-configuration&quot;:&quot;&#123;\&quot;apiVersion\&quot;:\&quot;apps/v1\&quot;,\&quot;kind\&quot;:\&quot;Deployment\&quot;,\&quot;metadata\&quot;:&#123;\&quot;annotations\&quot;:&#123;&#125;,\&quot;labels\&quot;:&#123;\&quot;app\&quot;:\&quot;lemes-gateway\&quot;&#125;,\&quot;name\&quot;:\&quot;lemes-gateway\&quot;,\&quot;namespace\&quot;:\&quot;default\&quot;&#125;,\&quot;spec\&quot;:&#123;\&quot;replicas\&quot;:2,\&quot;selector\&quot;:&#123;\&quot;matchLabels\&quot;:&#123;\&quot;app\&quot;:\&quot;lemes-gateway\&quot;&#125;&#125;,\&quot;template\&quot;:&#123;\&quot;metadata\&quot;:&#123;\&quot;labels\&quot;:&#123;\&quot;app\&quot;:\&quot;lemes-gateway\&quot;&#125;&#125;,\&quot;spec\&quot;:&#123;\&quot;containers\&quot;:[&#123;\&quot;env\&quot;:[&#123;\&quot;name\&quot;:\&quot;POD_NAME\&quot;,\&quot;valueFrom\&quot;:&#123;\&quot;fieldRef\&quot;:&#123;\&quot;apiVersion\&quot;:\&quot;v1\&quot;,\&quot;fieldPath\&quot;:\&quot;metadata.name\&quot;&#125;&#125;&#125;,&#123;\&quot;name\&quot;:\&quot;POD_NAMESPACE\&quot;,\&quot;valueFrom\&quot;:&#123;\&quot;fieldRef\&quot;:&#123;\&quot;apiVersion\&quot;:\&quot;v1\&quot;,\&quot;fieldPath\&quot;:\&quot;metadata.namespace\&quot;&#125;&#125;&#125;,&#123;\&quot;name\&quot;:\&quot;NACOS_ADDR\&quot;,\&quot;valueFrom\&quot;:&#123;\&quot;configMapKeyRef\&quot;:&#123;\&quot;key\&quot;:\&quot;nacos.addr\&quot;,\&quot;name\&quot;:\&quot;lemes-cm\&quot;&#125;&#125;&#125;,&#123;\&quot;name\&quot;:\&quot;NACOS_GROUP\&quot;,\&quot;valueFrom\&quot;:&#123;\&quot;configMapKeyRef\&quot;:&#123;\&quot;key\&quot;:\&quot;nacos.group\&quot;,\&quot;name\&quot;:\&quot;lemes-cm\&quot;&#125;&#125;&#125;,&#123;\&quot;name\&quot;:\&quot;NACOS_NAMESPACE\&quot;,\&quot;valueFrom\&quot;:&#123;\&quot;configMapKeyRef\&quot;:&#123;\&quot;key\&quot;:\&quot;nacos.namespace\&quot;,\&quot;name\&quot;:\&quot;lemes-cm\&quot;&#125;&#125;&#125;,&#123;\&quot;name\&quot;:\&quot;TZ\&quot;,\&quot;valueFrom\&quot;:&#123;\&quot;configMapKeyRef\&quot;:&#123;\&quot;key\&quot;:\&quot;tz\&quot;,\&quot;name\&quot;:\&quot;lemes-cm\&quot;&#125;&#125;&#125;,&#123;\&quot;name\&quot;:\&quot;JAVA_OPTS\&quot;,\&quot;valueFrom\&quot;:&#123;\&quot;configMapKeyRef\&quot;:&#123;\&quot;key\&quot;:\&quot;java.opts\&quot;,\&quot;name\&quot;:\&quot;lemes-cm\&quot;&#125;&#125;&#125;,&#123;\&quot;name\&quot;:\&quot;SKYWALKING\&quot;,\&quot;valueFrom\&quot;:&#123;\&quot;configMapKeyRef\&quot;:&#123;\&quot;key\&quot;:\&quot;java.skywalking\&quot;,\&quot;name\&quot;:\&quot;lemes-cm\&quot;&#125;&#125;&#125;],\&quot;image\&quot;:\&quot;10.176.66.20:5000/lemes-cloud/lemes-gateway:develop-202204111455\&quot;,\&quot;imagePullPolicy\&quot;:\&quot;Always\&quot;,\&quot;livenessProbe\&quot;:&#123;\&quot;failureThreshold\&quot;:10,\&quot;httpGet\&quot;:&#123;\&quot;path\&quot;:\&quot;/actuator/health/liveness\&quot;,\&quot;port\&quot;:80&#125;,\&quot;initialDelaySeconds\&quot;:5,\&quot;periodSeconds\&quot;:5,\&quot;timeoutSeconds\&quot;:10&#125;,\&quot;name\&quot;:\&quot;lemes-gateway\&quot;,\&quot;ports\&quot;:[&#123;\&quot;containerPort\&quot;:80&#125;],\&quot;readinessProbe\&quot;:&#123;\&quot;httpGet\&quot;:&#123;\&quot;path\&quot;:\&quot;/actuator/health/readiness\&quot;,\&quot;port\&quot;:80&#125;,\&quot;initialDelaySeconds\&quot;:5,\&quot;periodSeconds\&quot;:5,\&quot;timeoutSeconds\&quot;:10&#125;,\&quot;volumeMounts\&quot;:[&#123;\&quot;mountPath\&quot;:\&quot;/sidecar\&quot;,\&quot;name\&quot;:\&quot;sidecar\&quot;&#125;]&#125;],\&quot;initContainers\&quot;:[&#123;\&quot;command\&quot;:[\&quot;cp\&quot;,\&quot;-r\&quot;,\&quot;/opt/tingyun\&quot;,\&quot;/sidecar\&quot;],\&quot;image\&quot;:\&quot;10.176.66.20:5000/library/tingyun:3.6.1.4\&quot;,\&quot;imagePullPolicy\&quot;:\&quot;Always\&quot;,\&quot;name\&quot;:\&quot;tingyun\&quot;,\&quot;volumeMounts\&quot;:[&#123;\&quot;mountPath\&quot;:\&quot;/sidecar\&quot;,\&quot;name\&quot;:\&quot;sidecar\&quot;&#125;]&#125;],\&quot;volumes\&quot;:[&#123;\&quot;emptyDir\&quot;:&#123;&#125;,\&quot;name\&quot;:\&quot;sidecar\&quot;&#125;]&#125;&#125;&#125;&#125;&quot;&#125;,&quot;workloadLabels&quot;:&#123;&quot;app&quot;:&quot;lemes-gateway&quot;&#125;&#125;&#39; &#39;https://10.176.66.20/v3/project/c-b62fg:p-rqhfd/workloads/deployment:default:lemes-auth&#39;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;创建-Rancher-Server-数据副本&quot;&gt;&lt;a href=&quot;#创建-Rancher-Server-数据副本&quot; class=&quot;headerlink&quot; title=&quot;创建 Rancher Server 数据副本&quot;&gt;&lt;/a&gt;创建 Rancher Server 数据</summary>
      
    
    
    
    <category term="运维" scheme="http://yelog.org/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
    <category term="docker" scheme="http://yelog.org/tags/docker/"/>
    
    <category term="rancher" scheme="http://yelog.org/tags/rancher/"/>
    
  </entry>
  
  <entry>
    <title>k8s 集群搭建和使用及常见问题处理</title>
    <link href="http://yelog.org/2024/08/30/k8s-cluster-and-common-problems/"/>
    <id>http://yelog.org/2024/08/30/k8s-cluster-and-common-problems/</id>
    <published>2024-08-30T03:16:06.000Z</published>
    <updated>2024-09-30T03:54:09.980Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>kubernetes: k8s 是谷歌在2014年开源的容器化集群管理系统</p><ul><li><p><strong>Pod</strong> Pod 是可以在 Kubernetes 中创建和管理的、最小的可部署的计算单元</p></li><li><p>网络控制器</p></li><li><p>ApiServer: Uniform interface for access by all services</p></li><li><p>ControllerManager: Maintaining Copy Expectations</p></li><li><p><code>kubeadm</code>: the command to bootstrap the cluster.</p></li><li><p><code>kubelet</code>: the component that runs on all of the machines in your cluster and does things like starting pods and containers.</p></li><li><p><code>kubectl</code>: the command line util to talk to your cluster.</p></li></ul><h2 id="搭建方式"><a href="#搭建方式" class="headerlink" title="搭建方式"></a>搭建方式</h2><h3 id="kubeadmin"><a href="#kubeadmin" class="headerlink" title="kubeadmin"></a>kubeadmin</h3><p><a href="https://kubernetes.io/docs/reference/setup-tools/kubeadm/">kubeadm</a></p><h4 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h4><p>master和nodes 均需要执行一下步骤进行安装</p><pre><code class="bash">cat &lt;&lt;EOF | sudo tee /etc/yum.repos.d/kubernetes.repo[kubernetes]name=Kubernetesbaseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64enabled=1gpgcheck=1repo_gpgcheck=1gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpgexclude=kubelet kubeadm kubectlEOF# Set SELinux in permissive mode (effectively disabling it)sudo setenforce 0sudo sed -i &#39;s/^SELINUX=enforcing$/SELINUX=permissive/&#39; /etc/selinux/config# turn off swapswapoff -a # 临时vim /etc/fstab # 永久sudo yum install -y kubelet-1.20.5 kubeadm-1.20.5 kubectl-1.20.5 --disableexcludes=kubernetessudo systemctl enable --now kubelet</code></pre><blockquote><p>uninstall command <code>sudo yum remove -y kubelet kubeadm kubectl</code></p></blockquote><h4 id="集群部署"><a href="#集群部署" class="headerlink" title="集群部署"></a>集群部署</h4><p>假设 master 所在机器为 10.176.66.58</p><pre><code class="bash"># 提前拉去镜像kubeadm config images pull --image-repository registry.aliyuncs.com/google_containerskubeadm config images pull --image-repository 10.176.66.20/google_containers# ping 不通 service 和 pod 的dnssudo kubeadm init \--apiserver-advertise-address=10.114.130.3 \--image-repository registry.aliyuncs.com/google_containers \--kubernetes-version v1.20.5 \--service-cidr=10.96.0.0/12 \--pod-network-cidr=10.244.0.0/16# 使用私服sudo kubeadm init \--apiserver-advertise-address=10.114.130.3 \--image-repository 10.176.66.20/google_containers \--kubernetes-version v1.20.5 \--service-cidr=10.96.0.0/12 \--pod-network-cidr=10.244.0.0/16# 在 nodes 上直接上面生成的命令，加入集群，如下kubeadm join 10.176.66.58:6443 --token 7opg66.gcmdavb2vxiliytp \    --discovery-token-ca-cert-hash sha256:ecb8d4930ac8489c1196560612afa1736dddf7be25244a50e64c82dca9bb2644# 使用 kubectl 工具mkdir -p $HOME/.kubesudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/configsudo chown $(id -u):$(id -g) $HOME/.kube/config# 查看 node 节点加入情况kubectl get nodes# 查看 pod 情况kubectl get pods -o wide# 安装 pod 网络插件 CNIkubectl apply -f  https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</code></pre><blockquote><p>master 重新生成加入命令: <code>kubeadm token create --print-join-command</code> <code>kubeadm token list</code></p><p>master&#x2F;node 退出集群 <code>kubeadm reset</code></p></blockquote><h3 id="二进制安装"><a href="#二进制安装" class="headerlink" title="二进制安装"></a>二进制安装</h3><p>待更新</p><h2 id="YAML-支持的数据结构"><a href="#YAML-支持的数据结构" class="headerlink" title="YAML 支持的数据结构"></a>YAML 支持的数据结构</h2><pre><code class="bash"># 查看所有 pod 和 servicekubectl get pod,svc# 开启检测, 有变化打印kubectl get pod -w# 查看 所有组件kubectl get pods --all-namespaces -o widekubectl get componentstatuses# 查看某个服务情况kubectl describe pods -n kube-system coredns-7f89b7bc75-hsjdl# 查看某个 pod 信息kubectl describe pod &lt;pod-name&gt;# 查看 pod 下，某个容器日志kubectl logs &lt;pod-name&gt; -c &lt;container-name&gt;# 删除某个 podkubectl delete pod &lt;pod-name&gt;# 删除所有 deploymentkubectl delete deployment --all# 删除所有 podkubectl delete pod --all# 根据配置文件创建对象kubectl create -f nginx.yaml# 根据配置文件删除对象 (猜测是根据 meta 标识的唯一对象进行删除)kubectl delete -f nginx.yaml# 更新对象配置kubectl replace -f nginx.yaml# 进入容器kubectl exec -it nacos-2 -- /bin/bash</code></pre><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><pre><code class="bash"># 更新kubectl set image deployment/nginx-deployment nginx=nginx:1.16.1 --record# 查看回滚历史kubectl rollout history deployment.v1.apps/nginx-deployment# 回滚到上个版本kubectl rollout undo deployment.v1.apps/nginx-deployment# 回滚到指定版本kubectl rollout undo deployment.v1.apps/nginx-deployment --to-revision=2# 缩放kubectl scale deployment.v1.apps/nginx-deployment --replicas=10# 自动伸缩kubectl autoscale deployment.v1.apps/nginx-deployment --min=10 --max=15 --cpu-percent=80# 查看各 pod/container cpu和memory 的占用量kubectl top podkubectl top pod test-huishi-server-6f875487d7-9rzpdkubectl top pod | grep lemes-service-common# 查看节点的内存和cpu占用情况kubectl top nodessudo systemctl restart docker</code></pre><h2 id="使用Rancher"><a href="#使用Rancher" class="headerlink" title="使用Rancher"></a>使用Rancher</h2><h3 id="deploy-nfs"><a href="#deploy-nfs" class="headerlink" title="deploy nfs"></a>deploy nfs</h3><pre><code class="bash">sudo yum install -y nfs-utils rpcbindsudo mkdir -p /data/nfssudo sh -c &quot;sudo echo &#39;/data/nfs *(rw,sync,no_root_squash)&#39; &gt;&gt; /etc/exports&quot;sudo systemctl enable --now nfssudo systemctl enable --now rpcbind</code></pre><h3 id="部署-ceph-未验证"><a href="#部署-ceph-未验证" class="headerlink" title="部署 ceph (未验证)"></a>部署 ceph (未验证)</h3><pre><code class="bash">sudo cat &gt; /etc/yum.repos.d/ceph.repo &lt;&lt; EOF[ceph-norch]name=ceph-norchbaseurl=https://mirrors.aliyun.com/ceph/rpm-nautilus/el7/noarch/enabled=1gpgcheck=0[ceph-x86_64]name=ceph-x86_64baseurl=https://mirrors.aliyun.com/ceph/rpm-nautilus/el7/x86_64/enabled=1gpgcheck=0EOFsudo yum install ceph-common</code></pre><h3 id="部署-redis"><a href="#部署-redis" class="headerlink" title="部署 redis"></a>部署 redis</h3><pre><code class="bash">kubectl exec -it redis-cluster-0 -- redis-cli --cluster create --cluster-replicas 1 $(kubectl get pods -l app=redis-cluster -o jsonpath=&#39;&#123;range.items[*]&#125;&#123;.status.podIP&#125;:6379 &#123;end&#125;&#39;)kubectl exec -it redis-cluster-0 -- redis-cli cluster nodes</code></pre><h3 id="修改-ingress-端口"><a href="#修改-ingress-端口" class="headerlink" title="修改 ingress 端口"></a>修改 ingress 端口</h3><pre><code class="yaml">- --http-port=81- --https-port=8443</code></pre><h3 id="集成-ceph"><a href="#集成-ceph" class="headerlink" title="集成 ceph"></a>集成 ceph</h3><h4 id="安装-ceph"><a href="#安装-ceph" class="headerlink" title="安装 ceph"></a>安装 ceph</h4><pre><code class="bash"># 安装 cephsudo yum -y install ceph-common# 创建poolceph osd pool create kubernetes 16 16# 初始化poolrbd pool init kubernetes# 创建块文件rbd create -p kubernetes --image-feature layering rbd.img --size 10Gmkdir -p /data/ceph/sdbmkdir -p /data/ceph/sdc# 查看 lv pathsudo vgscansudo vgdisplay -v datavgceph-deploy osd create --data /dev/datavg/lv_data whulpdpms01ceph-deploy osd create --data /dev/datavg/lv_data whulpdpms02ceph-deploy osd create --data /dev/datavg/lv_data whulpdpms03</code></pre><h2 id="Problem-问题记录"><a href="#Problem-问题记录" class="headerlink" title="Problem 问题记录"></a>Problem 问题记录</h2><h3 id="Snippet-directives-are-disabled-by-the-Ingress-administrator"><a href="#Snippet-directives-are-disabled-by-the-Ingress-administrator" class="headerlink" title="Snippet directives are disabled by the Ingress administrator"></a>Snippet directives are disabled by the Ingress administrator</h3><h2 id="当应用如下配置时报错题目问题-yaml-暴露服务"><a href="#当应用如下配置时报错题目问题-yaml-暴露服务" class="headerlink" title="当应用如下配置时报错题目问题&#96;&#96;&#96;yaml# 暴露服务"></a>当应用如下配置时报错题目问题<br>&#96;&#96;&#96;yaml<br># 暴露服务</h2><p>apiVersion: networking.k8s.io&#x2F;v1<br>kind: Ingress<br>metadata:<br>  name: lemes-gateway-ig<br>  namespace: default<br>  annotations:<br>    nginx.ingress.kubernetes.io&#x2F;rewrite-target: &#x2F;$2<br>    nginx.ingress.kubernetes.io&#x2F;proxy-connect-timeout: “600”<br>    nginx.ingress.kubernetes.io&#x2F;proxy-send-timeout: “600”<br>    nginx.ingress.kubernetes.io&#x2F;proxy-read-timeout: “600”<br>    nginx.ingress.kubernetes.io&#x2F;proxy-body-size: “600m”<br>    nginx.ingress.kubernetes.io&#x2F;configuration-snippet: |<br>      more_set_headers “Host $host”;<br>      more_set_headers “X-Forwarded-Proto $scheme”;<br>      more_set_headers “X-Forwarded-For $proxy_add_x_forwarded_for”;<br>      more_set_headers “X-Real-IP $remote_addr”;<br>spec:<br>  rules:<br>    - http:<br>        paths:<br>          - path: &#x2F;lemes-api(&#x2F;|$)(.*)<br>            pathType: Prefix<br>            backend:<br>              service:<br>                name: lemes-gateway-svc<br>                port:<br>                  number: 80</p><pre><code>原因与解决方案: https://github.com/kubernetes/ingress-nginx/issues/78371. 编辑 ingress-nginx```bashkubectl edit configmap -n ingress-nginx ingress-nginx-controller</code></pre><ol start="2"><li>如果有如下内容, 删除或修改 false 为 true</li></ol><pre><code class="yaml">data:  allow-snippet-annotations: &quot;false&quot;</code></pre><h3 id="ingress-前多层反向代理穿透，-获取-real-ip"><a href="#ingress-前多层反向代理穿透，-获取-real-ip" class="headerlink" title="ingress 前多层反向代理穿透， 获取 real ip"></a>ingress 前多层反向代理穿透， 获取 real ip</h3><p>升级 集群名-&gt; System -&gt; 资源 -&gt; 配置映射 中的 <code>ingress-nginx-controller</code><br>添加如下键值对</p><pre><code class="yaml">compute-full-forwarded-for: trueforwarded-for-header: X-Forwarded-Foruse-forwarded-headers:true</code></pre><p>实时生效</p><h3 id="容器删不掉"><a href="#容器删不掉" class="headerlink" title="容器删不掉"></a>容器删不掉</h3><p>docker stop&#x2F;kill&#x2F;rm -f 都不好使</p><pre><code class="bash"># 找到进程$ ps axo stat,ppid,pid,comm | grep -w defunctZl   19653 19679 java &lt;defunct&gt;# 找到父进程$ ps -f 19679UID        PID  PPID  C STIME TTY      STAT   TIME CMDroot     19653 19635  0 11:02 ?        Ss     0:00 [docker-startup.]$ sudo kill -9 19635$ sudo systemctl restart docker</code></pre><h3 id="强制删除所有-terminating-的-pod"><a href="#强制删除所有-terminating-的-pod" class="headerlink" title="强制删除所有 terminating 的 pod"></a>强制删除所有 terminating 的 pod</h3><pre><code class="bash">kubectl get pods | grep Terminating | awk &#39;&#123;print $1&#125;&#39; | xargs -I &#123;&#125; kubectl delete pod &#123;&#125; --force --grace-period=0kubectl delete pod nginx-ingress-controller-lbftg --force --grace-period=0</code></pre><h3 id="too-many-open-files"><a href="#too-many-open-files" class="headerlink" title="too many open files"></a>too many open files</h3><pre><code class="bash">sudo vi /etc/sysctl.conf# 添加fs.file-max=9000000fs.inotify.max_user_instances = 1000000fs.inotify.max_user_watches = 1000000sudo sysctl -psudo systemctl restart docker</code></pre><h3 id="删除挂载卷"><a href="#删除挂载卷" class="headerlink" title="删除挂载卷"></a>删除挂载卷</h3><pre><code class="bash"># 查看挂载卷cat /proc/mounts |grep &quot;docker&quot;# 显示/dev/mapper/centos-root /var/lib/docker/overlay xfs rw,seclabel,relatime,attr2,inode64,noquota 0 0 overlay /var/lib/docker/overlay/xxxxxxxxxx# 取消挂载umount /var/lib/docker/overlay/xxxxxxxxxxx# 批量取消挂载sudo umount `cat /proc/mounts |grep &quot;docker&quot;|awk &#39;&#123;print $2&#125;&#39;`</code></pre><h3 id="docker-假死"><a href="#docker-假死" class="headerlink" title="docker 假死"></a>docker 假死</h3><pre><code class="bash">[lemes@slt6dhqgxev ~]$ docker psCannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?# journalctl -u docker.serviceaccept4: too many open files</code></pre><p><strong>问题解析</strong><br>文件数创建上限</p><p><strong>问题解决</strong></p><pre><code class="bash">sudo vi /etc/sysctl.conf# 添加fs.file-max = 9000000fs.inotify.max_user_instances = 1000000fs.inotify.max_user_watches = 1000000# 生效sudo sysctl -p# 重启 docker 服务sudo systemctl restart docker# 启动所有关闭的容器docker start $(docker ps -a | awk &#39;&#123; print $1&#125;&#39; | tail -n +2)</code></pre><h3 id="rancher-应用-HOST-PATH-时-使用-subPath-subPathExpr-日志没有写入宿主机"><a href="#rancher-应用-HOST-PATH-时-使用-subPath-subPathExpr-日志没有写入宿主机" class="headerlink" title="rancher 应用 HOST-PATH 时 使用 subPath &#x2F; subPathExpr 日志没有写入宿主机"></a>rancher 应用 HOST-PATH 时 使用 subPath &#x2F; subPathExpr 日志没有写入宿主机</h3><p>问题讨论：<a href="https://github.com/rancher/rancher/issues/14836">volume hostpath with subpath</a></p><p>问题原因：<br>映射到了 kubectl 容器内<br><code>docker exec -it $(docker ps -aq --filter &quot;name=kubelet&quot;) /bin/sh</code></p><h3 id="k8s-集群内-dns-生效-rancher"><a href="#k8s-集群内-dns-生效-rancher" class="headerlink" title="k8s 集群内 dns 生效(rancher)"></a>k8s 集群内 dns 生效(rancher)</h3><p>修改了宿主机的 dns 后，需要重启 docker 才能全体生效</p><pre><code class="bash">sudo systemctl restart docker</code></pre><h3 id="报错-x509-certificate-is-not-valid-for-any-names-but-wanted-to-match-ingress-nginx-controller-admission-ingress-nginx-svc"><a href="#报错-x509-certificate-is-not-valid-for-any-names-but-wanted-to-match-ingress-nginx-controller-admission-ingress-nginx-svc" class="headerlink" title="报错 x509: certificate is not valid for any names, but wanted to match ingress-nginx-controller-admission.ingress-nginx.svc"></a>报错 x509: certificate is not valid for any names, but wanted to match ingress-nginx-controller-admission.ingress-nginx.svc</h3><pre><code class="bash">kubectl delete -A ValidatingWebhookConfiguration foobar-ingress-nginx-admission</code></pre><h3 id="network-plugin-is-not-ready-cni-config-uninitialized"><a href="#network-plugin-is-not-ready-cni-config-uninitialized" class="headerlink" title="network plugin is not ready: cni config uninitialized"></a>network plugin is not ready: cni config uninitialized</h3><p>网络框架一直安装不上, 根据 <code>docker logs -f kubelet</code> 日志查看, 网络插件安装时报 <code>diskpress</code> 被放逐<br>问题: &#x2F;data 磁盘空间不足<br>解决方案: 释放磁盘空间解决</p><h3 id="Pod-ephemeral-local-storage-usage-exceeds-the-total-limit-of-containers-4Gi"><a href="#Pod-ephemeral-local-storage-usage-exceeds-the-total-limit-of-containers-4Gi" class="headerlink" title="Pod ephemeral local storage usage exceeds the total limit of containers 4Gi."></a>Pod ephemeral local storage usage exceeds the total limit of containers 4Gi.</h3><p>现象: pod被驱逐, 报错如题<br>问题: 使用的临时容量超过了节点限制(在此节点上)</p><p>2023-08-11 21:22 再次出现这个问题</p><p>经<a href="https://access.redhat.com/solutions/4367311">查询资料</a>， 可能是由于没有限制容器日志造成的</p><p>南方厂工厂的 <code>sudo vi /etc/docker/daemon.json</code> 配置确实如下</p><pre><code class="json">&#123;  &quot;registry-mirrors&quot;: [],  &quot;insecure-registries&quot;: [    &quot;10.176.66.20:5000&quot;,    &quot;10.188.132.44:5000&quot;,    &quot;10.188.132.123:5000&quot;,    &quot;10.176.2.207:5000&quot;  ],  &quot;data-root&quot;:&quot;/data/docker/system&quot;,  &quot;debug&quot;: true,  &quot;experimental&quot;: false,&#125;</code></pre><p>改为如下, 限制每个容器只能保留10m的日志</p><pre><code class="json">&#123;  &quot;registry-mirrors&quot;: [],  &quot;insecure-registries&quot;: [    &quot;10.188.132.44:5000&quot;,    &quot;10.188.132.123:5000&quot;,    &quot;10.176.2.207:5000&quot;  ],  &quot;data-root&quot;:&quot;/data/docker/system&quot;,  &quot;debug&quot;: true,  &quot;experimental&quot;: false,  &quot;log-driver&quot;: &quot;json-file&quot;,  &quot;log-opts&quot;: &#123;    &quot;max-size&quot;: &quot;10m&quot;,    &quot;max-file&quot;: &quot;1&quot;,    &quot;labels&quot;: &quot;production_status&quot;,    &quot;env&quot;: &quot;os,customer&quot;  &#125;&#125;</code></pre><p>2023-08-25 16:41 再次出现问题<br>发现 tingyun 使用的 <code>emptyDir</code> 中， 一直在写入日志，导致占用临时空间</p><pre><code class="bash"># 查询log日志总数sudo find /data/docker/system/containers/ -name &quot;*-json.log&quot; | xargs sudo ls -l | awk &#39;&#123;print $5&#125;&#39; | awk &#39;&#123;sum+=$1&#125;END&#123;print sum&#125;&#39;sudo find /data/docker/system/containers/ -name &quot;*-json.log&quot; | xargs sudo rm -rf</code></pre><p>2023-08-31 smt-wh 和 smt-tjsc 都出现了这个问题 <code>The node was low on resource: ephemeral-storage. Container lemes-service-wh-report was using 1936Ki, which exceeds its request of 0.</code></p><p>超出了0，就不是有限制， 而是当前磁盘已经达到了 85%，造成了 pod 驱逐</p><h3 id="导入-lemes-web-出现问题"><a href="#导入-lemes-web-出现问题" class="headerlink" title="导入 lemes-web 出现问题"></a>导入 lemes-web 出现问题</h3><p>Error from server (InternalError): error when creating “management-state&#x2F;tmp&#x2F;yaml-397511040”: Internal error occurred: failed calling webhook “validate.nginx.ingress.kubernetes.io”: Post “<a href="https://ingress-nginx-controller-admission.ingress-nginx.svc/networking/v1/ingresses?timeout=10s">https://ingress-nginx-controller-admission.ingress-nginx.svc:443/networking/v1/ingresses?timeout=10s</a>“: x509: certificate is not valid for any names, but wanted to match ingress-nginx-controller-admission.ingress-nginx.svc</p><h3 id="node-节点报错-PLEG-is-not-healthy-pleg-was-last-seen-active-7m20-510472824s-ago-threshold-is-3m0s"><a href="#node-节点报错-PLEG-is-not-healthy-pleg-was-last-seen-active-7m20-510472824s-ago-threshold-is-3m0s" class="headerlink" title="node 节点报错 PLEG is not healthy: pleg was last seen active 7m20.510472824s ago; threshold is 3m0s"></a>node 节点报错 PLEG is not healthy: pleg was last seen active 7m20.510472824s ago; threshold is 3m0s</h3><p>有个 <code>issue</code> 问题很像 <a href="https://github.com/rancher/rancher/issues/31793#issuecomment-911143593">PLEG is not healthy K8 1.20.4&#x2F;Ubuntu 20.04</a></p><p>根据 <code>minchieh-fay</code> 老哥的回答,是 <code>runc</code> 的 <code>runc-1.0.0-rc93</code> 这个版本有问题</p><p>可以通过 <code>docker version</code> 来查看 <code>runc</code> 的版本, 确实是 <code>runc-1.0.0-rc93</code>, 按照如下方式进行离线升级</p><ol><li>到 <code>runc</code> 的 <a href="https://github.com/opencontainers/runc/releases/">github release</a> 找到升级的版本, 我选的是 <code>1.1.4</code>, 选择 <code>runc.amd64</code> 进行下载</li><li>上传到服务器, 执行 <code>mv runc.amd64 runc &amp;&amp; chmod +x runc</code> 进行重命名和赋予执行权限</li><li>备份原来的 <code>runc</code> 文件, <code>mv /usr/bin/runc /usr/bin/runc.bak</code></li><li>停止 <code>docker</code> 服务, <code>systemctl stop docker</code></li><li>移动新的 <code>runc</code> 文件到 <code>/usr/bin/</code> 目录下, <code>mv runc /usr/bin/runc</code></li><li>启动 <code>docker</code> 服务, <code>systemctl start docker</code></li><li>执行 <code>docker version</code> 查看 <code>runc</code> 版本, 确认升级成功</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;kubernetes: k8s 是谷歌在2014年开源的容器化集群管理系统&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Pod&lt;/str</summary>
      
    
    
    
    <category term="运维" scheme="http://yelog.org/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
    <category term="docker" scheme="http://yelog.org/tags/docker/"/>
    
    <category term="k8s" scheme="http://yelog.org/tags/k8s/"/>
    
    <category term="container" scheme="http://yelog.org/tags/container/"/>
    
  </entry>
  
  <entry>
    <title>JDK 垃圾回收介绍</title>
    <link href="http://yelog.org/2024/08/30/jdk-gc/"/>
    <id>http://yelog.org/2024/08/30/jdk-gc/</id>
    <published>2024-08-30T03:12:15.000Z</published>
    <updated>2024-09-30T03:54:10.295Z</updated>
    
    <content type="html"><![CDATA[<h2 id="推荐配置"><a href="#推荐配置" class="headerlink" title="推荐配置"></a>推荐配置</h2><h3 id="容器内"><a href="#容器内" class="headerlink" title="容器内"></a>容器内</h3><pre><code class="bash">-XX:+UseContainerSupport -XX:InitialRAMPercentage=75.0 -XX:MaxRAMPercentage=75.0 -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/home/admin/nas/dump-$&#123;POD_IP&#125;-$(date &#39;+%s&#39;).hprof</code></pre><h2 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h2><p><a href="https://juejin.cn/post/6856222574155104270">https://juejin.cn/post/6856222574155104270</a><br><a href="https://juejin.cn/post/7007343142328352804">https://juejin.cn/post/7007343142328352804</a><br><a href="https://blog.csdn.net/jiguansheng/article/details/105406343">https://blog.csdn.net/jiguansheng/article/details/105406343</a><br><a href="https://tech.meituan.com/2016/09/23/g1.html">https://tech.meituan.com/2016/09/23/g1.html</a></p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h4><p>新生代又叫年轻代，大多数对象在新生代中被创建，很多对象的生命周期很短。每次新生代的垃圾回收（又称Young GC、Minor GC、YGC）后只有少量对象存活，所以使用复制算法，只需少量的复制操作成本就可以完成回收。</p><p>新生代内又分三个区：一个Eden区，两个Survivor区(S0、S1，又称From Survivor、To Survivor)，大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到两个Survivor区（中的一个）。当这个Survivor区满时，此区的存活且不满足晋升到老年代条件的对象将被复制到另外一个Survivor区。对象每经历一次复制，年龄加1，达到晋升年龄阈值后，转移到老年代</p><h4 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h4><p>在新生代中经历了N次垃圾回收后仍然存活的对象，就会被放到老年代，该区域中对象存活率高。老年代的垃圾回收通常使用“标记-整理”算法</p><h3 id="YGC"><a href="#YGC" class="headerlink" title="YGC"></a>YGC</h3><p>触发条件: 新生代占据整个堆大小的 60%</p><p>新生代: Eden Space + Survivor Space</p><p>新生代晋升老年代条件</p><ul><li>对象超过 age 阈值 15</li><li>附质量过程超过 50, age 最大的放到老年代</li></ul><p>-XX:MaxGCPauseMils 默认为200ms<br>在优先时间内尽量回收垃圾多的区域, 让时间效率最大化</p><p>Young GC 每次都会引起全线停顿(Stop-The-World)，暂停所有的应用线程，停顿时间相对老年代GC的造成的停顿，几乎可以忽略不计</p><h3 id="Mixed-GC"><a href="#Mixed-GC" class="headerlink" title="Mixed GC"></a>Mixed GC</h3><p>新生代和老年代进行收集和整理<br>触发条件: 老年代超过堆 45%</p><h3 id="压缩算法回收-STW-Stop-The-World"><a href="#压缩算法回收-STW-Stop-The-World" class="headerlink" title="压缩算法回收 STW(Stop-The-World)"></a>压缩算法回收 STW(Stop-The-World)</h3><p>G1 开辟一块最多 5% 堆空间的内存用于标记压缩的数据交换, 过程产生 STW, STW 200ms内最多回收 10% 垃圾最多的区域, 回收后检查老年代是否低于 45%, 未达标继续再来一次, 最多 8 次, 8次未达标 Serial Old GC(Full GC)</p><h3 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h3><p>used &#x3D; resident + swapped pages</p><h2 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h2><p><a href="https://docs.oracle.com/en/java/javase/14/docs/specs/man/jstat.html">doc</a></p><h3 id="gc"><a href="#gc" class="headerlink" title="-gc"></a>-gc</h3><table><thead><tr><th>head</th><th>description</th></tr></thead><tbody><tr><td>S0C</td><td>Current survivor space 0 capacity (KB).</td></tr><tr><td>S1C</td><td>Current survivor space 1 capacity (KB).</td></tr><tr><td>S0U</td><td>Survivor space 0 utilization (KB).</td></tr><tr><td>S1U</td><td>Survivor space 1 utilization (KB).</td></tr><tr><td>EC</td><td>Current eden space capacity (KB).</td></tr><tr><td>EU</td><td>Eden space utilization (KB).</td></tr><tr><td>OC</td><td>Current old space capacity (KB).</td></tr><tr><td>OU</td><td>Old space utilization (KB).</td></tr><tr><td>MC</td><td>Metaspace Committed Size (KB).</td></tr><tr><td>MU</td><td>Metaspace utilization (KB).</td></tr><tr><td>CCSC</td><td>Compressed class committed size (KB).</td></tr><tr><td>CCSU</td><td>Compressed class space used (KB).</td></tr><tr><td>YGC</td><td>Number of young generation garbage collection (GC) events.</td></tr><tr><td>YGCT</td><td>Young generation garbage collection time.</td></tr><tr><td>FGC</td><td>Number of full GC events.</td></tr><tr><td>FGCT</td><td>Full garbage collection time.</td></tr><tr><td>GCT</td><td>Total garbage collection time.</td></tr></tbody></table><h3 id="jstat-gcutil-10"><a href="#jstat-gcutil-10" class="headerlink" title="jstat -gcutil 10"></a>jstat -gcutil 10</h3><p>S0: Survivor 0区的空间使用率 Survivor space 0 utilization as a percentage of the space’s current capacity.</p><p>S1: Survivor 1区的空间使用率 Survivor space 1 utilization as a percentage of the space’s current capacity.</p><p>E: Eden区的空间使用率 Eden space utilization as a percentage of the space’s current capacity.</p><p>O: 老年代的空间使用率 Old space utilization as a percentage of the space’s current capacity.</p><p>M: 元数据的空间使用率 Metaspace utilization as a percentage of the space’s current capacity.</p><p>CCS: 类指针压缩空间使用率 Compressed class space utilization as a percentage.</p><p>YGC: 新生代GC次数 Number of young generation GC events.</p><p>YGCT: 新生代GC总时长（从应用程序启动到采样时年轻代中gc所用时间 单位：s）<br>      Young generation garbage collection time.</p><p>FGC: Full GC次数 Number of full GC events.</p><p>FGCT: Full GC总时长（从应用程序启动到采样时old代(全gc)gc所用时间 单位：s）<br>      Full garbage collection time.</p><p>GCT: 总共的GC时长 （从应用程序启动到采样时gc用的总时间 单位：s）Total garbage collection time.</p><h2 id="查询当前使用的是什么垃圾回收器"><a href="#查询当前使用的是什么垃圾回收器" class="headerlink" title="查询当前使用的是什么垃圾回收器"></a>查询当前使用的是什么垃圾回收器</h2><h3 id="查看是否通过-JVM-参数指定了虚拟机类型"><a href="#查看是否通过-JVM-参数指定了虚拟机类型" class="headerlink" title="查看是否通过 JVM 参数指定了虚拟机类型"></a>查看是否通过 JVM 参数指定了虚拟机类型</h3><pre><code class="bash">ps -ef | grep webservice</code></pre><h3 id="查询-JDK-默认虚拟机类型"><a href="#查询-JDK-默认虚拟机类型" class="headerlink" title="查询 JDK 默认虚拟机类型"></a>查询 JDK 默认虚拟机类型</h3><pre><code class="bash">java -XX:+PrintCommandLineFlags -version</code></pre><h2 id="others"><a href="#others" class="headerlink" title="others"></a>others</h2><pre><code class="bash"># 查看堆空间占用类， 前20条jmap -histo PID | head -n20</code></pre><h2 id="bash-4-2-jmap-histo-9-head-n20-num-instances-bytes-class-name-module"><a href="#bash-4-2-jmap-histo-9-head-n20-num-instances-bytes-class-name-module" class="headerlink" title="bash-4.2# jmap -histo 9 | head -n20 num     #instances         #bytes  class name (module)"></a>bash-4.2# jmap -histo 9 | head -n20<br> num     #instances         #bytes  class name (module)</h2><p>   1:        544456     3280814896  [C (<a href="mailto:&#106;&#x61;&#x76;&#x61;&#46;&#98;&#97;&#x73;&#x65;&#x40;&#x31;&#x31;&#46;&#x30;&#46;&#49;&#56;">&#106;&#x61;&#x76;&#x61;&#46;&#98;&#97;&#x73;&#x65;&#x40;&#x31;&#x31;&#46;&#x30;&#46;&#49;&#56;</a>)<br>   2:       3076195     1819165352  [B (<a href="mailto:&#106;&#x61;&#x76;&#97;&#46;&#x62;&#97;&#x73;&#x65;&#x40;&#x31;&#49;&#x2e;&#x30;&#46;&#x31;&#x38;">&#106;&#x61;&#x76;&#97;&#46;&#x62;&#97;&#x73;&#x65;&#x40;&#x31;&#49;&#x2e;&#x30;&#46;&#x31;&#x38;</a>)<br>   3:       1029042      626773184  [I (<a href="mailto:&#x6a;&#97;&#118;&#97;&#46;&#x62;&#97;&#x73;&#101;&#64;&#x31;&#x31;&#x2e;&#48;&#46;&#49;&#x38;">&#x6a;&#97;&#118;&#97;&#46;&#x62;&#97;&#x73;&#101;&#64;&#x31;&#x31;&#x2e;&#48;&#46;&#49;&#x38;</a>)<br>   4:       6287573      201202336  java.lang.ClassValue$Entry (<a href="mailto:&#106;&#97;&#x76;&#97;&#46;&#x62;&#97;&#115;&#101;&#64;&#x31;&#x31;&#x2e;&#x30;&#46;&#49;&#56;">&#106;&#97;&#x76;&#97;&#46;&#x62;&#97;&#115;&#101;&#64;&#x31;&#x31;&#x2e;&#x30;&#46;&#49;&#56;</a>)<br>   5:       4575213      183008520  java.util.WeakHashMap$Entry (<a href="mailto:&#106;&#x61;&#118;&#97;&#46;&#98;&#x61;&#x73;&#x65;&#64;&#49;&#x31;&#x2e;&#48;&#x2e;&#x31;&#56;">&#106;&#x61;&#118;&#97;&#46;&#98;&#x61;&#x73;&#x65;&#64;&#49;&#x31;&#x2e;&#48;&#x2e;&#x31;&#56;</a>)<br>   6:       2214270      141713280  java.util.concurrent.ConcurrentHashMap (<a href="mailto:&#x6a;&#97;&#x76;&#x61;&#46;&#x62;&#97;&#x73;&#101;&#64;&#x31;&#49;&#46;&#48;&#46;&#x31;&#56;">&#x6a;&#97;&#x76;&#x61;&#46;&#x62;&#97;&#x73;&#101;&#64;&#x31;&#49;&#46;&#48;&#46;&#x31;&#56;</a>)<br>   7:       1085202      130240080  [Ljava.lang.Object; (<a href="mailto:&#x6a;&#x61;&#118;&#97;&#46;&#98;&#x61;&#115;&#101;&#64;&#49;&#x31;&#x2e;&#x30;&#46;&#x31;&#56;">&#x6a;&#x61;&#118;&#97;&#46;&#98;&#x61;&#115;&#101;&#64;&#49;&#x31;&#x2e;&#x30;&#46;&#x31;&#56;</a>)<br>   8:       1492883      130059632  [Ljava.util.WeakHashMap$Entry; (<a href="mailto:&#106;&#97;&#x76;&#x61;&#46;&#98;&#x61;&#115;&#x65;&#x40;&#x31;&#49;&#46;&#x30;&#x2e;&#x31;&#56;">&#106;&#97;&#x76;&#x61;&#46;&#98;&#x61;&#115;&#x65;&#x40;&#x31;&#49;&#46;&#x30;&#x2e;&#x31;&#56;</a>)<br>   9:       3101147      124045880  java.lang.ref.SoftReference (<a href="mailto:&#x6a;&#x61;&#118;&#97;&#x2e;&#98;&#x61;&#x73;&#101;&#x40;&#x31;&#x31;&#x2e;&#48;&#46;&#49;&#x38;">&#x6a;&#x61;&#118;&#97;&#x2e;&#98;&#x61;&#x73;&#101;&#x40;&#x31;&#x31;&#x2e;&#48;&#46;&#49;&#x38;</a>)<br>  10:       3068059      122722360  java.lang.invoke.BoundMethodHandle$Species_LL (<a href="mailto:&#106;&#97;&#118;&#x61;&#x2e;&#x62;&#x61;&#x73;&#101;&#x40;&#x31;&#49;&#46;&#48;&#x2e;&#x31;&#56;">&#106;&#97;&#118;&#x61;&#x2e;&#x62;&#x61;&#x73;&#101;&#x40;&#x31;&#49;&#46;&#48;&#x2e;&#x31;&#56;</a>)<br>  11:       4341767      104202408  java.lang.ClassValue$Version (<a href="mailto:&#106;&#x61;&#x76;&#97;&#46;&#x62;&#x61;&#115;&#x65;&#x40;&#x31;&#49;&#46;&#x30;&#46;&#x31;&#x38;">&#106;&#x61;&#x76;&#97;&#46;&#x62;&#x61;&#115;&#x65;&#x40;&#x31;&#49;&#46;&#x30;&#46;&#x31;&#x38;</a>)<br>  12:       1506502       84364112  jdk.nashorn.internal.runtime.ScriptFunction (<a href="mailto:&#106;&#x64;&#x6b;&#46;&#x73;&#x63;&#x72;&#x69;&#x70;&#116;&#105;&#110;&#x67;&#x2e;&#x6e;&#97;&#x73;&#104;&#111;&#114;&#110;&#x40;&#49;&#49;&#46;&#48;&#46;&#49;&#x38;">&#106;&#x64;&#x6b;&#46;&#x73;&#x63;&#x72;&#x69;&#x70;&#116;&#105;&#110;&#x67;&#x2e;&#x6e;&#97;&#x73;&#104;&#111;&#114;&#110;&#x40;&#49;&#49;&#46;&#48;&#46;&#49;&#x38;</a>)<br>  13:       2004817       80192680  java.util.TreeMap$Entry (<a href="mailto:&#x6a;&#97;&#x76;&#x61;&#x2e;&#x62;&#97;&#x73;&#101;&#64;&#49;&#49;&#x2e;&#48;&#46;&#x31;&#56;">&#x6a;&#97;&#x76;&#x61;&#x2e;&#x62;&#97;&#x73;&#101;&#64;&#49;&#49;&#x2e;&#48;&#46;&#x31;&#56;</a>)<br>  14:       2316002       74112064  java.util.HashMap$Node (<a href="mailto:&#106;&#97;&#118;&#97;&#x2e;&#x62;&#97;&#x73;&#101;&#64;&#x31;&#49;&#46;&#x30;&#46;&#x31;&#56;">&#106;&#97;&#118;&#97;&#x2e;&#x62;&#97;&#x73;&#101;&#64;&#x31;&#49;&#46;&#x30;&#46;&#x31;&#56;</a>)<br>  15:       2282867       73051744  jdk.nashorn.internal.runtime.PropertyHashMap$Element (<a href="mailto:&#106;&#100;&#107;&#46;&#115;&#99;&#x72;&#105;&#x70;&#116;&#105;&#x6e;&#x67;&#x2e;&#110;&#97;&#x73;&#x68;&#x6f;&#x72;&#x6e;&#x40;&#x31;&#49;&#46;&#48;&#x2e;&#x31;&#x38;">&#106;&#100;&#107;&#46;&#115;&#99;&#x72;&#105;&#x70;&#116;&#105;&#x6e;&#x67;&#x2e;&#110;&#97;&#x73;&#x68;&#x6f;&#x72;&#x6e;&#x40;&#x31;&#49;&#46;&#48;&#x2e;&#x31;&#x38;</a>)<br>  16:       4341767       69468272  java.lang.ClassValue$Identity (<a href="mailto:&#x6a;&#x61;&#118;&#x61;&#46;&#98;&#x61;&#115;&#x65;&#x40;&#x31;&#49;&#x2e;&#x30;&#x2e;&#49;&#56;">&#x6a;&#x61;&#118;&#x61;&#46;&#98;&#x61;&#115;&#x65;&#x40;&#x31;&#49;&#x2e;&#x30;&#x2e;&#49;&#56;</a>)<br>  17:       1435938       68925024  java.util.WeakHashMap (<a href="mailto:&#x6a;&#x61;&#118;&#97;&#46;&#x62;&#97;&#115;&#101;&#64;&#49;&#x31;&#46;&#x30;&#x2e;&#49;&#x38;">&#x6a;&#x61;&#118;&#97;&#46;&#x62;&#97;&#115;&#101;&#64;&#49;&#x31;&#46;&#x30;&#x2e;&#49;&#x38;</a>)<br>  18:       1657484       66299360  jdk.nashorn.internal.runtime.CompiledFunction (<a href="mailto:&#x6a;&#100;&#x6b;&#x2e;&#115;&#x63;&#114;&#x69;&#x70;&#x74;&#x69;&#110;&#x67;&#46;&#x6e;&#x61;&#x73;&#104;&#x6f;&#114;&#x6e;&#64;&#49;&#49;&#46;&#x30;&#46;&#x31;&#x38;">&#x6a;&#100;&#x6b;&#x2e;&#115;&#x63;&#114;&#x69;&#x70;&#x74;&#x69;&#110;&#x67;&#46;&#x6e;&#x61;&#x73;&#104;&#x6f;&#114;&#x6e;&#64;&#49;&#49;&#46;&#x30;&#46;&#x31;&#x38;</a>)</p><p>[C is a char[]<br>[B is a byte[]<br>[I is a int[]<br>[S is a short[]<br>[[I is a int[][]</p><pre><code class="bash"># 查看堆空间存活, 注意, 会触发 full gcjmap -histo:live PID | head -n20</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;推荐配置&quot;&gt;&lt;a href=&quot;#推荐配置&quot; class=&quot;headerlink&quot; title=&quot;推荐配置&quot;&gt;&lt;/a&gt;推荐配置&lt;/h2&gt;&lt;h3 id=&quot;容器内&quot;&gt;&lt;a href=&quot;#容器内&quot; class=&quot;headerlink&quot; title=&quot;容器内&quot;&gt;&lt;/a&gt;容器</summary>
      
    
    
    
    <category term="后端" scheme="http://yelog.org/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="java" scheme="http://yelog.org/tags/java/"/>
    
    <category term="gc" scheme="http://yelog.org/tags/gc/"/>
    
    <category term="jdk" scheme="http://yelog.org/tags/jdk/"/>
    
  </entry>
  
  <entry>
    <title>Centos7 常用命令</title>
    <link href="http://yelog.org/2024/08/30/centos7-commands/"/>
    <id>http://yelog.org/2024/08/30/centos7-commands/</id>
    <published>2024-08-30T02:46:15.000Z</published>
    <updated>2024-09-30T03:54:10.798Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Software-installation"><a href="#Software-installation" class="headerlink" title="Software installation"></a>Software installation</h2><h3 id="yum"><a href="#yum" class="headerlink" title="yum"></a>yum</h3><pre><code class="bash"># 就是把服务器的包信息下载到本地电脑缓存起来，makecache建立一个缓存，以后用install时就在缓存中搜索，提高了速度。yum makecache# 不用上网检索就能查找软件信息yum -C search git# 清理缓存yum clean all# 添加 Extra Packages for Enterprise Linux 源，安装后就可以在 /etc/yum.repos.d/ 看到 epel 源信息yum install -y epel-release# 接下来以 ansible 这个软件为例yum install ansible     # 安装yum reinstall ansible   # 重新安装yum upgrade ansible     # 升级yum info ansible        # 查看软件信息yum remove ansible      # 删除yum update              # 升级所有包同时也升级软件和系统内核(慎用yum upgrade             # 升级所有包，但不升级软件和系统内核yum list ansible        # 查看是否安装yum list all            # 列出所有软件yum list installed      # 列出所有安装的软件yum list available      # 列出所有可以安装的软件yum search ansible      # 搜索软件信息yum whatprovides rm     # yum源中查找包含rm的软件包yum check-update        # 查看可更新的软件列表rpm -ql ansible | more  # 查看 ansible 的安装位置# 换源## 备份mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup## 下载新的配置文件### CentOS 6wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-6.repo### CentOS 7wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo### CentOS 8wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-8.repo## 生成缓存yum makecache</code></pre><h3 id="ansible"><a href="#ansible" class="headerlink" title="ansible"></a>ansible</h3><pre><code class="bash"># 修改要管理的机器vim /etc/ansible/hosts[webservers]192.168.1.100192.168.1.101</code></pre><h3 id="man"><a href="#man" class="headerlink" title="man"></a>man</h3><pre><code class="bash"># 在 .bashrc 中放入，可以高亮man手册function man()&#123;    env \    LESS_TERMCAP_mb=$(printf &quot;\e[1;31m&quot;) \    LESS_TERMCAP_md=$(printf &quot;\e[1;31m&quot;) \    LESS_TERMCAP_me=$(printf &quot;\e[0m&quot;) \    LESS_TERMCAP_se=$(printf &quot;\e[0m&quot;) \    LESS_TERMCAP_so=$(printf &quot;\e[1;44;33m&quot;) \    LESS_TERMCAP_ue=$(printf &quot;\e[0m&quot;) \    LESS_TERMCAP_us=$(printf &quot;\e[1;32m&quot;) \    man &quot;$@&quot;&#125;</code></pre><h3 id="zsh-on-my-zsh"><a href="#zsh-on-my-zsh" class="headerlink" title="zsh&#x2F;on-my-zsh"></a>zsh&#x2F;on-my-zsh</h3><pre><code class="bash"># 安装 zsh gityum install -y zsh git# 设置默认shell为 zshchsh -s /bin/zsh# 安装 on-my-zshsh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;# 复制配置cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc# 手动安装 zsh http://zsh.sourceforge.net/Arc/source.htmlyum -y install gcc perl-ExtUtils-MakeMaker ncurses-devel# 编译安装tar xvf zsh-5.8.tar.xzcd zsh-5.8./configuremake &amp;&amp; make install# 将zsh加入/etc/shellsvim /etc/shells # 添加：/usr/local/bin/zsh</code></pre><h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><pre><code class="bash">sudo yum install -y https://packages.endpointdev.com/rhel/7/os/x86_64/endpoint-repo.x86_64.rpmsudo yum install -y git</code></pre><h3 id="neovim"><a href="#neovim" class="headerlink" title="neovim"></a>neovim</h3><pre><code class="bash"># Download source codegit clone https://github.com/neovim/neovim.git# install cmake and dependencysudo yum install -y cmake gcc-c++ libtool unzip# compile with cmakemake CMAKE_BUILD_TYPE=Release# installsudo make install# fix error: Failed to load python3 hostpip3 install --upgrade --force-reinstall neovim</code></pre><h3 id="neofetch"><a href="#neofetch" class="headerlink" title="neofetch"></a>neofetch</h3><pre><code class="bash">dnf copr enable -y konimex/neofetchdnf install -y neofetch</code></pre><h3 id="rainbarf"><a href="#rainbarf" class="headerlink" title="rainbarf"></a>rainbarf</h3><pre><code class="bash"># Download source codegit clone https://github.com/creaktive/rainbarf.git# install dependencyyum install -y perl-Module-Build perl-Test-Simple# installperl Build.PL./Build test./Build install</code></pre><h3 id="node"><a href="#node" class="headerlink" title="node"></a>node</h3><p>Mange node using <a href="https://github.com/nvm-sh/nvm">nvm</a></p><pre><code class="bash"># installationcurl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.37.2/install.sh | bash# set path，put following content into ~/.bashrcexport NVM_DIR=&quot;$([ -z &quot;$&#123;XDG_CONFIG_HOME-&#125;&quot; ] &amp;&amp; printf %s &quot;$&#123;HOME&#125;/.nvm&quot; || printf %s &quot;$&#123;XDG_CONFIG_HOME&#125;/nvm&quot;)&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \. &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm# install latest nodenvm install node</code></pre><h3 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h3><p>[[docker#安装卸载]]</p><h3 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h3><p>[[docker#docker-compose]]</p><h3 id="rancher"><a href="#rancher" class="headerlink" title="rancher"></a>rancher</h3><pre><code class="bash">docker run -d --restart=unless-stopped \  -p 80:80 -p 443:443 \  --privileged \  --name=lemes-rancher-2.5 \  10.188.132.44:5000/rancher/rancher:v2.5.12docker restart lemes-rancher-2.5docker stop lemes-rancher-2.5docker start lemes-rancher-2.5docker run -d --restart=unless-stopped \  -p 9080:80 -p 8443:443 \  --privileged \  --name=lemes-rancher-2.5-prod \  10.188.132.123:5000/rancher/rancher:v2.5.12# 生产docker run -d --restart=unless-stopped \  -p 80:80 -p 443:443 \  --privileged \  --name=lemes-rancher-2.5-prod \  10.188.132.44:5000/rancher/rancher:v2.5.12docker run -d --restart=unless-stopped \  -p 9080:80 -p 8443:443 \  --privileged \  --name=lemes-rancher-2.5-prod \  10.188.132.44:5000/rancher/rancher:v2.5.12docker run -d --restart=unless-stopped \  -p 9080:80 -p 9443:443 \  --privileged \  --name=lemes-rancher-2.5-prod \  rancher/rancher:v2.5.12docker run -d --restart=unless-stopped \  -p 8080:80 -p 8083:443 \  --privileged \  --name=lemes-rancher-2.5-prod \  10.176.2.207:5000/rancher/rancher:v2.5.12</code></pre><h3 id="Harbor"><a href="#Harbor" class="headerlink" title="Harbor"></a>Harbor</h3><blockquote><p>前提: 需要先安装 docker &amp; docker-compose</p></blockquote><p>复制最新的包的链接: <a href="https://github.com/goharbor/harbor/releases">https://github.com/goharbor/harbor/releases</a></p><pre><code class="bash">wget https://github.com/goharbor/harbor/releases/download/v2.3.1/harbor-offline-installer-v2.3.1.tgztar -zxf harbor-offline-installer-v2.3.1.tgz -C /data/docker/harborsudo chown -R lemes:lemes /data/docker/harborcd /data/docker/harbor/harborcp harbor.yml.tmpl harbor.ymlvi harbor.ymlsudo su rootexport PATH=$PATH:/usr/local/bin./install.sh</code></pre><pre><code class="yaml"># Configuration file of Harbor# The IP address or hostname to access admin UI and registry service.# DO NOT use localhost or 127.0.0.1, because Harbor needs to be accessed by external clients.hostname: 10.176.2.207# http related confighttp:  # port for http, default is 80. If https enabled, this port will redirect to https port  port: 5000# https related config#https:#  # https port for harbor, default is 443#  port: 443#  # The path of cert and key files for nginx#  certificate: /your/certificate/path#  private_key: /your/private/key/path# # Uncomment following will enable tls communication between all harbor components# internal_tls:#   # set enabled to true means internal tls is enabled#   enabled: true#   # put your cert and key files on dir#   dir: /etc/harbor/tls/internal# Uncomment external_url if you want to enable external proxy# And when it enabled the hostname will no longer used# external_url: https://reg.mydomain.com:8433# The initial password of Harbor admin# It only works in first time to install harbor# Remember Change the admin password from UI after launching Harbor.harbor_admin_password: Lenovo2021# Harbor DB configurationdatabase:  # The password for the root user of Harbor DB. Change this before any production use.  password: root123  # The maximum number of connections in the idle connection pool. If it &lt;=0, no idle connections are retained.  max_idle_conns: 100  # The maximum number of open connections to the database. If it &lt;= 0, then there is no limit on the number of open connections.  # Note: the default number of connections is 1024 for postgres of harbor.  max_open_conns: 900# The default data volumedata_volume: /data/docker/harbor# Harbor Storage settings by default is using /data dir on local filesystem# Uncomment storage_service setting If you want to using external storage# storage_service:#   # ca_bundle is the path to the custom root ca certificate, which will be injected into the truststore#   # of registry&#39;s and chart repository&#39;s containers.  This is usually needed when the user hosts a internal storage with self signed certificate.#   ca_bundle:#   # storage backend, default is filesystem, options include filesystem, azure, gcs, s3, swift and oss#   # for more info about this configuration please refer https://docs.docker.com/registry/configuration/#   filesystem:#     maxthreads: 100#   # set disable to true when you want to disable registry redirect#   redirect:#     disabled: false# Trivy configuration## Trivy DB contains vulnerability information from NVD, Red Hat, and many other upstream vulnerability databases.# It is downloaded by Trivy from the GitHub release page https://github.com/aquasecurity/trivy-db/releases and cached# in the local file system. In addition, the database contains the update timestamp so Trivy can detect whether it# should download a newer version from the Internet or use the cached one. Currently, the database is updated every# 12 hours and published as a new release to GitHub.trivy:  # ignoreUnfixed The flag to display only fixed vulnerabilities  ignore_unfixed: false  # skipUpdate The flag to enable or disable Trivy DB downloads from GitHub  #  # You might want to enable this flag in test or CI/CD environments to avoid GitHub rate limiting issues.  # If the flag is enabled you have to download the `trivy-offline.tar.gz` archive manually, extract `trivy.db` and  # `metadata.json` files and mount them in the `/home/scanner/.cache/trivy/db` path.  skip_update: false  #  # The offline_scan option prevents Trivy from sending API requests to identify dependencies.  # Scanning JAR files and pom.xml may require Internet access for better detection, but this option tries to avoid it.  # For example, the offline mode will not try to resolve transitive dependencies in pom.xml when the dependency doesn&#39;t  # exist in the local repositories. It means a number of detected vulnerabilities might be fewer in offline mode.  # It would work if all the dependencies are in local.  # This option doesn’t affect DB download. You need to specify &quot;skip-update&quot; as well as &quot;offline-scan&quot; in an air-gapped environment.  offline_scan: false  #  # insecure The flag to skip verifying registry certificate  insecure: false  # github_token The GitHub access token to download Trivy DB  #  # Anonymous downloads from GitHub are subject to the limit of 60 requests per hour. Normally such rate limit is enough  # for production operations. If, for any reason, it&#39;s not enough, you could increase the rate limit to 5000  # requests per hour by specifying the GitHub access token. For more details on GitHub rate limiting please consult  # https://developer.github.com/v3/#rate-limiting  #  # You can create a GitHub token by following the instructions in  # https://help.github.com/en/github/authenticating-to-github/creating-a-personal-access-token-for-the-command-line  #  # github_token: xxxjobservice:  # Maximum number of job workers in job service  max_job_workers: 10notification:  # Maximum retry count for webhook job  webhook_job_max_retry: 10chart:  # Change the value of absolute_url to enabled can enable absolute url in chart  absolute_url: disabled# Log configurationslog:  # options are debug, info, warning, error, fatal  level: info  # configs for logs in local storage  local:    # Log files are rotated log_rotate_count times before being removed. If count is 0, old versions are removed rather than rotated.    rotate_count: 50    # Log files are rotated only if they grow bigger than log_rotate_size bytes. If size is followed by k, the size is assumed to be in kilobytes.    # If the M is used, the size is in megabytes, and if G is used, the size is in gigabytes. So size 100, size 100k, size 100M and size 100G    # are all valid.    rotate_size: 200M    # The directory on your host that store log    location: /data/docker/harbor/log  # Uncomment following lines to enable external syslog endpoint.  # external_endpoint:  #   # protocol used to transmit log to external endpoint, options is tcp or udp  #   protocol: tcp  #   # The host of external endpoint  #   host: localhost  #   # Port of external endpoint  #   port: 5140#This attribute is for migrator to detect the version of the .cfg file, DO NOT MODIFY!_version: 2.6.0# Uncomment external_database if using external database.# external_database:#   harbor:#     host: harbor_db_host#     port: harbor_db_port#     db_name: harbor_db_name#     username: harbor_db_username#     password: harbor_db_password#     ssl_mode: disable#     max_idle_conns: 2#     max_open_conns: 0#   notary_signer:#     host: notary_signer_db_host#     port: notary_signer_db_port#     db_name: notary_signer_db_name#     username: notary_signer_db_username#     password: notary_signer_db_password#     ssl_mode: disable#   notary_server:#     host: notary_server_db_host#     port: notary_server_db_port#     db_name: notary_server_db_name#     username: notary_server_db_username#     password: notary_server_db_password#     ssl_mode: disable# Uncomment external_redis if using external Redis server# external_redis:#   # support redis, redis+sentinel#   # host for redis: &lt;host_redis&gt;:&lt;port_redis&gt;#   # host for redis+sentinel:#   #  &lt;host_sentinel1&gt;:&lt;port_sentinel1&gt;,&lt;host_sentinel2&gt;:&lt;port_sentinel2&gt;,&lt;host_sentinel3&gt;:&lt;port_sentinel3&gt;#   host: redis:6379#   password: #   # sentinel_master_set must be set to support redis+sentinel#   #sentinel_master_set:#   # db_index 0 is for core, it&#39;s unchangeable#   registry_db_index: 1#   jobservice_db_index: 2#   chartmuseum_db_index: 3#   trivy_db_index: 5#   idle_timeout_seconds: 30# Uncomment uaa for trusting the certificate of uaa instance that is hosted via self-signed cert.# uaa:#   ca_file: /path/to/ca# Global proxy# Config http proxy for components, e.g. http://my.proxy.com:3128# Components doesn&#39;t need to connect to each others via http proxy.# Remove component from `components` array if want disable proxy# for it. If you want use proxy for replication, MUST enable proxy# for core and jobservice, and set `http_proxy` and `https_proxy`.# Add domain to the `no_proxy` field, when you want disable proxy# for some special registry.proxy:  http_proxy:  https_proxy:  no_proxy:  components:    - core    - jobservice    - trivy# metric:#   enabled: false#   port: 9090#   path: /metrics# Trace related config# only can enable one trace provider(jaeger or otel) at the same time,# and when using jaeger as provider, can only enable it with agent mode or collector mode.# if using jaeger collector mode, uncomment endpoint and uncomment username, password if needed# if using jaeger agetn mode uncomment agent_host and agent_port# trace:#   enabled: true#   # set sample_rate to 1 if you wanna sampling 100% of trace data; set 0.5 if you wanna sampling 50% of trace data, and so forth#   sample_rate: 1#   # # namespace used to differenciate different harbor services#   # namespace:#   # # attributes is a key value dict contains user defined attributes used to initialize trace provider#   # attributes:#   #   application: harbor#   # # jaeger should be 1.26 or newer.#   # jaeger:#   #   endpoint: http://hostname:14268/api/traces#   #   username:#   #   password:#   #   agent_host: hostname#   #   # export trace data by jaeger.thrift in compact mode#   #   agent_port: 6831#   # otel:#   #   endpoint: hostname:4318#   #   url_path: /v1/traces#   #   compression: false#   #   insecure: true#   #   timeout: 10s# enable purge _upload directoriesupload_purging:  enabled: true  # remove files in _upload directories which exist for a period of time, default is one week.  age: 168h  # the interval of the purge operations  interval: 24h  dryrun: false# cache layer configurations# If this feature enabled, harbor will cache the resource# `project/project_metadata/repository/artifact/manifest` in the redis# which can especially help to improve the performance of high concurrent# manifest pulling.# NOTICE# If you are deploying Harbor in HA mode, make sure that all the harbor# instances have the same behaviour, all with caching enabled or disabled,# otherwise it can lead to potential data inconsistency.cache:  # not enabled by default  enabled: false  # keep cache for one day by default  expire_hours: 24</code></pre><pre><code class="bash"># 阻止 vim 样式穿透</code></pre><h3 id="nexus"><a href="#nexus" class="headerlink" title="nexus"></a>nexus</h3><pre><code class="bash"># create dir of nexussudo mkdir /data/nexus-data &amp;&amp; sudo chown -R 200 /data/nexus-datadocker run -d -p 8081:8081 --name nexus -v /data/nexus-data:/nexus-data 10.188.132.123:5000/library/sonatype/nexus3:3.63.0</code></pre><h3 id="jenkins"><a href="#jenkins" class="headerlink" title="jenkins"></a>jenkins</h3><p>修改启动用户，默认 anonymous 在 jenkins 脚本中没有权限创建文件</p><pre><code class="bash">sudo vi /etc/sysconfig/jenkins# 找到如下内容，修改后面的用户为有权限的用户JENKINS_USER=&quot;lemes&quot;# 重启 jenkinsservice jenkins restart</code></pre><h3 id="jenkins-docker"><a href="#jenkins-docker" class="headerlink" title="jenkins-docker"></a>jenkins-docker</h3><pre><code class="bash">docker run -d --name jenkins -p 9080:8080 10.188.132.44:5000/library/jenkins/jenkins:2.426.2-lts-jdk17sudo mkdir -p /data/jenkins_homesudo chown -R 1000:1000 /data/jenkins_homedocker run -d --name jenkins -p 9080:8080 \  -v /var/run/docker.sock:/var/run/docker.sock \  -v /data/jenkins_home:/var/jenkins_home \  10.188.132.44:5000/library/jenkins/jenkins:2.426.3-lts-jdk17-dinddocker run -d --name jenkins -p 8080:8080 \  -v /var/run/docker.sock:/var/run/docker.sock \  -v /data/jenkins_home:/var/jenkins_home \  10.188.132.44:5000/library/jenkins/jenkins:2.426.3-lts-jdk17-dinddocker run -d --name jenkins -p 9080:8080 \  -v /var/run/docker.sock:/var/run/docker.sock \  10.188.132.44:5000/library/jenkins/jenkins:2.426.3-lts-jdk17-dinddocker run -d --name jenkins -p 9080:8080 \  -v /var/run/docker.sock:/var/run/docker.sock \  10.188.132.44:5000/library/jenkins/jenkins:2.426.3-lts-jdk17-dinddocker run -d --name jenkins -p 8080:8080 \  -v /var/run/docker.sock:/var/run/docker.sock \  10.188.132.44:5000/library/jenkins/jenkins:2.426.3-lts-jdk17-dind-plugindocker run -d --name jenkins -p 8080:8080 \  -v /var/run/docker.sock:/var/run/docker.sock \  -v /data/jenkins_home:/var/jenkins_home \  jenkins:2.426.3-lts-jdk17-dinddocker run \  --rm \  -u root \  -p 8080:8080 \  -v jenkins-data:/var/jenkins_home \  -v /var/run/docker.sock:/var/run/docker.sock \  -v &quot;$HOME&quot;:/home \  jenkinsci/blueocean</code></pre><ul><li>jenkins plugin</li></ul><h3 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h3><pre><code class="bash">sudo yum install -y epel-releasesudo yum -y install nginx # 安装 nginxsudo yum remove nginx  # 卸载 nginx</code></pre><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><p>Download latest installation package from <a href="https://www.python.org/downloads/source/">https://www.python.org/downloads/source/</a></p><pre><code class="bash"># 安装依赖&amp;编译工具yum -y groupinstall &quot;Development tools&quot;yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-develyum install -y libffi-devel zlib1g-devyum install zlib* -y# 下载安装包wget https://www.python.org/ftp/python/3.9.1/Python-3.9.1.tgz# 解压tar -xvf Python-3.9.1.tgz# 创建编译目录mkdir /usr/local/python3# 编译./configure --prefix=/usr/local/python3 --enable-optimizations --with-ssl make &amp;&amp; make install# 创建软连接ln -s /usr/local/python3/bin/python3 /usr/local/bin/python3ln -s /usr/local/python3/bin/pip3 /usr/local/bin/pip3# 验证python3 -Vpip3 -V</code></pre><h3 id="gcc8"><a href="#gcc8" class="headerlink" title="gcc8"></a>gcc8</h3><pre><code class="bash">sudo yum install centos-release-scl devtoolset-8-gcc* -y# 激活生效（临时）scl enable devtoolset-8 bashgcc -v</code></pre><h3 id="jdk"><a href="#jdk" class="headerlink" title="jdk"></a>jdk</h3><pre><code class="bash"># 创建 jdk 存放目录mkdir -p /data/software/jdkcd /data/software/jdk# 下载 jdk 包wget https://corretto.aws/downloads/latest/amazon-corretto-8-x64-linux-jdk.tar.gz# 解压tar -zxvf amazon-corretto-8-x64-linux-jdk.tar.gz# 设置 JAVA_HOME 和 PATHvi /etc/profileexport JAVA_HOME=/data/software/jdk/amazon-corretto-8.322.06.2-linux-x64export PATH=$&#123;JAVA_HOME&#125;/bin:$&#123;PATH&#125;# 生效source /etc/profile</code></pre><pre><code class="bash">sudo rpm --import https://yum.corretto.aws/corretto.key  sudo curl -L -o /etc/yum.repos.d/corretto.repo https://yum.corretto.aws/corretto.reposudo yum install -y java-11-amazon-corretto-devel</code></pre><h3 id="maven"><a href="#maven" class="headerlink" title="maven"></a>maven</h3><pre><code class="bash"># 下载 maven 包 https://dlcdn.apache.org/mkdir -p /data/software/mavencd /data/software/mavenwget https://dlcdn.apache.org/maven/maven-3/3.9.1/binaries/apache-maven-3.9.1-bin.tar.gz --no-check-certificate# 解压tar -zxvf apache-maven-3.9.1-bin.tar.gz# 设置环境变量sudo vi /etc/profileMAVEN_HOME=/data/software/maven/apache-maven-3.9.1export PATH=$&#123;MAVEN_HOME&#125;/bin:$&#123;PATH&#125;# 生效source /etc/profile</code></pre><h3 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h3><pre><code class="bash"># https://redis.io/download/cd /usr/local/curl -LO https://codeload.github.com/redis/redis/tar.gz/refs/tags/7.0.5tar -zxvf redis-7.0.5.tar.gzcd redis-7.0.5/</code></pre><h3 id="ntp"><a href="#ntp" class="headerlink" title="ntp"></a>ntp</h3><pre><code class="bash">yum install ntp ntpdatesystemctl start ntpdsystemctl enable ntpd</code></pre><h2 id="System-setting"><a href="#System-setting" class="headerlink" title="System setting"></a>System setting</h2><h3 id="ssh-no-password"><a href="#ssh-no-password" class="headerlink" title="ssh no password"></a>ssh no password</h3><pre><code class="bash"># 客户端## 生成公私钥对ssh-keygen -t rsa -C &quot;yelog@mail.com&quot;## 复制下面下面打印出来的公钥cat ~/.ssh/id_rsa.pub# 将公钥上传到服务器ssh-copy-id -i ～/.ssh/id_rsa.pub root@xx.xx.xx.xx# 手动将密钥上传到服务器## 创建 authorized_keys（存在则忽略）touch ~/.ssh/authorized_keys## 设置权限chmod 700 -R ~/.ssh## 追加到文件内echo &quot;公钥&quot; &gt;&gt; ~/.ssh/authorized_keys</code></pre><h3 id="open-file-limit"><a href="#open-file-limit" class="headerlink" title="open file limit"></a>open file limit</h3><pre><code class="bash"># 获取当前系统设置的文件数ulimit -n# 软件限制ulimit  -Sn# 硬件限制ulimit  -Hn# 临时生效ulimit -SHn 10000# 永久生效sudo vim /etc/security/limits.conf* soft nofile 9000000* hard nofile 9000000# 查看当前进程打开了多少句柄数lsof -n|awk &#39;&#123;print $2&#125;&#39;|sort|uniq -c|sort -nr|moresudo vi /etc/sysctl.conf# 添加fs.file-max = 9000000fs.inotify.max_user_instances = 1000000fs.inotify.max_user_watches = 1000000# 生效sudo sysctl -p</code></pre><h3 id="firewalld"><a href="#firewalld" class="headerlink" title="firewalld"></a>firewalld</h3><pre><code class="bash"># 启动 firewalldsudo systemctl start firewalld# 查看 firewalld 状态sudo systemctl status firewalld# 关闭 firewalldsudo systemctl stop firewalld# 重新加载配置sudo firewall-cmd --reload# 允许端口(tcp)范围进行访问sudo firewall-cmd --zone=public --add-rich-rule=&#39;rule family=&quot;ipv4&quot; source address=&quot;0.0.0.0/0&quot; port port=&quot;1-9329&quot; protocol=&quot;tcp&quot; accept&#39; --permanent# 允许端口(udp)范围进行访问sudo firewall-cmd --zone=public --add-rich-rule=&#39;rule family=&quot;ipv4&quot; source address=&quot;0.0.0.0/0&quot; port port=&quot;1-9329&quot; protocol=&quot;udp&quot; accept&#39; --permanent# 添加访问端口 永久生效sudo firewall-cmd --zone=public --add-port=9332/tcp --permanent</code></pre><h3 id="disk"><a href="#disk" class="headerlink" title="disk"></a>disk</h3><pre><code class="bash"># 挂载磁盘 /dev/sda3 到/data目录， 重启失效# 需要提前 创建 /data 目录mount /dev/sda3 /data</code></pre><p>永久生效 <code>vi /etc/fstab</code>, 添加如下内容</p><pre><code class="bash">/dev/sda3 /data ext4 defaults 0 0</code></pre><h3 id="Cpu-Memory"><a href="#Cpu-Memory" class="headerlink" title="Cpu&amp;Memory"></a>Cpu&amp;Memory</h3><pre><code class="bash"># 查询物理个数grep &#39;physical id&#39; /proc/cpuinfo | sort -u | wc -l# 查看 CPU 物理核心数量grep &#39;core id&#39; /proc/cpuinfo | sort -u | wc -l# 查看 CPU 逻辑核心数量(一般说几C几G, 说的是逻辑核心)grep &#39;processor&#39; /proc/cpuinfo | sort -u | wc -l</code></pre><h2 id="command"><a href="#command" class="headerlink" title="command"></a>command</h2><h3 id="network"><a href="#network" class="headerlink" title="network"></a>network</h3><pre><code class="bash"># 监控 eth1 网卡的上下行网络watch -d ifstat eth1</code></pre><h3 id="files"><a href="#files" class="headerlink" title="files"></a>files</h3><h4 id="search-and-delete-file"><a href="#search-and-delete-file" class="headerlink" title="search and delete file"></a>search and delete file</h4><pre><code class="bash"># 查找并删除当前文件夹下（包括子目录） 的所有以 .bak 结尾的文件find . -name *.bak -type f -exec rm -rf &#123;&#125; \;# 查找并删除当前文件夹（包括子目录） 的所有 .settings 目录，并执行删除命令find . -name &#39;.settings&#39; -type d -exec rm -rf &#123;&#125; \;</code></pre><h3 id="ctrl-w-delete-word"><a href="#ctrl-w-delete-word" class="headerlink" title="ctrl-w delete word"></a>ctrl-w delete word</h3><p>add the following lines to my .bashrc</p><pre><code class="bash">stty werase undefbind &#39;\C-w:unix-filename-rubout&#39;</code></pre><h3 id="enable-vim-on-cli"><a href="#enable-vim-on-cli" class="headerlink" title="enable vim on cli"></a>enable vim on cli</h3><pre><code class="bash">set -o vi</code></pre><h3 id="set-time"><a href="#set-time" class="headerlink" title="set time"></a>set time</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Software-installation&quot;&gt;&lt;a href=&quot;#Software-installation&quot; class=&quot;headerlink&quot; title=&quot;Software installation&quot;&gt;&lt;/a&gt;Software installation&lt;/</summary>
      
    
    
    
    <category term="运维" scheme="http://yelog.org/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
    <category term="linux" scheme="http://yelog.org/tags/linux/"/>
    
    <category term="centos7" scheme="http://yelog.org/tags/centos7/"/>
    
    <category term="yum" scheme="http://yelog.org/tags/yum/"/>
    
  </entry>
  
  <entry>
    <title>Docker 常用命令</title>
    <link href="http://yelog.org/2024/08/30/docker-commands/"/>
    <id>http://yelog.org/2024/08/30/docker-commands/</id>
    <published>2024-08-30T02:43:21.000Z</published>
    <updated>2024-09-30T03:54:10.434Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Commands"><a href="#Commands" class="headerlink" title="Commands"></a>Commands</h2><pre><code class="bash"># 查询 docker 的磁盘使用情况docker system df# 每个容器的磁盘占用情况docker system df -v# 从容器中拷贝到宿主机docker cp &lt;container-id&gt;:&lt;path&gt; .</code></pre><h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><h3 id="安装卸载"><a href="#安装卸载" class="headerlink" title="安装卸载"></a>安装卸载</h3><h4 id="docker-install"><a href="#docker-install" class="headerlink" title="docker install"></a>docker install</h4><pre><code class="bash"># 安装依赖sudo yum install -y yum-utils device-mapper-persistent-data lvm2# 设置 yum 源sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo# 查看 docker 版本sudo yum list docker-ce --showduplicates | sort -r# 选取一个版本进行安装sudo yum install -y docker-ce-20.10.9# 启动 docker 并设置开机启动sudo systemctl enable --now docker</code></pre><h4 id="docker-uninstall"><a href="#docker-uninstall" class="headerlink" title="docker uninstall"></a>docker uninstall</h4><pre><code class="bash"># 卸载sudo yum remove -y docker docker-ce docker-common docker-selinux docker-engine</code></pre><h4 id="docker-设置私服和存储地址"><a href="#docker-设置私服和存储地址" class="headerlink" title="docker 设置私服和存储地址"></a>docker 设置私服和存储地址</h4><pre><code class="bash">sudo vi /etc/docker/daemon.json</code></pre><pre><code class="json">&#123;  &quot;registry-mirrors&quot;: [],  &quot;insecure-registries&quot;: [    &quot;10.188.132.44:5000&quot;,    &quot;10.188.132.123:5000&quot;,    &quot;10.176.2.207:5000&quot;  ],  &quot;data-root&quot;:&quot;/data/docker/system&quot;,  &quot;debug&quot;: true,  &quot;experimental&quot;: false,  &quot;log-driver&quot;: &quot;json-file&quot;,  &quot;log-opts&quot;: &#123;    &quot;max-size&quot;: &quot;10m&quot;,    &quot;max-file&quot;: &quot;1&quot;,    &quot;labels&quot;: &quot;production_status&quot;,    &quot;env&quot;: &quot;os,customer&quot;  &#125;&#125;</code></pre><pre><code class="bash">sudo systemctl restart docker# 直接生效 daemon.jsonsudo kill -SIGHUP $(pidof dockerd)</code></pre><blockquote><p>其他方法</p></blockquote><pre><code class="bash"># 创建一个挂在镜像和容器的地方，最好选存储空间大的位置mkdir -p /data/docker/system#如果下面位置找不到 可以通过 sudo find / -name &#39;docker.service&#39; -type f 寻找 docker.service 位置sudo vim /usr/lib/systemd/system/docker.service# 在 ExecStart 最后添加 私服和镜像存储位置 --insecure-registry 10.176.66.20:5000 --graph /data/docker/systemExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock --insecure-registry 10.176.66.20:5000 --graph /data/docker/system# 重载配置sudo systemctl daemon-reload# 重启服务sudo systemctl restart docker</code></pre><h4 id="授权当前用户-docker-的执行权限"><a href="#授权当前用户-docker-的执行权限" class="headerlink" title="授权当前用户 docker 的执行权限"></a>授权当前用户 docker 的执行权限</h4><pre><code class="bash"># 将当前用户添加到 docker 组内sudo gpasswd -a $USER docker# 刷新 docker 组配置newgrp docker# 重启 docker 服务sudo systemctl restart docker</code></pre><h3 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h3><p>1.自带插件</p><pre><code class="bash">sudo yum install -y docker-compose-plugin</code></pre><p>2.下载</p><pre><code class="bash"># 下载安装docker-composesudo curl -L &quot;https://github.com/docker/compose/releases/download/v2.17.2/docker-compose-linux-x86_64&quot; -o /usr/bin/docker-compose# 设置执行权限sudo chmod 777 /usr/bin/docker-compose</code></pre><h3 id="查看容器文件（原始启动失败的情况下）"><a href="#查看容器文件（原始启动失败的情况下）" class="headerlink" title="查看容器文件（原始启动失败的情况下）"></a>查看容器文件（原始启动失败的情况下）</h3><pre><code class="bash">docker run -it 10.176.2.207:5000/lemes-cloud/lemes-gateway:pgsql-master-202306181324 /bin/bash</code></pre><p>docker create -it –name dumy 10.188.132.123:5000&#x2F;lemes-cloud&#x2F;lemes-gateway:develop-202312111536 bash<br>docker cp dumy:&#x2F;data .</p><h3 id="从镜像想宿主机复制文件"><a href="#从镜像想宿主机复制文件" class="headerlink" title="从镜像想宿主机复制文件"></a>从镜像想宿主机复制文件</h3><pre><code class="bash"># 创建容器, 不启动docker create -it --name dumy 10.188.132.123:5000/library/mysql2postgresql-jdbc-agent:1.0.0 bash# 从容器内复制文件出来docker cp dumy:/tmp/mysql2postgresql-jdbc-agent-1.0.0.jar .# 移除容器docker rm dumy</code></pre><h3 id="打包镜像并还原镜像"><a href="#打包镜像并还原镜像" class="headerlink" title="打包镜像并还原镜像"></a>打包镜像并还原镜像</h3><pre><code class="bash"># 打包镜像docker save -o lemes-web.tar 10.176.2.207:5000/lemes-cloud/lemes-web:pgsql-master-202306272212# 还原镜像docker load -i lemes-web.tar</code></pre><h3 id="修改启动容器的端口映射-modify-port-mapping-of-running-container"><a href="#修改启动容器的端口映射-modify-port-mapping-of-running-container" class="headerlink" title="修改启动容器的端口映射 modify port mapping of running container"></a>修改启动容器的端口映射 modify port mapping of running container</h3><p>假设我们有已经启动的容器 <code>my-nginx</code>, 目前的端口映射为 <code>80:80</code>, 现在需要修改为 <code>8080:80</code></p><ol><li>首先通过 <code>docker ps | grep nginx</code> 查看容器的 <code>CONTAINER ID</code></li><li>找到 <code>docker</code> 的磁盘存储地址, 默认为 <code>/var/lib/docker/containers</code>, 如果修改了 <code>daemon.json</code> 中的 <code>data-root</code> 则需要修改对应的地址</li><li>在 <code>containers</code> 下载找到对应的 <code>CONTAINER ID</code> 的文件夹, 编辑其下的 <code>hostconfig.json</code> 文件</li><li>找到 <code>PortBindings</code> 下的 <code>80/tcp</code> 对应的 <code>HostPort</code> 目前应该是 <code>80</code>, 修改为 <code>8080</code></li><li>重启 <code>docker</code> 服务, <code>systemctl restart docker</code></li></ol><blockquote><p>注意: 如果需要修改容器内的端口, 比如要修改为 <code>80:8080</code><br>那么除了修改 <code>config.v2.json</code> 中的 <code>PortBindings</code> 的 <code>key</code> 从 <code>80/tcp</code> 到 <code>8080/tcp</code> 外<br>还需要修改 <code>config.v2.json</code> 中的 <code>ExposedPorts</code> 中的 <code>80/tcp</code> 为 <code>8080/tcp</code></p></blockquote><h2 id="problem"><a href="#problem" class="headerlink" title="problem"></a>problem</h2><h3 id="getting-the-final-child’s-pid-from-pipe-caused-EOF-unknown"><a href="#getting-the-final-child’s-pid-from-pipe-caused-EOF-unknown" class="headerlink" title="getting the final child’s pid from pipe caused: EOF: unknown"></a>getting the final child’s pid from pipe caused: EOF: unknown</h3><pre><code class="bash">sudo sysctl -w user.max_user_namespaces=150000</code></pre><h3 id="failed-to-start-daemon-Devices-cgroup-isn’t-mounted"><a href="#failed-to-start-daemon-Devices-cgroup-isn’t-mounted" class="headerlink" title="failed to start daemon: Devices cgroup isn’t mounted"></a>failed to start daemon: Devices cgroup isn’t mounted</h3><p>start docker deamon faild.</p><pre><code class="bash">$ sudo systemctl start dockerJob for docker.service failed because the control process exited with error code. See &quot;systemctl status docker.service&quot; and &quot;journalctl -xe&quot; for details.`$ journalctl -xe-- Subject: Unit docker.socket has finished start-up-- Defined-By: systemd-- Support: http://lists.freedesktop.org/mailman/listinfo/systemd-devel---- Unit docker.socket has finished starting up.---- The start-up result is done.May 19 10:26:34 szxlpidgapp06 systemd[1]: Starting Docker Application Container Engine...-- Subject: Unit docker.service has begun start-up-- Defined-By: systemd-- Support: http://lists.freedesktop.org/mailman/listinfo/systemd-devel---- Unit docker.service has begun starting up.May 19 10:26:34 szxlpidgapp06 dockerd[33200]: time=&quot;2022-05-19T10:26:34.580459394+08:00&quot; level=info msg=&quot;Starting up&quot;May 19 10:26:34 szxlpidgapp06 dockerd[33200]: time=&quot;2022-05-19T10:26:34.580654556+08:00&quot; level=debug msg=&quot;Listener created for HTTP on fd ()&quot;May 19 10:26:34 szxlpidgapp06 dockerd[33200]: time=&quot;2022-05-19T10:26:34.580999123+08:00&quot; level=debug msg=&quot;Golang&#39;s threads limit set to 922770&quot;May 19 10:26:34 szxlpidgapp06 dockerd[33200]: time=&quot;2022-05-19T10:26:34.582149991+08:00&quot; level=info msg=&quot;parsed scheme: \&quot;unix\&quot;&quot; module=grpcMay 19 10:26:34 szxlpidgapp06 dockerd[33200]: time=&quot;2022-05-19T10:26:34.582178725+08:00&quot; level=info msg=&quot;scheme \&quot;unix\&quot; not registered, fallback to default scheme&quot; module=grpcMay 19 10:26:34 szxlpidgapp06 dockerd[33200]: time=&quot;2022-05-19T10:26:34.582285273+08:00&quot; level=info msg=&quot;ccResolverWrapper: sending update to cc: &#123;[&#123;unix:///run/containerd/containerd.sock 0  &lt;nil&gt;&#125;] &lt;nil&gt;&#125;&quot; module=grpcMay 19 10:26:34 szxlpidgapp06 dockerd[33200]: time=&quot;2022-05-19T10:26:34.582321352+08:00&quot; level=info msg=&quot;ClientConn switching balancer to \&quot;pick_first\&quot;&quot; module=grpcMay 19 10:26:34 szxlpidgapp06 dockerd[33200]: time=&quot;2022-05-19T10:26:34.583565030+08:00&quot; level=info msg=&quot;parsed scheme: \&quot;unix\&quot;&quot; module=grpcMay 19 10:26:34 szxlpidgapp06 dockerd[33200]: time=&quot;2022-05-19T10:26:34.583585521+08:00&quot; level=info msg=&quot;scheme \&quot;unix\&quot; not registered, fallback to default scheme&quot; module=grpcMay 19 10:26:34 szxlpidgapp06 dockerd[33200]: time=&quot;2022-05-19T10:26:34.583602813+08:00&quot; level=info msg=&quot;ccResolverWrapper: sending update to cc: &#123;[&#123;unix:///run/containerd/containerd.sock 0  &lt;nil&gt;&#125;] &lt;nil&gt;&#125;&quot; module=grpcMay 19 10:26:34 szxlpidgapp06 dockerd[33200]: time=&quot;2022-05-19T10:26:34.583610828+08:00&quot; level=info msg=&quot;ClientConn switching balancer to \&quot;pick_first\&quot;&quot; module=grpcMay 19 10:26:34 szxlpidgapp06 dockerd[33200]: time=&quot;2022-05-19T10:26:34.584849300+08:00&quot; level=debug msg=&quot;Using default logging driver json-file&quot;May 19 10:26:34 szxlpidgapp06 dockerd[33200]: time=&quot;2022-05-19T10:26:34.584898470+08:00&quot; level=debug msg=&quot;processing event stream&quot; module=libcontainerd namespace=plugins.mobyMay 19 10:26:34 szxlpidgapp06 dockerd[33200]: time=&quot;2022-05-19T10:26:34.584902148+08:00&quot; level=debug msg=&quot;[graphdriver] priority list: [btrfs zfs overlay2 aufs overlay devicemapper vfs]&quot;May 19 10:26:34 szxlpidgapp06 dockerd[33200]: time=&quot;2022-05-19T10:26:34.594035041+08:00&quot; level=debug msg=&quot;backingFs=xfs, projectQuotaSupported=false, indexOff=\&quot;index=off,\&quot;&quot; storage-driver=overlay2May 19 10:26:34 szxlpidgapp06 dockerd[33200]: time=&quot;2022-05-19T10:26:34.594052376+08:00&quot; level=info msg=&quot;[graphdriver] using prior storage driver: overlay2&quot;May 19 10:26:34 szxlpidgapp06 dockerd[33200]: time=&quot;2022-05-19T10:26:34.594062706+08:00&quot; level=debug msg=&quot;Initialized graph driver overlay2&quot;May 19 10:26:34 szxlpidgapp06 dockerd[33200]: time=&quot;2022-05-19T10:26:34.594715135+08:00&quot; level=warning msg=&quot;Your kernel does not support cgroup memory limit&quot;May 19 10:26:34 szxlpidgapp06 dockerd[33200]: time=&quot;2022-05-19T10:26:34.594726229+08:00&quot; level=warning msg=&quot;Unable to find cpu cgroup in mounts&quot;May 19 10:26:34 szxlpidgapp06 dockerd[33200]: time=&quot;2022-05-19T10:26:34.594731880+08:00&quot; level=warning msg=&quot;Unable to find blkio cgroup in mounts&quot;May 19 10:26:34 szxlpidgapp06 dockerd[33200]: time=&quot;2022-05-19T10:26:34.594737414+08:00&quot; level=warning msg=&quot;Unable to find cpuset cgroup in mounts&quot;May 19 10:26:34 szxlpidgapp06 dockerd[33200]: time=&quot;2022-05-19T10:26:34.594741722+08:00&quot; level=warning msg=&quot;mountpoint for pids not found&quot;May 19 10:26:34 szxlpidgapp06 dockerd[33200]: time=&quot;2022-05-19T10:26:34.594868843+08:00&quot; level=debug msg=&quot;Cleaning up old mountid : start.&quot;May 19 10:26:34 szxlpidgapp06 dockerd[33200]: failed to start daemon: Devices cgroup isn&#39;t mountedMay 19 10:26:34 szxlpidgapp06 systemd[1]: docker.service: main process exited, code=exited, status=1/FAILUREMay 19 10:26:34 szxlpidgapp06 systemd[1]: Failed to start Docker Application Container Engine.-- Subject: Unit docker.service has failed-- Defined-By: systemd-- Support: http://lists.freedesktop.org/mailman/listinfo/systemd-devel---- Unit docker.service has failed.---- The result is failed.May 19 10:26:34 szxlpidgapp06 systemd[1]: Unit docker.service entered failed state.May 19 10:26:34 szxlpidgapp06 systemd[1]: docker.service failed.</code></pre><p><strong>failed to start daemon: Devices cgroup isn’t mounted</strong> is very important message.</p><p>We check docker config by <code>https://raw.githubusercontent.com/moby/moby/master/contrib/check-config.sh</code></p><pre><code class="bash">warning: /proc/config.gz does not exist, searching other paths for kernel config ...info: reading kernel config from /boot/config-3.10.0-1160.62.1.el7.x86_64 ...Generally Necessary:- cgroup hierarchy: nonexistent??    (see https://github.com/tianon/cgroupfs-mount)- CONFIG_NAMESPACES: enabled- CONFIG_NET_NS: enabled- CONFIG_PID_NS: enabled- CONFIG_IPC_NS: enabled- CONFIG_UTS_NS: enabled- CONFIG_CGROUPS: enabled- CONFIG_CGROUP_CPUACCT: enabled- CONFIG_CGROUP_DEVICE: enabled- CONFIG_CGROUP_FREEZER: enabled- CONFIG_CGROUP_SCHED: enabled- CONFIG_CPUSETS: enabled- CONFIG_MEMCG: enabled- CONFIG_KEYS: enabled- CONFIG_VETH: enabled (as module)- CONFIG_BRIDGE: enabled (as module)- CONFIG_BRIDGE_NETFILTER: enabled (as module)- CONFIG_IP_NF_FILTER: enabled (as module)- CONFIG_IP_NF_TARGET_MASQUERADE: enabled (as module)- CONFIG_NETFILTER_XT_MATCH_ADDRTYPE: enabled (as module)- CONFIG_NETFILTER_XT_MATCH_CONNTRACK: enabled (as module)- CONFIG_NETFILTER_XT_MATCH_IPVS: enabled (as module)- CONFIG_NETFILTER_XT_MARK: enabled (as module)- CONFIG_IP_NF_NAT: enabled (as module)- CONFIG_NF_NAT: enabled (as module)- CONFIG_POSIX_MQUEUE: enabled- CONFIG_DEVPTS_MULTIPLE_INSTANCES: enabled- CONFIG_NF_NAT_IPV4: enabled (as module)- CONFIG_NF_NAT_NEEDED: enabled</code></pre><p><strong>cgroup hierarchy: nonexistent??</strong>, so we mounted cgroup by following script</p><blockquote><p>reference url: <a href="https://github.com/tianon/cgroupfs-mount/blob/master/cgroupfs-mount">https://github.com/tianon/cgroupfs-mount/blob/master/cgroupfs-mount</a></p></blockquote><pre><code class="bash">#!/bin/sh# Copyright 2011 Canonical, Inc#           2014 Tianon Gravi# Author: Serge Hallyn &lt;serge.hallyn@canonical.com&gt;#         Tianon Gravi &lt;tianon@debian.org&gt;set -e# for simplicity this script provides no flexibility# if cgroup is mounted by fstab, don&#39;t run# don&#39;t get too smart - bail on any uncommented entry with &#39;cgroup&#39; in itif grep -v &#39;^#&#39; /etc/fstab | grep -q cgroup; then echo &#39;cgroups mounted from fstab, not mounting /sys/fs/cgroup&#39; exit 0fi# kernel provides cgroups?if [ ! -e /proc/cgroups ]; then exit 0fi# if we don&#39;t even have the directory we need, something else must be wrongif [ ! -d /sys/fs/cgroup ]; then exit 0fi# mount /sys/fs/cgroup if not already doneif ! mountpoint -q /sys/fs/cgroup; then mount -t tmpfs -o uid=0,gid=0,mode=0755 cgroup /sys/fs/cgroupficd /sys/fs/cgroup# get/mount list of enabled cgroup controllersfor sys in $(awk &#39;!/^#/ &#123; if ($4 == 1) print $1 &#125;&#39; /proc/cgroups); do mkdir -p $sys if ! mountpoint -q $sys; then  if ! mount -n -t cgroup -o $sys cgroup $sys; then   rmdir $sys || true  fi fidone# example /proc/cgroups:#  #subsys_name hierarchy num_cgroups enabled#  cpuset 2 3 1#  cpu 3 3 1#  cpuacct 4 3 1#  memory 5 3 0#  devices 6 3 1#  freezer 7 3 1#  blkio 8 3 1# enable cgroups memory hierarchy, like systemd does (and lxc/docker desires)# https://github.com/systemd/systemd/blob/v245/src/core/cgroup.c#L2983# https://bugs.debian.org/940713if [ -e /sys/fs/cgroup/memory/memory.use_hierarchy ]; then echo 1 &gt; /sys/fs/cgroup/memory/memory.use_hierarchyfiexit 0</code></pre><h3 id="systemctl-start-docker-卡住"><a href="#systemctl-start-docker-卡住" class="headerlink" title="systemctl start docker 卡住"></a>systemctl start docker 卡住</h3><p>通过 <code>systemctl status docker</code> 查看状态, 发现并没有关闭成功</p><p>我们可以通过如下脚本, 进行强制关闭</p><pre><code class="bash">while true; do    kill -9 $(pidof containerd) $(pidof dockerd)    if [[ ! &quot;$?&quot; = &quot;0&quot; ]]; then        break    fidone</code></pre><p>然后再次启动 <code>docker</code> 即可</p><h2 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h2><ol><li><a href="https://download.docker.com/linux/centos/7/x86_64/stable/Packages/">docker centos rpm</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Commands&quot;&gt;&lt;a href=&quot;#Commands&quot; class=&quot;headerlink&quot; title=&quot;Commands&quot;&gt;&lt;/a&gt;Commands&lt;/h2&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;# 查询 docker 的磁盘使用情况
docke</summary>
      
    
    
    
    <category term="运维" scheme="http://yelog.org/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
    <category term="docker" scheme="http://yelog.org/tags/docker/"/>
    
    <category term="commands" scheme="http://yelog.org/tags/commands/"/>
    
  </entry>
  
  <entry>
    <title>用 neovim 写 markdown 是一种什么样的体验(含技巧)</title>
    <link href="http://yelog.org/2024/08/02/write-markdown-in-neovim-experience-and-tips/"/>
    <id>http://yelog.org/2024/08/02/write-markdown-in-neovim-experience-and-tips/</id>
    <published>2024-08-02T07:10:59.000Z</published>
    <updated>2024-09-30T03:54:09.637Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从上大学开始使用 <code>vim</code> 已有 12 年, 最近三四年开始深度使用 <code>vim/neovim</code>, 包括写代码, 写文档, 写博客等等. 从这篇文章开始, 我将会记录和分享关于 <code>vim</code> 的一些使用技巧, 配置和插件.</p><p>插件管理器推荐 <code>lazy.nvim</code>, 如下配置也是基于 <code>lazy.nvim</code> 的, 其他的插件管理器配置也相似</p><p>很多使用技巧是基于插件和配置的, 所以本文的大纲如下:</p><ol><li>样式</li><li>效率</li><li>Snippet</li></ol><h1 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h1><h2 id="全局主题"><a href="#全局主题" class="headerlink" title="全局主题"></a>全局主题</h2><p>使用的是 <a href="https://github.com/folke/tokyonight.nvim">folke&#x2F;tokyonight.nvim</a> 主题</p><pre><code class="lua">&#123;  &quot;folke/tokyonight.nvim&quot;,  config = function()    require(&quot;tokyonight&quot;).setup(&#123;      style = &quot;night&quot;,        -- The theme comes in three styles, `storm`, `moon`, a darker variant `night` and `day`      light_style = &quot;day&quot;,    -- The theme is used when the background is set to light      transparent = true,     -- Enable this to disable setting the background color      terminal_colors = true, -- Configure the colors used when opening a `:terminal` in Neovim      styles = &#123;        comments = &#123; italic = true &#125;,        keywords = &#123; italic = true &#125;,        functions = &#123;&#125;,        variables = &#123;&#125;,        sidebars = &quot;transparent&quot;,       -- style for sidebars, see below        floats = &quot;transparent&quot;,         -- style for floating windows      &#125;,      sidebars = &#123; &quot;qf&quot;, &quot;help&quot; &#125;,      -- Set a darker background on sidebar-like windows. For example: `[&quot;qf&quot;, &quot;vista_kind&quot;, &quot;terminal&quot;, &quot;packer&quot;]`      day_brightness = 0.3,             -- Adjusts the brightness of the colors of the **Day** style. Number between 0 and 1, from dull to vibrant colors      hide_inactive_statusline = false, -- Enabling this option, will hide inactive statuslines and replace them with a thin border instead. Should work with the standard **StatusLine** and **LuaLine**.      dim_inactive = true,              -- dims inactive windows      lualine_bold = true,              -- When `true`, section headers in the lualine theme will be bold      on_colors = function(colors)        colors.border = &quot;#ef9020&quot;      end,      on_highlights = function(hl, c)        hl.Visual = &#123; bg = &quot;#6D6BC8&quot; &#125;      end,    &#125;)    vim.cmd([[colorscheme tokyonight]])  end,&#125;</code></pre><h2 id="代码块高亮"><a href="#代码块高亮" class="headerlink" title="代码块高亮"></a>代码块高亮</h2><p>使用的是 <a href="https://github.com/tpope/vim-markdown">tpope&#x2F;vim-markdown</a> 提供的代码块高亮功能</p><pre><code class="lua">&#123;    &quot;tpope/vim-markdown&quot;,    config = function()      -- tpope/vim-markdown      vim.g.markdown_syntax_conceal = 0      vim.g.markdown_fenced_languages =      &#123; &quot;html&quot;, &quot;python&quot;, &quot;bash=sh&quot;, &quot;json&quot;, &quot;java&quot;, &quot;js=javascript&quot;, &quot;sql&quot;, &quot;yaml&quot;, &quot;xml&quot;, &quot;Dockerfile&quot;, &quot;Rust&quot;,        &quot;swift&quot;, &quot;javascript&quot;, &#39;lua&#39; &#125;    end,&#125;, --&gt; syntax highlighting and filetype plugins for Markdown</code></pre><p>如下图所示, 左边是原始 markdown 文本, 右边是开启了 <code>vim-markdown</code> 插件的效果:</p><p><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/202408301733036.png" alt="vim-markdown"></p><h2 id="终端实时渲染"><a href="#终端实时渲染" class="headerlink" title="终端实时渲染"></a>终端实时渲染</h2><p>使用的是 <a href="https://github.com/yelog/marklive.nvim">yelog&#x2F;marklive.nvim</a> 进行终端样式实时渲染</p><pre><code class="lua">&#123;    &quot;yelog/marklive.nvim&quot;,    dependencies = &#123; &#39;nvim-treesitter/nvim-treesitter&#39; &#125;,    lazy = true,    ft = &quot;markdown&quot;,    dev = true,&#125;,</code></pre><p>效果如下:</p><p><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/202408301903047.png" alt="marklive.nvim"></p><h2 id="实时浏览器预览"><a href="#实时浏览器预览" class="headerlink" title="实时浏览器预览"></a>实时浏览器预览</h2><p><a href="https://github.com/iamcco/markdown-preview.nvim">iamcco&#x2F;markdown-preview.nvim</a>, 这是一个 <code>Markdown</code> 实时预览插件, 支持 <code>Github</code> 风格的 <code>Markdown</code>, 也支持数学公式渲染. 安装方法如下:</p><pre><code class="lua">&#123;    &quot;iamcco/markdown-preview.nvim&quot;,    cmd = &#123; &quot;MarkdownPreviewToggle&quot;, &quot;MarkdownPreview&quot;, &quot;MarkdownPreviewStop&quot; &#125;,    ft = &#123; &quot;markdown&quot; &#125;,    build = function()      vim.fn[&quot;mkdp#util#install&quot;]()      vim.g.mkdp_theme = &#39;light&#39;    end,&#125;</code></pre><p>添加了上面的插件后, 可以使用 <code>:MarkdownPreview</code> 命令就会自动弹出默认浏览器, 进行 markdown 实时预览.</p><p>效果如下:</p><p><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/202408301727428.gif" alt="markdown-preview"></p><h1 id="效率插件"><a href="#效率插件" class="headerlink" title="效率插件"></a>效率插件</h1><h2 id="普通列表"><a href="#普通列表" class="headerlink" title="普通列表"></a>普通列表</h2><p><a href="https://github.com/bullets-vim/bullets.vim">bullets-vim&#x2F;bullets.vim</a>, 这是一个辅助写 list 的插件, 支持有序列表, 无序列表, 任务列表等等, 可以缩进, 新增</p><pre><code class="lua">&#123;    &quot;bullets-vim/bullets.vim&quot;,    config = function()      vim.g.bullets_enabled_file_types = &#123; &quot;markdown&quot;, &quot;text&quot;, &quot;gitcommit&quot;, &quot;scratch&quot; &#125;    end,&#125;</code></pre><p>效果如下:</p><p><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/202408301740833.gif" alt="bullets.vim"></p><h2 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h2><p><a href="https://github.com/tenxsoydev/vim-markdown-checkswitch">tenxsoydev&#x2F;vim-markdown-checkswitch</a>, 任务状态切换插件</p><pre><code class="lua">&#123;    &quot;tenxsoydev/vim-markdown-checkswitch&quot;,        config = function()        vim.g.md_checkswitch_style = &quot;cycle&quot;    end,&#125;</code></pre><p>效果如下, 可以通过 <code>:CheckSwitch</code> 命令切换任务状态</p><p><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/202408311644937.gif" alt="CheckSwitch"></p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p><a href="https://github.com/dhruvasagar/vim-table-mode">dhruvasagar&#x2F;vim-table-mode</a>, 这是一个支持在 <code>vim/neovim</code> 中编辑 <code>markdown</code> 表格的插件, 支持高亮, 自动对齐, 自动生成等</p><pre><code class="lua">&#123;    &quot;dhruvasagar/vim-table-mode&quot;,    config = function()      vim.cmd([[        augroup markdown_config          autocmd!          autocmd FileType markdown nnoremap &lt;buffer&gt; &lt;M-s&gt; :TableModeRealign&lt;CR&gt;        augroup END      ]], false)      vim.g.table_mode_sort_map = &#39;&lt;leader&gt;mts&#39;    end&#125;, --&gt; table mode</code></pre><p>效果如下</p><p><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/202408301748302.gif" alt="vim-table-mode"></p><h1 id="Snippet"><a href="#Snippet" class="headerlink" title="Snippet"></a>Snippet</h1><pre><code class="snippets"># https://github.com/honza/vim-snippets/blob/master/snippets/markdown.snippetssnippet h1    # $&#123;1&#125;    $&#123;2&#125;snippet h2    ## $&#123;1&#125;    $&#123;2&#125;snippet h3    ### $&#123;1&#125;    $&#123;2&#125;snippet h4    #### $&#123;1&#125;    $&#123;2&#125;snippet h5    ##### $&#123;1&#125;    $&#123;2&#125;snippet h6    ##### $&#123;1&#125;    $&#123;2&#125;snippet h6    ##### $&#123;1&#125;    $&#123;2&#125;snippet l    [$&#123;1&#125;]($&#123;2&#125;) $&#123;3&#125;snippet !    ![$&#123;1&#125;]($&#123;2&#125;) $&#123;3&#125;snippet *    *$&#123;1&#125;* $&#123;2&#125;snippet **    **$&#123;1&#125;** $&#123;2&#125;snippet code    \`$&#123;1&#125;\` $&#123;2&#125;snippet codeblock    \`\`\`$&#123;1&#125;    $&#123;2&#125;    \`\`\`    $&#123;3&#125;snippet tb    | $&#123;1&#125; | $&#123;2&#125; | $&#123;3&#125; |    | ---- | ---- | ---- |    | $&#123;4&#125; | $&#123;5&#125; | $&#123;6&#125; |snippet tb2    | $&#123;1&#125; | $&#123;2&#125; |    | ---- | ---- |    | $&#123;4&#125; | $&#123;5&#125; |snippet info    ---    title: $&#123;1:`expand(&#39;%:t:r&#39;)`&#125;    enlink: $&#123;2&#125;    date: `strftime(&#39;%Y-%m-%d %H:%M:%S&#39;)`    categories:    - $&#123;3&#125;    tags:    - $&#123;4&#125;    ---snippet callout    &gt; [!$&#123;1:NOTE&#125;] $&#123;2:title&#125;    &gt; $&#123;3:content&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;从上大学开始使用 &lt;code&gt;vim&lt;/code&gt; 已有 12 年, 最近三四年开始深度使用 &lt;code&gt;vim/neovim&lt;/code&gt;</summary>
      
    
    
    
    <category term="工具" scheme="http://yelog.org/categories/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="vim" scheme="http://yelog.org/categories/%E5%B7%A5%E5%85%B7/vim/"/>
    
    
    <category term="vim" scheme="http://yelog.org/tags/vim/"/>
    
    <category term="neovim" scheme="http://yelog.org/tags/neovim/"/>
    
    <category term="editor" scheme="http://yelog.org/tags/editor/"/>
    
    <category term="markdown" scheme="http://yelog.org/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>Jackson 时间序列化/反序列化详解</title>
    <link href="http://yelog.org/2024/07/05/Jackson%20Time%20Serializer/Deserializer/"/>
    <id>http://yelog.org/2024/07/05/Jackson%20Time%20Serializer/Deserializer/</id>
    <published>2024-07-05T08:00:00.000Z</published>
    <updated>2024-09-30T03:54:10.243Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在项目中遇到了时间序列化的问题，所以研究了一下 Jackson 的时间序列化&#x2F;反序列化，这里做一个详细的总结。</p><h1 id="0-准备工作"><a href="#0-准备工作" class="headerlink" title="0. 准备工作"></a>0. 准备工作</h1><p>准备实体类 User.java</p><pre><code class="java">package com.example.testjava.entity;import lombok.Builder;import lombok.Data;import java.time.LocalDate;import java.time.LocalDateTime;import java.time.LocalTime;import java.util.Date;@Builder@Datapublic class User &#123;    private String name;    private Date date;    private LocalDate localDate;    private LocalDateTime localDateTime;    private LocalTime localTime;    private java.sql.Date sqlDate;    private java.sql.Time sqlTime;    private java.sql.Timestamp timestamp;&#125;</code></pre><p>简单查询</p><pre><code class="java">package com.example.testjava.controller;import com.example.testjava.entity.User;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.Date;@RestController@RequestMapping(&quot;/jackson&quot;)public class JacksonTestController &#123;    @GetMapping(&quot;/query&quot;)    public User testJavaDate() &#123;        return User.builder()                .name(&quot;test&quot;)                .date(new Date())                .localDate(java.time.LocalDate.now())                .localDateTime(java.time.LocalDateTime.now())                .localTime(java.time.LocalTime.now())                .sqlDate(new java.sql.Date(System.currentTimeMillis()))                .sqlTime(new java.sql.Time(System.currentTimeMillis()))                .timestamp(new java.sql.Timestamp(System.currentTimeMillis()))                .build();    &#125;&#125;</code></pre><h1 id="1-序列化"><a href="#1-序列化" class="headerlink" title="1. 序列化"></a>1. 序列化</h1><h2 id="1-1-默认返回"><a href="#1-1-默认返回" class="headerlink" title="1.1. 默认返回"></a>1.1. 默认返回</h2><pre><code class="json">&#123;    &quot;name&quot;: &quot;test&quot;,    &quot;date&quot;: &quot;2024-07-05T08:09:47.100+00:00&quot;,    &quot;localDate&quot;: &quot;2024-07-05&quot;,    &quot;localDateTime&quot;: &quot;2024-07-05T16:09:47.100462&quot;,    &quot;localTime&quot;: &quot;16:09:47.100514&quot;,    &quot;sqlDate&quot;: &quot;2024-07-05&quot;,    &quot;sqlTime&quot;: &quot;16:09:47&quot;,    &quot;timestamp&quot;: &quot;2024-07-05T08:09:47.100+00:00&quot;&#125;</code></pre><h1 id="1-2-添加配置"><a href="#1-2-添加配置" class="headerlink" title="1.2. 添加配置"></a>1.2. 添加配置</h1><p>配置如下</p><pre><code class="yaml">spring:  jackson:    date-format: yyyy-MM-dd HH:mm:ss</code></pre><p>返回效果</p><pre><code class="json">&#123;    &quot;name&quot;: &quot;test&quot;,    &quot;date&quot;: &quot;2024-07-05 08:16:07&quot;,    &quot;localDate&quot;: &quot;2024-07-05&quot;,    &quot;localDateTime&quot;: &quot;2024-07-05T16:16:07.097035&quot;,    &quot;localTime&quot;: &quot;16:16:07.09705&quot;,    &quot;sqlDate&quot;: &quot;2024-07-05&quot;,    &quot;sqlTime&quot;: &quot;16:16:07&quot;,    &quot;timestamp&quot;: &quot;2024-07-05 08:16:07&quot;&#125;</code></pre><p>可以发现, 日期时间类型中, 只有 <code>java.time.LocalDateTime</code> 没有按照配置序列化, <code>java.util.Date</code> 和 <code>java.sql.Timestamp</code> 按照配置序列化了。</p><h1 id="1-3-添加注解"><a href="#1-3-添加注解" class="headerlink" title="1.3. 添加注解"></a>1.3. 添加注解</h1><pre><code class="java">package com.example.testjava.entity;import com.fasterxml.jackson.annotation.JsonFormat;import lombok.Builder;import lombok.Data;import java.time.LocalDate;import java.time.LocalDateTime;import java.time.LocalTime;import java.util.Date;@Builder@Datapublic class User &#123;    private String name;    @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)    private Date date;    private LocalDate localDate;    @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)    private LocalDateTime localDateTime;    @JsonFormat(pattern = &quot;HH:mm:ss&quot;)    private LocalTime localTime;    private java.sql.Date sqlDate;    private java.sql.Time sqlTime;    @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)    private java.sql.Timestamp timestamp;&#125;</code></pre><p>返回效果</p><pre><code class="json">&#123;    &quot;name&quot;: &quot;test&quot;,    &quot;date&quot;: &quot;2024-07-05 08:24:36&quot;,    &quot;localDate&quot;: &quot;2024-07-05&quot;,    &quot;localDateTime&quot;: &quot;2024-07-05 16:24:36&quot;,    &quot;localTime&quot;: &quot;16:24:36&quot;,    &quot;sqlDate&quot;: &quot;2024-07-05&quot;,    &quot;sqlTime&quot;: &quot;16:24:36&quot;,    &quot;timestamp&quot;: &quot;2024-07-05 08:24:36&quot;&#125;</code></pre><p>注解是可以都有效的</p><h1 id="2-反序列化"><a href="#2-反序列化" class="headerlink" title="2. 反序列化"></a>2. 反序列化</h1><p>准备请求</p><pre><code class="java">    @PostMapping(&quot;/save&quot;)    public User save(@RequestBody User user) &#123;        return user;    &#125;</code></pre><p>请求参数</p><pre><code class="json">&#123;    &quot;name&quot;: &quot;test&quot;,    &quot;date&quot;: &quot;2024-07-05 08:24:36&quot;,    &quot;localDate&quot;: &quot;2024-07-05&quot;,    &quot;localDateTime&quot;: &quot;2024-07-05 16:24:36&quot;,    &quot;localTime&quot;: &quot;16:24:36&quot;,    &quot;sqlDate&quot;: &quot;2024-07-05&quot;,    &quot;sqlTime&quot;: &quot;16:24:36&quot;,    &quot;timestamp&quot;: &quot;2024-07-05 08:24:36&quot;&#125;</code></pre><h2 id="2-1-默认效果"><a href="#2-1-默认效果" class="headerlink" title="2.1 默认效果"></a>2.1 默认效果</h2><p>默认报错</p><pre><code class="text">JSON parse error: Cannot deserialize value of type `java.util.Date` from String \&quot;2024-07-05 08:24:36\&quot;</code></pre><h2 id="2-2-添加配置"><a href="#2-2-添加配置" class="headerlink" title="2.2 添加配置"></a>2.2 添加配置</h2><p>有两种方法可以解决, 一个是自定义时间序列化, 一个是自定义 objectMapper</p><h3 id="2-2-1-自定义时间序列化"><a href="#2-2-1-自定义时间序列化" class="headerlink" title="2.2.1 自定义时间序列化"></a>2.2.1 自定义时间序列化</h3><pre><code class="java">/** * 此转换方法试用于 json 请求 * LocalDateTime 时间格式转换 支持 */@JsonComponent@Configurationpublic class LocalDateTimeFormatConfiguration extends JsonDeserializer&lt;LocalDateTime&gt; &#123;    @Value(&quot;$&#123;spring.jackson.date-format:yyyy-MM-dd HH:mm:ss&#125;&quot;)    private String pattern;    /**     * LocalDate 类型全局时间格式化     * @return     */    @Bean    public LocalDateTimeSerializer localDateTimeDeserializer() &#123;        return new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(pattern));    &#125;    @Bean    public Jackson2ObjectMapperBuilderCustomizer jackson2ObjectMapperBuilderCustomizer() &#123;        return builder -&gt; builder.serializerByType(LocalDateTime.class, localDateTimeDeserializer());    &#125;    @Override    public LocalDateTime deserialize(JsonParser jsonParser, DeserializationContext deserializationContext) throws IOException, JsonProcessingException &#123;        return StrUtil.isEmpty(jsonParser.getText()) ? null : LocalDateTimeUtil.of(new DateTime(jsonParser.getText()));    &#125;&#125;</code></pre><pre><code class="java">@JsonComponent@Configurationpublic class DateFormatConfiguration extends JsonDeserializer&lt;Date&gt; &#123;    @Value(&quot;$&#123;spring.jackson.date-format:yyyy-MM-dd HH:mm:ss&#125;&quot;)    private String pattern;    /**     * date 类型全局时间格式化     *     * @return     */    @Bean    public Jackson2ObjectMapperBuilderCustomizer jackson2ObjectMapperBuilder() &#123;        return builder -&gt; &#123;            TimeZone tz = TimeZone.getTimeZone(&quot;UTC&quot;);            DateFormat df = new SimpleDateFormat(pattern);            df.setTimeZone(tz);            builder.failOnEmptyBeans(false)                    .failOnUnknownProperties(false)                    .featuresToDisable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)                    .dateFormat(df);        &#125;;    &#125;    @Override    public Date deserialize(JsonParser jsonParser, DeserializationContext deserializationContext) throws IOException, JsonProcessingException &#123;        return StrUtil.isEmpty(jsonParser.getText()) ? null : new DateTime(jsonParser.getText());    &#125;&#125;</code></pre><h3 id="2-2-2-自定义-objectMapper"><a href="#2-2-2-自定义-objectMapper" class="headerlink" title="2.2.2 自定义 objectMapper"></a>2.2.2 自定义 objectMapper</h3><pre><code class="java">package com.example.testjava.config;import cn.hutool.core.date.DatePattern;import cn.hutool.core.date.DateTime;import cn.hutool.core.date.LocalDateTimeUtil;import cn.hutool.core.util.StrUtil;import com.fasterxml.jackson.core.JacksonException;import com.fasterxml.jackson.core.JsonGenerator;import com.fasterxml.jackson.core.JsonParser;import com.fasterxml.jackson.databind.Module;import com.fasterxml.jackson.databind.*;import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateDeserializer;import com.fasterxml.jackson.datatype.jsr310.deser.LocalTimeDeserializer;import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateSerializer;import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateTimeSerializer;import com.fasterxml.jackson.datatype.jsr310.ser.LocalTimeSerializer;import org.springframework.beans.factory.annotation.Value;import org.springframework.boot.autoconfigure.AutoConfigureBefore;import org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import java.io.IOException;import java.sql.Time;import java.sql.Timestamp;import java.text.SimpleDateFormat;import java.time.LocalDate;import java.time.LocalDateTime;import java.time.LocalTime;import java.time.format.DateTimeFormatter;import java.util.Date;@Configuration@AutoConfigureBefore(JacksonAutoConfiguration.class)public class JacksonConfig &#123;    @Value(&quot;$&#123;spring.jackson.date-format:yyyy-MM-dd HH:mm:ss&#125;&quot;)    private String pattern;    @Bean    public ObjectMapper objectMapper() &#123;        ObjectMapper objectMapper = new ObjectMapper();        // 在反序列化时, 如果对象没有对应的字段, 不抛出异常        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);        objectMapper.registerModule(javaTimeModule());        objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);        return objectMapper;    &#125;    private Module javaTimeModule() &#123;        JavaTimeModule module = new JavaTimeModule();        // 序列化        module.addSerializer(new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(pattern)));        module.addSerializer(new LocalTimeSerializer(DateTimeFormatter.ofPattern(DatePattern.NORM_TIME_PATTERN)));        module.addSerializer(new LocalDateSerializer(DateTimeFormatter.ofPattern(DatePattern.NORM_DATE_PATTERN)));        module.addSerializer(Date.class, new JsonSerializer&lt;&gt;() &#123;            @Override            public void serialize(Date date, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException &#123;                SimpleDateFormat sdf = new SimpleDateFormat(pattern);                jsonGenerator.writeString(sdf.format(date));            &#125;        &#125;);        module.addSerializer(java.sql.Date.class, new JsonSerializer&lt;&gt;() &#123;            @Override            public void serialize(java.sql.Date date, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException &#123;                SimpleDateFormat sdf = new SimpleDateFormat(pattern);                jsonGenerator.writeString(sdf.format(date));            &#125;        &#125;);        module.addSerializer(Timestamp.class, new JsonSerializer&lt;&gt;() &#123;            @Override            public void serialize(Timestamp timestamp, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException &#123;                SimpleDateFormat sdf = new SimpleDateFormat(pattern);                jsonGenerator.writeString(sdf.format(timestamp));            &#125;        &#125;);        module.addSerializer(Time.class, new JsonSerializer&lt;&gt;() &#123;            @Override            public void serialize(Time time, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException &#123;                SimpleDateFormat sdf = new SimpleDateFormat(DatePattern.NORM_TIME_PATTERN);                jsonGenerator.writeString(sdf.format(time));            &#125;        &#125;);        // 反序列化        module.addDeserializer(LocalDateTime.class, new JsonDeserializer&lt;LocalDateTime&gt;() &#123;            @Override            public LocalDateTime deserialize(JsonParser jsonParser, DeserializationContext deserializationContext) throws IOException, JacksonException &#123;                return StrUtil.isEmpty(jsonParser.getText()) ? null : LocalDateTimeUtil.of(new DateTime(jsonParser.getText()));            &#125;        &#125;);        module.addDeserializer(LocalDate.class, new LocalDateDeserializer(DateTimeFormatter.ofPattern(DatePattern.NORM_DATE_PATTERN)));        module.addDeserializer(LocalTime.class, new LocalTimeDeserializer(DateTimeFormatter.ofPattern(DatePattern.NORM_TIME_PATTERN)));        module.addDeserializer(Date.class, new JsonDeserializer&lt;Date&gt;() &#123;            @Override            public Date deserialize(JsonParser jsonParser, DeserializationContext deserializationContext) throws IOException &#123;                return StrUtil.isEmpty(jsonParser.getText()) ? null : new DateTime(jsonParser.getText());            &#125;        &#125;);        module.addDeserializer(java.sql.Date.class, new JsonDeserializer&lt;java.sql.Date&gt;() &#123;            @Override            public java.sql.Date deserialize(JsonParser jsonParser, DeserializationContext deserializationContext) throws IOException &#123;                return StrUtil.isEmpty(jsonParser.getText()) ? null : new java.sql.Date(new DateTime(jsonParser.getText()).getTime());            &#125;        &#125;);        module.addDeserializer(Timestamp.class, new JsonDeserializer&lt;Timestamp&gt;() &#123;            @Override            public Timestamp deserialize(JsonParser jsonParser, DeserializationContext deserializationContext) throws IOException, JacksonException &#123;                return StrUtil.isEmpty(jsonParser.getText()) ? null : new Timestamp(new DateTime(jsonParser.getText()).getTime());            &#125;        &#125;);        module.addDeserializer(Time.class, new JsonDeserializer&lt;Time&gt;() &#123;            @Override            public Time deserialize(JsonParser jsonParser, DeserializationContext deserializationContext) throws IOException, JacksonException &#123;                return StrUtil.isEmpty(jsonParser.getText()) ? null : Time.valueOf(jsonParser.getText());            &#125;        &#125;);        // 添加默认处理        return module;    &#125;&#125;</code></pre><p>效果可以返回正确的数据</p><pre><code class="json">&#123;    &quot;name&quot;: &quot;test&quot;,    &quot;date&quot;: &quot;2024-07-05 08:24:36&quot;,    &quot;localDate&quot;: &quot;2024-07-05&quot;,    &quot;localDateTime&quot;: &quot;2024-07-05 16:24:36&quot;,    &quot;localTime&quot;: &quot;16:24:36&quot;,    &quot;sqlDate&quot;: &quot;2024-07-05 00:00:00&quot;,    &quot;sqlTime&quot;: &quot;16:24:36&quot;,    &quot;timestamp&quot;: &quot;2024-07-05 08:24:36&quot;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近在项目中遇到了时间序列化的问题，所以研究了一下 Jackson 的时间序列化&amp;#x2F;反序列化，这里做一个详细的总结。&lt;/p&gt;
&lt;h1</summary>
      
    
    
    
    <category term="后端" scheme="http://yelog.org/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="java" scheme="http://yelog.org/tags/java/"/>
    
    <category term="translation" scheme="http://yelog.org/tags/translation/"/>
    
  </entry>
  
  <entry>
    <title>2024年MacOS终端大比拼</title>
    <link href="http://yelog.org/2024/06/23/macos-terminal/"/>
    <id>http://yelog.org/2024/06/23/macos-terminal/</id>
    <published>2024-06-23T07:54:00.000Z</published>
    <updated>2024-09-30T03:54:09.844Z</updated>
    
    <content type="html"><![CDATA[<h2 id="最流行的终端"><a href="#最流行的终端" class="headerlink" title="最流行的终端"></a>最流行的终端</h2><h2 id="横评"><a href="#横评" class="headerlink" title="横评"></a>横评</h2><p>| capability | Kitty | Alacritty | WezTerm | iTerm2 | Native |<br>| —-       | —-  | —-      | —-    | —-   |        |<br>| key-bind   |       |           |         |        |        |</p><h2 id="log"><a href="#log" class="headerlink" title="log"></a>log</h2><h3 id="2024-06-27"><a href="#2024-06-27" class="headerlink" title="2024-06-27"></a>2024-06-27</h3><blockquote><p>放弃 <code>Kitty</code> -&gt; 转为 <code>WezTerm</code></p></blockquote><p><code>Kitty</code> 绑定 <code>cmd-shift-f</code> 在 tmux 下无法使用， 且没有 <code>vim-mode</code></p><h3 id="2024-06-26"><a href="#2024-06-26" class="headerlink" title="2024-06-26"></a>2024-06-26</h3><blockquote><p>放弃使用 <code>Alacritty</code> -&gt; 转为 <code>Kitty</code></p></blockquote><p>因为在 <code>vim</code> 的 <code>normal</code> 模式下, 如果是中文输入法, 输入的内容会出现在输入法的候选框内, 然后按 <code>&lt;CAPS&gt;</code> 按键切换输入法, 候选框中的输入的字母, 会以 insert 的方式输出到光标所在的位置, 这个问题在 <code>WezTerm</code> 和 <code>Kitty</code> 中没有出现.</p><blockquote><p>注意: <code>Kitty</code> 的 <code>map cmd+1 send_key cmd+1</code> 能够正常映射到 <code>NeoVim</code> 中进行 <code>maps.n[&quot;&lt;D-1&gt;&quot;] = &#123; &quot;&lt;cmd&gt;Neotree left toggle&lt;cr&gt;&quot;, desc = &quot;Toggle Explorer&quot; &#125;</code> 绑定, 但是开启 tmux 后, <code>cmd+1</code> 映射到 <code>NeoVim</code> 中就不行了</p></blockquote><h3 id="2024-06-20"><a href="#2024-06-20" class="headerlink" title="2024-06-20"></a>2024-06-20</h3><blockquote><p>放弃 <code>WezTerm</code> -&gt; 转为 <code>Alacritty</code></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;最流行的终端&quot;&gt;&lt;a href=&quot;#最流行的终端&quot; class=&quot;headerlink&quot; title=&quot;最流行的终端&quot;&gt;&lt;/a&gt;最流行的终端&lt;/h2&gt;&lt;h2 id=&quot;横评&quot;&gt;&lt;a href=&quot;#横评&quot; class=&quot;headerlink&quot; title=&quot;横评&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="工具" scheme="http://yelog.org/categories/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="软件记录" scheme="http://yelog.org/categories/%E5%B7%A5%E5%85%B7/%E8%BD%AF%E4%BB%B6%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="mac" scheme="http://yelog.org/tags/mac/"/>
    
    <category term="efficiency" scheme="http://yelog.org/tags/efficiency/"/>
    
    <category term="terminal" scheme="http://yelog.org/tags/terminal/"/>
    
  </entry>
  
  <entry>
    <title>离线安装Home Assistant</title>
    <link href="http://yelog.org/2024/03/22/home-assistant/"/>
    <id>http://yelog.org/2024/03/22/home-assistant/</id>
    <published>2024-03-22T01:05:44.000Z</published>
    <updated>2024-09-30T03:54:10.357Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近搬到了新家，家里的智能设备也越来越多, 引入很多米家设备, 但博主使用的是苹果生态, 需要将这些不支持 <code>homekit</code> 的米家设备接入到 <code>homekit</code> 中, 经过调研发现 <code>Home Assistant</code> 是一个不错的选择, 本文会介绍联网安装的过程, 并且如果有需要联网的步骤, 也会提供<strong>离线安装</strong>的方法.</p><p>本篇主要介绍通过 <code>docker</code> 部署的方式</p><h2 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h2><p>如已有 <code>docker</code> 环境, 可以跳过这一步</p><pre><code class="bash">sudo apt-get updatesudo </code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近搬到了新家，家里的智能设备也越来越多, 引入很多米家设备, 但博主使用的是苹果生态, 需要将这些不支持 &lt;code&gt;homekit&lt;/c</summary>
      
    
    
    
    <category term="工具" scheme="http://yelog.org/categories/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="IOT" scheme="http://yelog.org/categories/%E5%B7%A5%E5%85%B7/IOT/"/>
    
    
    <category term="home-assistant" scheme="http://yelog.org/tags/home-assistant/"/>
    
    <category term="iot" scheme="http://yelog.org/tags/iot/"/>
    
  </entry>
  
  <entry>
    <title>K8s-内部培训</title>
    <link href="http://yelog.org/2024/02/05/k8s-inner-training/"/>
    <id>http://yelog.org/2024/02/05/k8s-inner-training/</id>
    <published>2024-02-05T01:17:27.000Z</published>
    <updated>2024-09-30T03:54:09.310Z</updated>
    
    <content type="html"><![CDATA[<h1 id="K8s-内部培训"><a href="#K8s-内部培训" class="headerlink" title="K8s 内部培训"></a>K8s 内部培训</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>K8s 为 Kubernetes 的简称, 是一个开源的<strong>容器编排</strong>平台, 最初是由 Google 工程师开发和设计的, 后于 2015 年捐赠给了<a href="https://www.cncf.io/">云原生计算机基金会-CNCF</a></p><h3 id="应用服务管理发展史"><a href="#应用服务管理发展史" class="headerlink" title="应用服务管理发展史"></a>应用服务管理发展史</h3><p>早期服务应用大多以单包的形式运行在服务器上, 当我们增加一些服务时, 比如添加 <code>JOB</code> 应用时, 我们会另开一个新的应用, 但基本用一台服务器上就能完成</p><p>所以我们早期应用的发展就如下面图表所示, 由于用户数量较少, 所以更新应用时短暂的暂停服务也是可以接受的</p><div style="display: none">┌──────────────**石器时代**───────────────┐     ┌──────────────**石器时代**───────────────┐     ┌──────────────**石器时代**───────────────┐│ ┌─────────────`Server1`───────────────┐ │     │ ┌─────────────`Server1`───────────────┐ │     │ ┌─────────────`Server1`───────────────┐ ││ │             ┌──☕──┐                │ │     │ │        ┌──☕──┐   ┌──☕──┐          │ │     │ │ ┌──☕──┐     ┌──☕──┐     ┌──☕──┐  │ ││ │             │ APP1 │                │ │     │ │        │ APP1 │   │ APP2 │          │ │     │ │ │ APP1 │     │ APP2 │     │ APP3 │  │ ││ │             └──────┘                │ │ ==> │ │        └──────┘   └──────┘          │ │ ==> │ │ └──────┘     └──────┘     └──────┘  │ ││ ├─────────────────────────────────────┤ │     │ ├─────────────────────────────────────┤ │     │ ├─────────────────────────────────────┤ ││ │ 安装: JDK8, Tomcat, 需要手动启动服务│ │     │ │ 安装: JDK8, Tomcat, 需要手动启动服务│ │     │ │ 安装: JDK8, Tomcat, 需要手动启动服务│ ││ └─────────────────────────────────────┘ │     │ └─────────────────────────────────────┘ │     │ └─────────────────────────────────────┘ │└─────────────────────────────────────────┘     └─────────────────────────────────────────┘     └─────────────────────────────────────────┘</div><p><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/202402051408786.png"></p><p>随着用户数量的上升, 应用的并发也随之提高, 单台服务器的压力也随之增大, 有了如下情况:</p><ol><li>高峰期经常出现卡顿</li><li>更新应用时的暂停服务已经不可接受</li><li>在服务器出现故障时的高可用有了更高的要求</li></ol><p>为了解决上面的问题, 我们就进入了下个时代(下图一), 采购多台服务器, 对应用进行支持集群的改造, 这时我们的应用分别在三台服务器上, 并发能力提高了3倍, 并且冗灾能力大幅提升</p><p>尽管我们解决了上面的问题, 但是带来了新的问题, 因为服务器数量过多, 在安装应用需要的工具如 JDK、Tomcat、Node、Nginx、Redis 等等, 可能会因为安装版本和服务器系统版本不一致导致应用运行失败</p><p>所以会在环境安装中浪费太多时间, 所以很多企业开始引入如 <code>Docker</code> 的虚拟化技术(下图二), 用来解决环境不一致的问题, 并且一并解决了守护进程, 开机启动等问题</p><p>这时我们通过 <code>docker-compose</code> 技术, 升级应用、调整配置相比以前大大简化, 但是随着应用规模的扩大, 对应用高可用有了更高的要求, 纷纷开始进行微服务拆分, 应用数量和服务器数量越来越多, 服务的运维管理越来越复杂、</p><p>大家开始开发各种集群管理, 让大家可以在一个地方并且可视化的管理集群中的所有 <code>Docker</code>, 以 Google 开源的 Kubernetes 做的最功能完善且灵活可配置, 从而开始爆火.</p><p>于是众多企业开始上K8s(下图三), 不仅解决运维复杂的问题, 而且带来了更多更好的特性:</p><ol><li>服务发现和负载均衡</li><li>存储编排</li><li>自动部署和回滚</li><li>自我修复</li><li>密钥和配置管理</li></ol><div style="display: block">┌──────────────**农耕文明**───────────────┐     ┌─────────────────**工业文明**───────────────┐     ┌─────────────────**信息文明**───────────────┐│ ┌─────────────`Server1`───────────────┐ │     │ ┌────────────────`Server1`───────────────┐ │     │ ┌────────────────`K8s 集群`──────────────┐ ││ │ ┌──☕──┐     ┌──☕──┐     ┌──☕──┐  │ │     │ │ ┌─────🐳────┐┌─────🐳────┐┌─────🐳────┐│ │     │ │ ┌─────🐳────┐┌─────🐳────┐┌─────🐳────┐│ ││ │ │ APP1 │     │ APP2 │     │ APP3 │  │ │     │ │ │   APP1    ││   APP2    ││   APP3    ││ │     │ │ │   POD1    ││   POD2    ││   POD3    ││ ││ │ └──────┘     └──────┘     └──────┘  │ │     │ │ ├───────────┤├───────────┤├───────────┤│ │     │ │ ├───────────┤├───────────┤├───────────┤│ ││ ├─────────────────────────────────────┤ │     │ │ │JDK8/Tomcat││JDK8/Tomcat││JDK8/Tomcat││ │     │ │ │JDK8/Tomcat││JDK8/Tomcat││JDK8/Tomcat││ ││ │ 安装: JDK8, Tomcat, 需要手动启动服务│ │     │ │ └───────────┘└───────────┘└───────────┘│ │     │ │ └───────────┘└───────────┘└───────────┘│ ││ └─────────────────────────────────────┘ │     │ └────────────────────────────────────────┘ │     │ │ ┌─────🐳────┐┌─────🐳────┐┌─────🐳────┐│ ││ ┌─────────────`Server2`───────────────┐ │     │ ┌────────────────`Server1`───────────────┐ │     │ │ │   POD4    ││   POD5    ││   POD6    ││ ││ │ ┌──☕──┐     ┌──☕──┐     ┌──☕──┐  │ │     │ │ ┌─────🐳────┐┌─────🐳────┐┌─────🐳────┐│ │     │ │ ├───────────┤├───────────┤├───────────┤│ ││ │ │ APP1 │     │ APP2 │     │ APP3 │  │ │     │ │ │   APP1    ││   APP2    ││   APP3    ││ │     │ │ │JDK8/Tomcat││JDK8/Tomcat││JDK8/Tomcat││ ││ │ └──────┘     └──────┘     └──────┘  │ │ ==> │ │ ├───────────┤├───────────┤├───────────┤│ │ ==> │ │ └───────────┘└───────────┘└───────────┘│ ││ ├─────────────────────────────────────┤ │     │ │ │JDK8/Tomcat││JDK8/Tomcat││JDK8/Tomcat││ │     │ │ ┌─────🐳────┐┌─────🐳────┐┌─────🐳────┐│ ││ │ 安装: JDK8, Tomcat, 需要手动启动服务│ │     │ │ └───────────┘└───────────┘└───────────┘│ │     │ │ │   POD7    ││   POD8    ││   POD9    ││ ││ └─────────────────────────────────────┘ │     │ └────────────────────────────────────────┘ │     │ │ ├───────────┤├───────────┤├───────────┤│ ││ ┌─────────────`Server3`───────────────┐ │     │ ┌────────────────`Server1`───────────────┐ │     │ │ │JDK8/Tomcat││JDK8/Tomcat││JDK8/Tomcat││ ││ │ ┌──☕──┐     ┌──☕──┐     ┌──☕──┐  │ │     │ │ ┌─────🐳────┐┌─────🐳────┐┌─────🐳────┐│ │     │ │ └───────────┘└───────────┘└───────────┘│ ││ │ │ APP1 │     │ APP2 │     │ APP3 │  │ │     │ │ │   APP1    ││   APP2    ││   APP3    ││ │     │ ├────────────────────────────────────────┤ ││ │ └──────┘     └──────┘     └──────┘  │ │     │ │ ├───────────┤├───────────┤├───────────┤│ │     │ │  ┌───────┐ ┌───────┐ ┌───────┐         │ ││ ├─────────────────────────────────────┤ │     │ │ │JDK8/Tomcat││JDK8/Tomcat││JDK8/Tomcat││ │     │ │  │Server1│ │Server2│ │Server3│ •••     │ ││ │ 安装: JDK8, Tomcat, 需要手动启动服务│ │     │ │ └───────────┘└───────────┘└───────────┘│ │     │ │  └───────┘ └───────┘ └───────┘         │ ││ └─────────────────────────────────────┘ │     │ └────────────────────────────────────────┘ │     │ └────────────────────────────────────────┘ │├─────────────────────────────────────────┤     ├────────────────────────────────────────────┤     ├────────────────────────────────────────────┤│ 优点: 节省资源, 需要掌握的知识较少      │     │ 优点: 环境搭建容易, 安装Docker和配置文件   │     │ 优点: 自动故障恢复, 监控完善, 操作方便     ││ 缺点: 运维操作繁杂, JDK版本难以统一     │     │ 缺点: 随着规模扩大, 日常运维也变得繁杂     │     │ 缺点: k8s 功能较多, 需要掌握的知识也多     │└─────────────────────────────────────────┘     └────────────────────────────────────────────┘     └────────────────────────────────────────────┘                图一                                               图二                                                图三</div><p><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/202402051410212.png"></p><h3 id="Kubernetes-组件"><a href="#Kubernetes-组件" class="headerlink" title="Kubernetes 组件"></a>Kubernetes 组件</h3><p><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/202402051554610.png" alt="Kubernetes 各组件"></p><ul><li><code>Control Plane Components</code>: 控制平面组件<ul><li><code>kube-apiserver</code>: 负责公开 Kubernetes API, 处理请求, 类似 cloud 中的网关</li><li><code>etcd</code>: key-value 存储, 用于保存集群数据</li><li><code>kube-scheduler</code>: 任务调度, 监听有新创建但未运行的pods, 选择节点来让 pod 在上面运行</li><li><code>kube-controller-manager</code>: 负责运行控制器进程, 有如下不同类型的控制器<ul><li><code>Node Controller</code>: 节点控制器, 负责节点出现故障时进行通知和响应</li><li><code>Job Controller</code>: 任务控制器, 检测代表一次性任务的 Job 对象, 然后创建 Pod 来运行这些任务直至完成</li><li><code>EndpointSlice Controller</code>: 端点分片控制器, 提供 Service 和 Pod 之间的链接</li><li><code>ServiceAccount Controller</code>: 为新的命名空间创建默认的服务账号</li></ul></li><li><code>cloud-controller-manager</code>: 云控制管理器, 集成云提供商的API, 我们内网部署的用不到</li></ul></li><li><code>Node Components</code>: 节点组件, 运行在各个节点, 负责维护运行的 Pod, 提供 Kubernetes 的运行环境<ul><li><code>kubelet</code>: 在每个节点中运行, 保证容器都运行在 Pod 中, kubelet 接受一组 PodSpec, 确保 PodSpec 中描述的容器处于运行状态且健康</li><li><code>kube-proxy</code>: 网络代理, 是实现 Service 的一部分</li><li><code>Container Runtime</code>: 容器运行时, Kubernetes 支持需要容器运行环境, 例如: docker, containerd, CRI-O</li></ul></li><li><code>Addons</code>: 插件, 提供集群级别的功能, 插件提供的资源属于 kube-system 命名空间<ul><li><code>DNS</code>: 提供集群内的域名系统</li><li><code>Web UI/Dashboard</code>: 通用的基于 Web 的用户界面, 它使用户可以集中管理集群中的应用已经集群本身</li><li><code>Container Resource Monitoring</code>: 将容器的一些常见的时间序列度量值保存到一个集中的数据库中, 并提供浏览这些数据的界面</li><li><code>Cluster-level Logging</code>: 集群级日志, 将容器日志保存到一个集中的日志存储中, 这种集中日志存储提供搜索和浏览接口</li><li><code>Network Plugins</code>: 网络插件, 实现容器网络接口(CNI)规范的软件组件, 负责为 Pod 分配 IP 地址, 并使这些 Pod 能在集群内部互相通信</li></ul></li></ul><h3 id="Kubernetes-架构"><a href="#Kubernetes-架构" class="headerlink" title="Kubernetes 架构"></a>Kubernetes 架构</h3><p><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/202402051553913.png"></p><h4 id="Node-节点"><a href="#Node-节点" class="headerlink" title="Node 节点"></a>Node 节点</h4><p>Kubernetes 通过将容器放入在节点(Node) 上运行的 Pod 来执行你的负载. 节点可以是一个虚拟机或物理机, 每个节点包含 Pod 所需的服务器, 这些节点由 <code>Control Plane</code> 负责管理</p><p>一个集群的节点数量可以是1个, 也可以是多个. 且节点名称是唯一的.</p><p>可以通过 <code>kubectl</code> 来创建和修改 Node 对象</p><pre><code class="bash"># 查一下集群中的所有节点信息kubectl get node# 查看某个节点详细信息kubectl descibe $NODENAME# 标记一个 Node 为不可调度kubectl cordon $NODENAME</code></pre><h4 id="Controllers-控制器"><a href="#Controllers-控制器" class="headerlink" title="Controllers 控制器"></a>Controllers 控制器</h4><p>在机器人和自动化领域, 又一个类似的概念叫控制回路 (Control Loop), 用于调节系统状态, 如: 房间里的温度自动调节器</p><p>当你设置了温度, 温度自动调节器让其当前状态接近期望温度; 在 Kubernetes 中, 控制器通过监控集群的公共状态, <strong>并致力于将当前的状态转为期望状态</strong></p><p>控制器是通过通知 <code>apiserver</code> 来管理状态的, 就像温度自动调节器是通过控制空调来调节气温的</p><h4 id="Container-Runtime-Interface-CRI-容器运行时接口"><a href="#Container-Runtime-Interface-CRI-容器运行时接口" class="headerlink" title="Container Runtime Interface&#x2F;CRI 容器运行时接口"></a>Container Runtime Interface&#x2F;CRI 容器运行时接口</h4><p>CRI 是一个插件接口, 它使 kubelet 能够使用各种容器运行时, 定义了主要 gRPC 协议, 用于节点组件 kubelet 和容器运行时之间的通信</p><h3 id="Containers-容器"><a href="#Containers-容器" class="headerlink" title="Containers 容器"></a>Containers 容器</h3><p><strong>容器</strong>将应用从底层主机设备中解耦, 这使得在不同的云或 OS 环境中部署更加容易</p><p>Kubernetes 集群中的每个节点都会运行容器, 这些容器构成分配给该节点的 Pod, 单个 Pod 中的容器会在共同调度下, 运行在相同的节点</p><p><strong>容器镜像</strong>是一个随时可以运行的软件包, 它包含了运行容器程序所需要的一切, 代码和它需要的运行时、应用程序和系统库, 以及一些基本设置</p><p><strong>容器运行时</strong>这个基础组件使 Kubernetes 能够有效运行容器, 他负责管理 Kubernetes 环境中的容器的执行和生命周期</p><h3 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h3><p>Pod 是可以在 Kubernetes 中创建和管理的、最小的可部署计算单元</p><p>Pod 是有一个或多个容器组成, 这些容器共享存储、网络、已经怎么样运行这些容器的声明, 统一调度.</p><p>此外还可以包含 init container, 用于做一些启动主应用前的准备工作, 比如通过 init container 注入 tingyun 等 agent 包</p><p>如下示例, 它由一个运行镜像 <code>nginx:1.14.2</code> 的容器组成</p><pre><code class="yaml">apiVersion: v1kind: Podmetadata:  name: nginx  labels:    app: my-nginxspec:  containers:  - name: nginx    image: nginx:1.14.2    ports:    - containerPort: 80</code></pre><p>要创建上面显示的 Pod, 保存上面内容到 <code>my-nginx.yaml</code>, 可以通过如下命令</p><pre><code class="bash">kubectl apply -f my-nginx.yaml</code></pre><h3 id="Workloads-工作负载"><a href="#Workloads-工作负载" class="headerlink" title="Workloads 工作负载"></a>Workloads 工作负载</h3><p>工作负载是在 Kubernetes 上运行的应用程序, 无论是又一个还是多个组件构成, 你都可以通过一组 Pod 来运行它, Pod 代表的是集群上处于运行状态的一组容器的集合, 但通常一个 Pod 内只运行一个容器</p><p>Kubernetes 提供若干种内置的工作负载资源:</p><ul><li><code>Deployment</code> 和 <code>ReplicaSet</code> Deployment 适合无状态应用, Deployment 中的所有 Pod 都是互相等价的</li><li><code>StatefulSet</code> 有状态应用, 比如可以独立持久化文件, 互不影响</li><li><code>DaemonSet</code> 提供节点本地支撑设施的 Pod, 保证每个节点上一个</li><li><code>Job</code> 和 <code>CronJob</code> 定义只需要执行一次并且执行后视为完完成的任务</li></ul><h3 id="Network-网络"><a href="#Network-网络" class="headerlink" title="Network 网络"></a>Network 网络</h3><h4 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h4><p><code>Service</code> 是将一个或者一组 Pod 公开代理给集群内部, 使之能够各个应用之间通信, 甚至用于公开到集群外(NodePort 或者 代理给 Ingress)</p><p>它提供了类似域名的访问方式, 使用者无需关心后面有多少个 Pod 在提供服务, 他们是否健康, 他们 IP 是否发生变化.</p><p>定义 Service</p><pre><code class="yaml">apiVersion: v1kind: Servicemetadata:  name: nginx-servicespec:  selector:    app: my-nginx  ports:  - name: name-of-service-port    protocol: TCP    port: 80    targetPort: http-web-svc</code></pre><p>服务类型(type):</p><ul><li><code>ClusterIp</code>: 默认值, 智能在集群内访问</li><li><code>NodePort</code>: 直接向集群外暴露, 通过节点端口访问</li><li><code>LoadBalancer</code>: 使用云平台的负载均衡, Kubernetes 不直接提供</li><li><code>Externalname</code>: 将服务映射到 externalName 字段的内容, 例如<code>api.foo.bar.example</code></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;K8s-内部培训&quot;&gt;&lt;a href=&quot;#K8s-内部培训&quot; class=&quot;headerlink&quot; title=&quot;K8s 内部培训&quot;&gt;&lt;/a&gt;K8s 内部培训&lt;/h1&gt;&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="运维" scheme="http://yelog.org/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
    <category term="docker" scheme="http://yelog.org/tags/docker/"/>
    
    <category term="k8s" scheme="http://yelog.org/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>swift 离线图片识别文字(ocr)</title>
    <link href="http://yelog.org/2024/01/02/macos-ocr-swift/"/>
    <id>http://yelog.org/2024/01/02/macos-ocr-swift/</id>
    <published>2024-01-02T02:09:19.000Z</published>
    <updated>2024-09-30T03:54:10.447Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近打算写一个 macos 翻译软件, 需要用到 ocr 图像识别, 并且因为速度问题, 一开始就考虑使用系统的自带能力来实现.</p><p>经过翻阅文档和 chatgpt 拉扯了一下午, 最终成功实现.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>代码逻辑为, 接受参数: 图片路径, 然后获取图片, 通过 <code>VNImageRequestHandler</code> 对图片进行文字识别</p><p>如下代码可以直接放进一个 <code>ocr.swift</code>, 然后执行 <code>swiftc -o ocr ocr.swift</code> , 在执行 <code>./ocr /Users/yelog/Desktop/3.png</code> 后面为你实际的有文字的图片路经</p><pre><code class="swift">////  ocr.swift//  Fast Translation////  Created by 杨玉杰 on 2023/12/31.//import SwiftUIimport Visionfunc handleDetectedText(request: VNRequest?, error: Error?) &#123;    if let error = error &#123;        print(&quot;ERROR: \(error)&quot;)        return    &#125;    guard let results = request?.results, results.count &gt; 0 else &#123;        print(&quot;No text found&quot;)        return    &#125;    for result in results &#123;        if let observation = result as? VNRecognizedTextObservation &#123;            for text in observation.topCandidates(1) &#123;                let string = text.string                print(&quot;识别: \(string)&quot;)            &#125;        &#125;    &#125;&#125;func ocrImage(path: String) &#123;    let cgImage = NSImage(byReferencingFile: path)?.ciImage()?.cgImage    let requestHandler = VNImageRequestHandler(cgImage: cgImage!)    let request = VNRecognizeTextRequest(completionHandler: handleDetectedText)    // 设置文本识别的语言为英文    request.recognitionLanguages = [&quot;en&quot;]    request.recognitionLevel = .accurate    do &#123;        try requestHandler.perform([request])    &#125; catch &#123;        print(&quot;Unable to perform the requests: \(error).&quot;)    &#125;&#125;extension NSImage &#123;    func ciImage() -&gt; CIImage? &#123;        guard let data = self.tiffRepresentation,              let bitmap = NSBitmapImageRep(data: data) else &#123;            return nil        &#125;        let ci = CIImage(bitmapImageRep: bitmap)        return ci    &#125;&#125;// 执行函数，从命令行参数中获取图片的地址ocrImage(path: CommandLine.arguments[1])</code></pre><p>然后准备待识别的有文字的图片</p><p><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/202401021353013.png" alt="待识别的图片"> </p><pre><code class="bash"># 编译 swift 文件swiftc -o ocr ocr.swift# 执行并且传递图片路径参数./ocr /Users/yelog/Desktop/3.png</code></pre><p><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/202401021354591.png" alt="执行识别效果"></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>最近打算着手写一些 macos 的小工具, 如果对 <code>swift</code> 或者 <code>macos</code> 感兴趣的可以关注或评论.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近打算写一个 macos 翻译软件, 需要用到 ocr 图像识别, 并且因为速度问题, 一开始就考虑使用系统的自带能力来实现.&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="开发" scheme="http://yelog.org/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="swift" scheme="http://yelog.org/categories/%E5%BC%80%E5%8F%91/swift/"/>
    
    
    <category term="swift" scheme="http://yelog.org/tags/swift/"/>
    
    <category term="macos" scheme="http://yelog.org/tags/macos/"/>
    
    <category term="ocr" scheme="http://yelog.org/tags/ocr/"/>
    
  </entry>
  
  <entry>
    <title>Caused by: java.lang.ClassNotFoundException: org.springframework.boot.loader.JarLauncher</title>
    <link href="http://yelog.org/2023/12/11/springboot-jarlauncher/"/>
    <id>http://yelog.org/2023/12/11/springboot-jarlauncher/</id>
    <published>2023-12-11T08:58:00.000Z</published>
    <updated>2024-09-30T03:54:10.256Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h2><p>今天同事再升级框架后(spring-cloud 2022.0.4 -&gt; 2023.0.0)(spring-boot 3.1.6 -&gt; 3.2.0)</p><p>同时因为 spring-boot 的版本问题, 需要将 maven 升级到 3.6.3+</p><p><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/202312111837604.png" alt="maven version"></p><p>升级后构建 jar 包和构建镜像都是正常的, 但是发布到测试环境就报错 <code>Caused by: java.lang.ClassNotFoundException: org.springframework.boot.loader.JarLauncher</code></p><p><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/202312111851862.png" alt="error log"></p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>报错为 JarLauncher 找不到, 检查了 <code>Jenkins</code> 中的打包任务, 发现并没有编译报错, 同事直接使用打包任务中产生的 xx.jar, 可以正常运行.</p><p>说明在打包 <code>Docker</code> 镜像前都没有问题, 这时就想起来我们在打包镜像时, 先解压 xx.jar, 然后直接执行 <code>org.springframework.boot.loader.JarLauncher</code>, 所以很可能是升级后, 启动文件 <code>JarLauncher</code> 的路径变了.</p><p>为了验证我们的猜想, 我们得看一下实际容器内的文件结构, 但是这时容器一直报错导致无法启动, 不能直接通过 <code>Rancher</code> 查看文件结构, 我们可以通过文件拷贝的方式来解决, 如下:</p><pre><code class="bash"># 下载有问题的镜像, 并且创建容器(不启动)docker create -it --name dumy 10.188.132.123:5000/lemes-cloud/lemes-gateway:develop-202312111536 bash# 直接拷贝容器内的我们想要看的目录docker cp dumy:/data .</code></pre><p>到本地后, 就可以通过合适的工具查找 <code>JarLauncher</code> 文件, 我这里通过 <code>vim</code> 来寻找, 如下图:</p><p><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/202312111902709.png" alt="JarLauncher Path"></p><p>发现比原来多了一层目录 <code>launch</code>, 所以问题就发生在这里了.</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>我们在打包脚本 <code>JenkinsCommon.groovy</code> 中根据当前打包的 JDK 版本来判断使用的启动类路径, 如下:</p><p><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/202312111905161.png" alt="Jenkins"></p><p>再次打包, 应用正常启动.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://docs.spring.io/spring-boot/docs/2.5.15/api/org/springframework/boot/loader/JarLauncher.html">JarLauncher</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题现象&quot;&gt;&lt;a href=&quot;#问题现象&quot; class=&quot;headerlink&quot; title=&quot;问题现象&quot;&gt;&lt;/a&gt;问题现象&lt;/h2&gt;&lt;p&gt;今天同事再升级框架后(spring-cloud 2022.0.4 -&amp;gt; 2023.0.0)(spring-boot 3</summary>
      
    
    
    
    <category term="后端" scheme="http://yelog.org/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="java" scheme="http://yelog.org/tags/java/"/>
    
    <category term="docker" scheme="http://yelog.org/tags/docker/"/>
    
    <category term="spring-boot" scheme="http://yelog.org/tags/spring-boot/"/>
    
  </entry>
  
  <entry>
    <title>ideavim 使用百分号%支持xml的对应标签跳转</title>
    <link href="http://yelog.org/2023/06/17/idea-tips-percent-mach-xml/"/>
    <id>http://yelog.org/2023/06/17/idea-tips-percent-mach-xml/</id>
    <published>2023-06-17T08:09:00.000Z</published>
    <updated>2024-09-30T03:54:10.027Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于最近几年使用 vim 的频率越来越高, 所以在 idea 中也大量开始使用 vim 技巧, 在一年多前碰到个问题, 终于在最近解决了。</p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在 idea 中, 在 normal 模式下, 使用 % 不能在匹配标签(xml&#x2F;html等) 之间跳转</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>在 <code>~/.ideavimrc</code> 中添加如下设置, 重启 idea 即可</p><pre><code class="bash">set matchit</code></pre><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/picgo_qiniu2023-06-17%2016.23.45.gif"></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>最近会把一些加的 tips 分享出来，大家有什么建议和问题都可以在评论区讨论.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;由于最近几年使用 vim 的频率越来越高, 所以在 idea 中也大量开始使用 vim 技巧, 在一年多前碰到个问题, 终于在最近解决了。&lt;</summary>
      
    
    
    
    <category term="工具" scheme="http://yelog.org/categories/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="IDEA" scheme="http://yelog.org/categories/%E5%B7%A5%E5%85%B7/IDEA/"/>
    
    
    <category term="efficiency" scheme="http://yelog.org/tags/efficiency/"/>
    
    <category term="vim" scheme="http://yelog.org/tags/vim/"/>
    
    <category term="IntellijIDEA" scheme="http://yelog.org/tags/IntellijIDEA/"/>
    
  </entry>
  
  <entry>
    <title>Raycast 最强效率软件推荐</title>
    <link href="http://yelog.org/2023/05/17/mac-raycast/"/>
    <id>http://yelog.org/2023/05/17/mac-raycast/</id>
    <published>2023-05-17T09:45:00.000Z</published>
    <updated>2024-09-30T03:54:09.827Z</updated>
    
    <content type="html"><![CDATA[<h2 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h2><p><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/picgo_qiniu202305171806865.png" alt="Raycast"></p><p>最近在很多平台上看到 Raycast 的推荐文章, 今天就尝试了一下, 发现确实不错, 完全可以替代我目前对 Alfred 的使用, 甚至很多地方做得更好, 所以本文就是介绍我使用 Raycast 的一些效果(多图预警)， 方便那些还没有接触这个软件的人对它有个了解, 如果有插件推荐, 欢迎在评论区进行讨论。</p><p>Raycast 是 MacMac 平台独占的效率工具, 主要包含如下功能:</p><ol><li>应用启动</li><li>文件查找</li><li>窗口管理</li><li>剪贴板历史</li><li>Snippets</li><li>应用菜单查询</li></ol><p>插件扩展功能</p><ol><li>翻译</li><li>斗图</li><li>结束进程</li><li>查询端口占用</li><li>查询ip</li></ol><p>除此之外, Raycast提供的在线插件商店, 可以很方便的进行功能扩展</p><p><a href="https://www.raycast.com/">Raycast官网</a></p><h2 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h2><h3 id="应用启动"><a href="#应用启动" class="headerlink" title="应用启动"></a>应用启动</h3><p><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/picgo_qiniu202305172245860.png"></p><p>并且支持卸载应用, 找到应用, <code>cmd+k</code> 打开操作菜单, 下拉到最后<br><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/picgo_qiniu202305181223320.png"></p><h3 id="文件查找"><a href="#文件查找" class="headerlink" title="文件查找"></a>文件查找</h3><p><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/picgo_qiniu202305172249647.png"></p><h3 id="窗口管理"><a href="#窗口管理" class="headerlink" title="窗口管理"></a>窗口管理</h3><p><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/picgo_qiniu202305172251703.png"></p><h3 id="剪贴板历史"><a href="#剪贴板历史" class="headerlink" title="剪贴板历史"></a>剪贴板历史</h3><p>推荐使用 <code>Clipboard History</code> 这个扩展，和 Alfred 的一样, 并且有分类，效果如下<br><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/picgo_qiniu202305181002644.png"></p><p>设置快捷键 <code>cmd+shift+v</code><br><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/picgo_qiniu202305181052831.png"></p><h3 id="Snippets"><a href="#Snippets" class="headerlink" title="Snippets"></a>Snippets</h3><p>通过 Snippets 可以保存自定义片段, 通过关键字快速查询并输出到光标处, 如常用语、 邮箱、手机号、税号、代码片段等等<br><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/picgo_qiniu202305181108693.png"></p><p>创建 Snippets 可以通过搜索 <code>Create Snippet</code>, 搜索 Snippets 可以通过搜索<code>Search Snippet</code></p><h3 id="应用菜单查询"><a href="#应用菜单查询" class="headerlink" title="应用菜单查询"></a>应用菜单查询</h3><p>查询当前激活应用的所有菜单, 不限层级. 可以通过搜索 <code>Search Menu Items</code> 来查询。<br><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/picgo_qiniu202305181231629.png"></p><h2 id="推荐插件"><a href="#推荐插件" class="headerlink" title="推荐插件"></a>推荐插件</h2><h3 id="Easydict-翻译软件"><a href="#Easydict-翻译软件" class="headerlink" title="Easydict(翻译软件)"></a>Easydict(翻译软件)</h3><p>超强的翻译软件， 完美替代我在 Alfred 的 workflow 中配置的有道翻译, 我配置了如下功能</p><ul><li>输入中文, 自动翻译成英文</li><li>输入英文, 自动翻译成中文</li><li>支持一键发音</li><li>Open AI 翻译长文本</li></ul><p><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/picgo_qiniu202305172258408.png"></p><h3 id="Doutu"><a href="#Doutu" class="headerlink" title="Doutu"></a>Doutu</h3><p>表情包查询，选中回车就复制到剪贴板了， 就可以粘贴到 Discord&#x2F;QQ&#x2F;Wechat 斗图了, 非常方便。</p><p><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/picgo_qiniu202305172300474.png"></p><h3 id="Kill-Process"><a href="#Kill-Process" class="headerlink" title="Kill Process"></a>Kill Process</h3><p>关键字查询, 并一键结束进程<br><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/picgo_qiniu202305181119726.png"></p><h3 id="Kill-Port"><a href="#Kill-Port" class="headerlink" title="Kill Port"></a>Kill Port</h3><p>查询端口占用的进程, 并支持一键结束进程<br><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/picgo_qiniu202305181120514.png"></p><h3 id="MyIp"><a href="#MyIp" class="headerlink" title="MyIp"></a>MyIp</h3><p>查询当前ip<br><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/picgo_qiniu202305181230312.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;软件介绍&quot;&gt;&lt;a href=&quot;#软件介绍&quot; class=&quot;headerlink&quot; title=&quot;软件介绍&quot;&gt;&lt;/a&gt;软件介绍&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/yelog/assets/images/picg</summary>
      
    
    
    
    <category term="工具" scheme="http://yelog.org/categories/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="软件记录" scheme="http://yelog.org/categories/%E5%B7%A5%E5%85%B7/%E8%BD%AF%E4%BB%B6%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="mac" scheme="http://yelog.org/tags/mac/"/>
    
    <category term="efficiency" scheme="http://yelog.org/tags/efficiency/"/>
    
  </entry>
  
  <entry>
    <title>[Java]通过 CompletableFuture 实现异步多线程优化请求处理速度</title>
    <link href="http://yelog.org/2022/08/01/[Java]optimize-request-processing-speed-by-completablefuture/"/>
    <id>http://yelog.org/2022/08/01/[Java]optimize-request-processing-speed-by-completablefuture/</id>
    <published>2022-08-01T12:06:14.000Z</published>
    <updated>2024-09-30T03:54:10.339Z</updated>
    
    <content type="html"><![CDATA[<h3 id="零、背景"><a href="#零、背景" class="headerlink" title="零、背景"></a>零、背景</h3><p>我们在写后端请求的时候, 可能涉及多次 SQL 执行(或其他操作), 当这些请求相互不关联, 在顺序执行时就浪费了时间, 这些不需要先后顺序的操作可以通过多线程进行同时执行, 来加速整个逻辑的执行速度.</p><p>既然有了目标和大致思路, 如果有做过前端的小伙伴应该能想起来 Js 里面有个 <code>Promise.all</code> 来解决这个问题, 在 Java 里也有类似功能的类 <code>CompletableFuture</code> , 它可以实现多线程和线程阻塞, 这样能够保证等待多个线程执行完成后再继续操作.</p><h3 id="一、CompletableFuture-是什么"><a href="#一、CompletableFuture-是什么" class="headerlink" title="一、CompletableFuture 是什么"></a>一、CompletableFuture 是什么</h3><p>首先我们先了解一下 <code>CompletableFuture</code> 是干什么, 接下来我们通过简单的示例来介绍他的作用.</p><pre><code class="java"> long startTime = System.currentTimeMillis();//生成几个任务List&lt;CompletableFuture&lt;String&gt;&gt; futureList = new ArrayList&lt;&gt;();futureList.add(CompletableFuture.supplyAsync(()-&gt;&#123;    sleep(4000);    System.out.println(&quot;任务1 完成&quot;);    return &quot;任务1的数据&quot;;&#125;));futureList.add(CompletableFuture.supplyAsync(()-&gt;&#123;    sleep(2000);    System.out.println(&quot;任务2 完成&quot;);    return &quot;任务2的数据&quot;;&#125;));futureList.add(CompletableFuture.supplyAsync(()-&gt;&#123;    sleep(3000);    System.out.println(&quot;任务3 完成&quot;);    return &quot;任务3的数据&quot;;&#125;));//完成任务CompletableFuture&lt;Void&gt; allTask = CompletableFuture.allOf(futureList.toArray(new CompletableFuture[0]))        .whenComplete((t, e) -&gt; &#123;            System.out.println(&quot;所有任务都完成了， 返回结果集: &quot;                    + futureList.stream().map(CompletableFuture::join).collect(Collectors.joining(&quot;,&quot;)));        &#125;);// 阻塞主线程allTask.join();System.out.println(&quot;main end, cost: &quot; + (System.currentTimeMillis() - startTime));</code></pre><p>执行结果</p><pre><code class="bash">任务2 完成任务3 完成任务1 完成所有任务都完成了， 返回结果集: 任务1的数据,任务2的数据,任务3的数据main end, cost: 4032</code></pre><blockquote><p><strong>结果分析:</strong> 我们需要执行3个任务, 3个任务同时执行, 互不影响</p></blockquote><ol><li>其中任务2耗时最短,提前打印完成</li><li>其次是任务3</li><li>最后是执行1完成</li><li>当所有任务完成后, 触发 <code>whenComplete</code> 方法, 打印任务的返回结果</li><li>最后打印总耗时为 4.032s</li><li>结论: 多线程执行后, 耗时取决于最耗时的操作, 而单线程是所有操作耗时之和</li></ol><h3 id="二、封装工具类"><a href="#二、封装工具类" class="headerlink" title="二、封装工具类"></a>二、封装工具类</h3><p>经过上面的测试, 通过 <code>CompletableFuture</code> 已经能够实现我们的预想, 为了操作方便, 我们将封装起来, 便于统一管理</p><pre><code class="java">package org.yelog.java.usage.concurrent;import java.util.ArrayList;import java.util.List;import java.util.concurrent.CompletableFuture;import java.util.function.Consumer;import java.util.function.Function;import java.util.function.Predicate;/** * 执行并发任务 * * @author yangyj13 * @date 11/7/22 9:49 PM */public class MultiTask&lt;T&gt; &#123;    private List&lt;CompletableFuture&lt;T&gt;&gt; futureList;    /**     * 添加待执行的任务     *     * @param completableFuture 任务     * @return 当前对象     */    public MultiTask&lt;T&gt; addTask(CompletableFuture&lt;T&gt; completableFuture) &#123;        if (futureList == null) &#123;            futureList = new ArrayList&lt;&gt;();        &#125;        futureList.add(completableFuture);        return this;    &#125;    /**     * 添加待执行的任务(无返回)     *     * @param task 任务     * @return 当前对象     */    public MultiTask&lt;T&gt; addTask(Consumer&lt;T&gt; task) &#123;        addTask(CompletableFuture.supplyAsync(() -&gt; &#123;            task.accept(null);            return null;        &#125;));        return this;    &#125;    /**     * 添加待执行的任务(有返回)     *     * @param task 任务     * @return 当前对象     */    public MultiTask&lt;T&gt; addTask(Function&lt;Object, T&gt; task) &#123;        addTask(CompletableFuture.supplyAsync(() -&gt; task.apply(null)));        return this;    &#125;    /**     * 开始执行任务     *     * @param callback                当所有任务都完成后触发的回调方法     * @param waitTaskExecuteComplete 是否阻塞主线程     */    private void execute(Consumer&lt;List&lt;T&gt;&gt; callback, Boolean waitTaskExecuteComplete) &#123;        CompletableFuture&lt;Void&gt; allFuture = CompletableFuture.allOf(futureList.toArray(new CompletableFuture[0]))                .whenComplete((t, e) -&gt; &#123;                    if (callback != null) &#123;                        List&lt;T&gt; objectList = new ArrayList&lt;&gt;();                        futureList.forEach((future) -&gt; &#123;                            objectList.add(future.join());                        &#125;);                        callback.accept(objectList);                    &#125;                &#125;);        if (callback != null || waitTaskExecuteComplete == null || waitTaskExecuteComplete) &#123;            allFuture.join();        &#125;    &#125;    /**     * 开始执行任务     * 等待所有任务完成（阻塞主线程）     */    public void execute() &#123;        execute(null, true);    &#125;    /**     * 开始执行任务     *     * @param waitTaskExecuteComplete 是否阻塞主线程     */    public void execute(Boolean waitTaskExecuteComplete) &#123;        execute(null, waitTaskExecuteComplete);    &#125;    /**     * 开始执行任务     *     * @param callback 当所有任务都完成后触发的回调方法     */    public void execute(Consumer&lt;List&lt;T&gt;&gt; callback) &#123;        execute(callback, true);    &#125;&#125;</code></pre><p>那么上一步我们测试的流程转换成工具类后如下</p><pre><code class="java">long startTime = System.currentTimeMillis();MultiTask&lt;String&gt; multiTask = new MultiTask&lt;&gt;();multiTask.addTask(t -&gt; &#123;    sleep(1000);    System.out.println(&quot;任务1 完成&quot;);&#125;).addTask(t -&gt; &#123;    sleep(3000);    System.out.println(&quot;任务2 完成&quot;);&#125;).addTask(CompletableFuture.supplyAsync(()-&gt;&#123;    sleep(2000);    System.out.println(&quot;任务3 完成&quot;);    return &quot;任务3的数据&quot;;&#125;)).execute(resultList-&gt;&#123;    System.out.println(&quot;all complete: &quot; + resultList);&#125;);System.out.println(&quot;main end, cost: &quot; + (System.currentTimeMillis() - startTime));</code></pre><h3 id="三、应用到实际的效果"><a href="#三、应用到实际的效果" class="headerlink" title="三、应用到实际的效果"></a>三、应用到实际的效果</h3><p>执行两次数据库的操作如下</p><pre><code class="java">public interface TestMapper &#123;    @Select(&quot;select count(*) from test_user where score &lt; 1000 and user_id = #&#123;userId&#125;&quot;)    int countScoreLess1000(Integer userId);    @Select(&quot;select count(1) from test_log where success = true and user_id = #&#123;userId&#125;&quot;)    int countSuccess(Integer userId);&#125;</code></pre><p>调用方法:</p><pre><code class="java">long start = System.currentTimeMillis();testMapper.countScoreLess1000(userId);long countScoreLess1000End = System.currentTimeMillis();log.info(&quot;countScoreLess1000 cost: &quot; + (countScoreLess1000End - start));testMapper.countSuccess(userId);long countSuccessEnd = System.currentTimeMillis();log.info(&quot;countSuccess cost: &quot; + (countSuccessEnd - countScoreLess1000End));log.info(&quot;all cost: &quot; + (countSuccessEnd - start));</code></pre><p>顺序执行的平均时间如下</p><pre><code class="bash">countScoreLess1000 cost: 368countSuccess cost: 404all cost: 772</code></pre><p>当我们应用的上面的工具类后的调用方法</p><pre><code class="java">MultiTask multiTask = new MultiTask&lt;&gt;();multiTask.addTask(t -&gt; &#123;    testMapper.countScoreLess1000(userId);    log.info(&quot;countScoreLess1000 cost: &quot; + (System.currentTimeMillis() - start));&#125;).addTask(t -&gt; &#123;    testMapper.countSuccess(userId);    log.info(&quot;countSuccess cost: &quot; + (System.currentTimeMillis() - start));&#125;).execute();log.info(&quot;all cost: &quot; + (System.currentTimeMillis() - start));</code></pre><p>效果如下</p><pre><code class="bash">countScoreLess1000 cost: 433countSuccess cost: 463all cost: 464</code></pre><p>可以看到各子任务执行时长是差不多的, 但是总耗时使用多线程后有了明显下降</p><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>通过使用 <code>CompletableFuture</code> 实现多线程阻塞执行后, 大幅降低这类请求, 并且当可以异步执行的子任务越多, 效果越明显.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;零、背景&quot;&gt;&lt;a href=&quot;#零、背景&quot; class=&quot;headerlink&quot; title=&quot;零、背景&quot;&gt;&lt;/a&gt;零、背景&lt;/h3&gt;&lt;p&gt;我们在写后端请求的时候, 可能涉及多次 SQL 执行(或其他操作), 当这些请求相互不关联, 在顺序执行时就浪费了时间, 这</summary>
      
    
    
    
    <category term="后端" scheme="http://yelog.org/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="java" scheme="http://yelog.org/tags/java/"/>
    
    <category term="concurrent" scheme="http://yelog.org/tags/concurrent/"/>
    
  </entry>
  
</feed>
