<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>叶落阁</title>
  
  
  <link href="http://yelog.org/atom.xml" rel="self"/>
  
  <link href="http://yelog.org/"/>
  <updated>2024-08-12T09:33:11.729Z</updated>
  <id>http://yelog.org/</id>
  
  <author>
    <name>叶落阁</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>用 vim 写 markdown 是一种什么样的体验(含技巧)</title>
    <link href="http://yelog.org/2024/08/02/vim-write-markdown-experience-and-tips/"/>
    <id>http://yelog.org/2024/08/02/vim-write-markdown-experience-and-tips/</id>
    <published>2024-08-02T07:10:59.000Z</published>
    <updated>2024-08-12T09:33:11.729Z</updated>
    
    
    
    
    <category term="工具" scheme="http://yelog.org/categories/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="vim" scheme="http://yelog.org/categories/%E5%B7%A5%E5%85%B7/vim/"/>
    
    
    <category term="vim" scheme="http://yelog.org/tags/vim/"/>
    
    <category term="neovim" scheme="http://yelog.org/tags/neovim/"/>
    
    <category term="markdown" scheme="http://yelog.org/tags/markdown/"/>
    
    <category term="editor" scheme="http://yelog.org/tags/editor/"/>
    
  </entry>
  
  <entry>
    <title>Jackson 时间序列化/反序列化详解</title>
    <link href="http://yelog.org/2024/07/05/Jackson%20Time%20Serializer/Deserializer/"/>
    <id>http://yelog.org/2024/07/05/Jackson%20Time%20Serializer/Deserializer/</id>
    <published>2024-07-05T08:00:00.000Z</published>
    <updated>2024-08-12T09:33:12.215Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在项目中遇到了时间序列化的问题，所以研究了一下 Jackson 的时间序列化&#x2F;反序列化，这里做一个详细的总结。</p><h1 id="0-准备工作"><a href="#0-准备工作" class="headerlink" title="0. 准备工作"></a>0. 准备工作</h1><p>准备实体类 User.java</p><pre><code class="java">package com.example.testjava.entity;import lombok.Builder;import lombok.Data;import java.time.LocalDate;import java.time.LocalDateTime;import java.time.LocalTime;import java.util.Date;@Builder@Datapublic class User &#123;    private String name;    private Date date;    private LocalDate localDate;    private LocalDateTime localDateTime;    private LocalTime localTime;    private java.sql.Date sqlDate;    private java.sql.Time sqlTime;    private java.sql.Timestamp timestamp;&#125;</code></pre><p>简单查询</p><pre><code class="java">package com.example.testjava.controller;import com.example.testjava.entity.User;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.Date;@RestController@RequestMapping(&quot;/jackson&quot;)public class JacksonTestController &#123;    @GetMapping(&quot;/query&quot;)    public User testJavaDate() &#123;        return User.builder()                .name(&quot;test&quot;)                .date(new Date())                .localDate(java.time.LocalDate.now())                .localDateTime(java.time.LocalDateTime.now())                .localTime(java.time.LocalTime.now())                .sqlDate(new java.sql.Date(System.currentTimeMillis()))                .sqlTime(new java.sql.Time(System.currentTimeMillis()))                .timestamp(new java.sql.Timestamp(System.currentTimeMillis()))                .build();    &#125;&#125;</code></pre><h1 id="1-序列化"><a href="#1-序列化" class="headerlink" title="1. 序列化"></a>1. 序列化</h1><h2 id="1-1-默认返回"><a href="#1-1-默认返回" class="headerlink" title="1.1. 默认返回"></a>1.1. 默认返回</h2><pre><code class="json">&#123;    &quot;name&quot;: &quot;test&quot;,    &quot;date&quot;: &quot;2024-07-05T08:09:47.100+00:00&quot;,    &quot;localDate&quot;: &quot;2024-07-05&quot;,    &quot;localDateTime&quot;: &quot;2024-07-05T16:09:47.100462&quot;,    &quot;localTime&quot;: &quot;16:09:47.100514&quot;,    &quot;sqlDate&quot;: &quot;2024-07-05&quot;,    &quot;sqlTime&quot;: &quot;16:09:47&quot;,    &quot;timestamp&quot;: &quot;2024-07-05T08:09:47.100+00:00&quot;&#125;</code></pre><h1 id="1-2-添加配置"><a href="#1-2-添加配置" class="headerlink" title="1.2. 添加配置"></a>1.2. 添加配置</h1><p>配置如下</p><pre><code class="yaml">spring:  jackson:    date-format: yyyy-MM-dd HH:mm:ss</code></pre><p>返回效果</p><pre><code class="json">&#123;    &quot;name&quot;: &quot;test&quot;,    &quot;date&quot;: &quot;2024-07-05 08:16:07&quot;,    &quot;localDate&quot;: &quot;2024-07-05&quot;,    &quot;localDateTime&quot;: &quot;2024-07-05T16:16:07.097035&quot;,    &quot;localTime&quot;: &quot;16:16:07.09705&quot;,    &quot;sqlDate&quot;: &quot;2024-07-05&quot;,    &quot;sqlTime&quot;: &quot;16:16:07&quot;,    &quot;timestamp&quot;: &quot;2024-07-05 08:16:07&quot;&#125;</code></pre><p>可以发现, 日期时间类型中, 只有 <code>java.time.LocalDateTime</code> 没有按照配置序列化, <code>java.util.Date</code> 和 <code>java.sql.Timestamp</code> 按照配置序列化了。</p><h1 id="1-3-添加注解"><a href="#1-3-添加注解" class="headerlink" title="1.3. 添加注解"></a>1.3. 添加注解</h1><pre><code class="java">package com.example.testjava.entity;import com.fasterxml.jackson.annotation.JsonFormat;import lombok.Builder;import lombok.Data;import java.time.LocalDate;import java.time.LocalDateTime;import java.time.LocalTime;import java.util.Date;@Builder@Datapublic class User &#123;    private String name;    @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)    private Date date;    private LocalDate localDate;    @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)    private LocalDateTime localDateTime;    @JsonFormat(pattern = &quot;HH:mm:ss&quot;)    private LocalTime localTime;    private java.sql.Date sqlDate;    private java.sql.Time sqlTime;    @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)    private java.sql.Timestamp timestamp;&#125;</code></pre><p>返回效果</p><pre><code class="json">&#123;    &quot;name&quot;: &quot;test&quot;,    &quot;date&quot;: &quot;2024-07-05 08:24:36&quot;,    &quot;localDate&quot;: &quot;2024-07-05&quot;,    &quot;localDateTime&quot;: &quot;2024-07-05 16:24:36&quot;,    &quot;localTime&quot;: &quot;16:24:36&quot;,    &quot;sqlDate&quot;: &quot;2024-07-05&quot;,    &quot;sqlTime&quot;: &quot;16:24:36&quot;,    &quot;timestamp&quot;: &quot;2024-07-05 08:24:36&quot;&#125;</code></pre><p>注解是可以都有效的</p><h1 id="2-反序列化"><a href="#2-反序列化" class="headerlink" title="2. 反序列化"></a>2. 反序列化</h1><p>准备请求</p><pre><code class="java">    @PostMapping(&quot;/save&quot;)    public User save(@RequestBody User user) &#123;        return user;    &#125;</code></pre><p>请求参数</p><pre><code class="json">&#123;    &quot;name&quot;: &quot;test&quot;,    &quot;date&quot;: &quot;2024-07-05 08:24:36&quot;,    &quot;localDate&quot;: &quot;2024-07-05&quot;,    &quot;localDateTime&quot;: &quot;2024-07-05 16:24:36&quot;,    &quot;localTime&quot;: &quot;16:24:36&quot;,    &quot;sqlDate&quot;: &quot;2024-07-05&quot;,    &quot;sqlTime&quot;: &quot;16:24:36&quot;,    &quot;timestamp&quot;: &quot;2024-07-05 08:24:36&quot;&#125;</code></pre><h2 id="2-1-默认效果"><a href="#2-1-默认效果" class="headerlink" title="2.1 默认效果"></a>2.1 默认效果</h2><p>默认报错</p><pre><code class="text">JSON parse error: Cannot deserialize value of type `java.util.Date` from String \&quot;2024-07-05 08:24:36\&quot;</code></pre><h2 id="2-2-添加配置"><a href="#2-2-添加配置" class="headerlink" title="2.2 添加配置"></a>2.2 添加配置</h2><p>有两种方法可以解决, 一个是自定义时间序列化, 一个是自定义 objectMapper</p><h3 id="2-2-1-自定义时间序列化"><a href="#2-2-1-自定义时间序列化" class="headerlink" title="2.2.1 自定义时间序列化"></a>2.2.1 自定义时间序列化</h3><pre><code class="java">/** * 此转换方法试用于 json 请求 * LocalDateTime 时间格式转换 支持 */@JsonComponent@Configurationpublic class LocalDateTimeFormatConfiguration extends JsonDeserializer&lt;LocalDateTime&gt; &#123;    @Value(&quot;$&#123;spring.jackson.date-format:yyyy-MM-dd HH:mm:ss&#125;&quot;)    private String pattern;    /**     * LocalDate 类型全局时间格式化     * @return     */    @Bean    public LocalDateTimeSerializer localDateTimeDeserializer() &#123;        return new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(pattern));    &#125;    @Bean    public Jackson2ObjectMapperBuilderCustomizer jackson2ObjectMapperBuilderCustomizer() &#123;        return builder -&gt; builder.serializerByType(LocalDateTime.class, localDateTimeDeserializer());    &#125;    @Override    public LocalDateTime deserialize(JsonParser jsonParser, DeserializationContext deserializationContext) throws IOException, JsonProcessingException &#123;        return StrUtil.isEmpty(jsonParser.getText()) ? null : LocalDateTimeUtil.of(new DateTime(jsonParser.getText()));    &#125;&#125;</code></pre><pre><code class="java">@JsonComponent@Configurationpublic class DateFormatConfiguration extends JsonDeserializer&lt;Date&gt; &#123;    @Value(&quot;$&#123;spring.jackson.date-format:yyyy-MM-dd HH:mm:ss&#125;&quot;)    private String pattern;    /**     * date 类型全局时间格式化     *     * @return     */    @Bean    public Jackson2ObjectMapperBuilderCustomizer jackson2ObjectMapperBuilder() &#123;        return builder -&gt; &#123;            TimeZone tz = TimeZone.getTimeZone(&quot;UTC&quot;);            DateFormat df = new SimpleDateFormat(pattern);            df.setTimeZone(tz);            builder.failOnEmptyBeans(false)                    .failOnUnknownProperties(false)                    .featuresToDisable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)                    .dateFormat(df);        &#125;;    &#125;    @Override    public Date deserialize(JsonParser jsonParser, DeserializationContext deserializationContext) throws IOException, JsonProcessingException &#123;        return StrUtil.isEmpty(jsonParser.getText()) ? null : new DateTime(jsonParser.getText());    &#125;&#125;</code></pre><h3 id="2-2-2-自定义-objectMapper"><a href="#2-2-2-自定义-objectMapper" class="headerlink" title="2.2.2 自定义 objectMapper"></a>2.2.2 自定义 objectMapper</h3><pre><code class="java">package com.example.testjava.config;import cn.hutool.core.date.DatePattern;import cn.hutool.core.date.DateTime;import cn.hutool.core.date.LocalDateTimeUtil;import cn.hutool.core.util.StrUtil;import com.fasterxml.jackson.core.JacksonException;import com.fasterxml.jackson.core.JsonGenerator;import com.fasterxml.jackson.core.JsonParser;import com.fasterxml.jackson.databind.Module;import com.fasterxml.jackson.databind.*;import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateDeserializer;import com.fasterxml.jackson.datatype.jsr310.deser.LocalTimeDeserializer;import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateSerializer;import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateTimeSerializer;import com.fasterxml.jackson.datatype.jsr310.ser.LocalTimeSerializer;import org.springframework.beans.factory.annotation.Value;import org.springframework.boot.autoconfigure.AutoConfigureBefore;import org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import java.io.IOException;import java.sql.Time;import java.sql.Timestamp;import java.text.SimpleDateFormat;import java.time.LocalDate;import java.time.LocalDateTime;import java.time.LocalTime;import java.time.format.DateTimeFormatter;import java.util.Date;@Configuration@AutoConfigureBefore(JacksonAutoConfiguration.class)public class JacksonConfig &#123;    @Value(&quot;$&#123;spring.jackson.date-format:yyyy-MM-dd HH:mm:ss&#125;&quot;)    private String pattern;    @Bean    public ObjectMapper objectMapper() &#123;        ObjectMapper objectMapper = new ObjectMapper();        // 在反序列化时, 如果对象没有对应的字段, 不抛出异常        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);        objectMapper.registerModule(javaTimeModule());        objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);        return objectMapper;    &#125;    private Module javaTimeModule() &#123;        JavaTimeModule module = new JavaTimeModule();        // 序列化        module.addSerializer(new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(pattern)));        module.addSerializer(new LocalTimeSerializer(DateTimeFormatter.ofPattern(DatePattern.NORM_TIME_PATTERN)));        module.addSerializer(new LocalDateSerializer(DateTimeFormatter.ofPattern(DatePattern.NORM_DATE_PATTERN)));        module.addSerializer(Date.class, new JsonSerializer&lt;&gt;() &#123;            @Override            public void serialize(Date date, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException &#123;                SimpleDateFormat sdf = new SimpleDateFormat(pattern);                jsonGenerator.writeString(sdf.format(date));            &#125;        &#125;);        module.addSerializer(java.sql.Date.class, new JsonSerializer&lt;&gt;() &#123;            @Override            public void serialize(java.sql.Date date, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException &#123;                SimpleDateFormat sdf = new SimpleDateFormat(pattern);                jsonGenerator.writeString(sdf.format(date));            &#125;        &#125;);        module.addSerializer(Timestamp.class, new JsonSerializer&lt;&gt;() &#123;            @Override            public void serialize(Timestamp timestamp, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException &#123;                SimpleDateFormat sdf = new SimpleDateFormat(pattern);                jsonGenerator.writeString(sdf.format(timestamp));            &#125;        &#125;);        module.addSerializer(Time.class, new JsonSerializer&lt;&gt;() &#123;            @Override            public void serialize(Time time, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException &#123;                SimpleDateFormat sdf = new SimpleDateFormat(DatePattern.NORM_TIME_PATTERN);                jsonGenerator.writeString(sdf.format(time));            &#125;        &#125;);        // 反序列化        module.addDeserializer(LocalDateTime.class, new JsonDeserializer&lt;LocalDateTime&gt;() &#123;            @Override            public LocalDateTime deserialize(JsonParser jsonParser, DeserializationContext deserializationContext) throws IOException, JacksonException &#123;                return StrUtil.isEmpty(jsonParser.getText()) ? null : LocalDateTimeUtil.of(new DateTime(jsonParser.getText()));            &#125;        &#125;);        module.addDeserializer(LocalDate.class, new LocalDateDeserializer(DateTimeFormatter.ofPattern(DatePattern.NORM_DATE_PATTERN)));        module.addDeserializer(LocalTime.class, new LocalTimeDeserializer(DateTimeFormatter.ofPattern(DatePattern.NORM_TIME_PATTERN)));        module.addDeserializer(Date.class, new JsonDeserializer&lt;Date&gt;() &#123;            @Override            public Date deserialize(JsonParser jsonParser, DeserializationContext deserializationContext) throws IOException &#123;                return StrUtil.isEmpty(jsonParser.getText()) ? null : new DateTime(jsonParser.getText());            &#125;        &#125;);        module.addDeserializer(java.sql.Date.class, new JsonDeserializer&lt;java.sql.Date&gt;() &#123;            @Override            public java.sql.Date deserialize(JsonParser jsonParser, DeserializationContext deserializationContext) throws IOException &#123;                return StrUtil.isEmpty(jsonParser.getText()) ? null : new java.sql.Date(new DateTime(jsonParser.getText()).getTime());            &#125;        &#125;);        module.addDeserializer(Timestamp.class, new JsonDeserializer&lt;Timestamp&gt;() &#123;            @Override            public Timestamp deserialize(JsonParser jsonParser, DeserializationContext deserializationContext) throws IOException, JacksonException &#123;                return StrUtil.isEmpty(jsonParser.getText()) ? null : new Timestamp(new DateTime(jsonParser.getText()).getTime());            &#125;        &#125;);        module.addDeserializer(Time.class, new JsonDeserializer&lt;Time&gt;() &#123;            @Override            public Time deserialize(JsonParser jsonParser, DeserializationContext deserializationContext) throws IOException, JacksonException &#123;                return StrUtil.isEmpty(jsonParser.getText()) ? null : Time.valueOf(jsonParser.getText());            &#125;        &#125;);        // 添加默认处理        return module;    &#125;&#125;</code></pre><p>效果可以返回正确的数据</p><pre><code class="json">&#123;    &quot;name&quot;: &quot;test&quot;,    &quot;date&quot;: &quot;2024-07-05 08:24:36&quot;,    &quot;localDate&quot;: &quot;2024-07-05&quot;,    &quot;localDateTime&quot;: &quot;2024-07-05 16:24:36&quot;,    &quot;localTime&quot;: &quot;16:24:36&quot;,    &quot;sqlDate&quot;: &quot;2024-07-05 00:00:00&quot;,    &quot;sqlTime&quot;: &quot;16:24:36&quot;,    &quot;timestamp&quot;: &quot;2024-07-05 08:24:36&quot;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近在项目中遇到了时间序列化的问题，所以研究了一下 Jackson 的时间序列化&amp;#x2F;反序列化，这里做一个详细的总结。&lt;/p&gt;
&lt;h1</summary>
      
    
    
    
    <category term="后端" scheme="http://yelog.org/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="java" scheme="http://yelog.org/tags/java/"/>
    
    <category term="translation" scheme="http://yelog.org/tags/translation/"/>
    
  </entry>
  
  <entry>
    <title>2024年MacOS终端大比拼</title>
    <link href="http://yelog.org/2024/06/23/macos-terminal/"/>
    <id>http://yelog.org/2024/06/23/macos-terminal/</id>
    <published>2024-06-23T07:54:00.000Z</published>
    <updated>2024-08-12T09:33:11.893Z</updated>
    
    <content type="html"><![CDATA[<h2 id="最流行的终端"><a href="#最流行的终端" class="headerlink" title="最流行的终端"></a>最流行的终端</h2><h2 id="横评"><a href="#横评" class="headerlink" title="横评"></a>横评</h2><p>| capability | Kitty | Alacritty | WezTerm | iTerm2 | Native |<br>| —-       | —-  | —-      | —-    | —-   |        |<br>| key-bind   |       |           |         |        |        |</p><h2 id="log"><a href="#log" class="headerlink" title="log"></a>log</h2><h3 id="2024-06-27"><a href="#2024-06-27" class="headerlink" title="2024-06-27"></a>2024-06-27</h3><blockquote><p>放弃 <code>Kitty</code> -&gt; 转为 <code>WezTerm</code></p></blockquote><p><code>Kitty</code> 绑定 <code>cmd-shift-f</code> 在 tmux 下无法使用， 且没有 <code>vim-mode</code></p><h3 id="2024-06-26"><a href="#2024-06-26" class="headerlink" title="2024-06-26"></a>2024-06-26</h3><blockquote><p>放弃使用 <code>Alacritty</code> -&gt; 转为 <code>Kitty</code></p></blockquote><p>因为在 <code>vim</code> 的 <code>normal</code> 模式下, 如果是中文输入法, 输入的内容会出现在输入法的候选框内, 然后按 <code>&lt;CAPS&gt;</code> 按键切换输入法, 候选框中的输入的字母, 会以 insert 的方式输出到光标所在的位置, 这个问题在 <code>WezTerm</code> 和 <code>Kitty</code> 中没有出现.</p><blockquote><p>注意: <code>Kitty</code> 的 <code>map cmd+1 send_key cmd+1</code> 能够正常映射到 <code>NeoVim</code> 中进行 <code>maps.n[&quot;&lt;D-1&gt;&quot;] = &#123; &quot;&lt;cmd&gt;Neotree left toggle&lt;cr&gt;&quot;, desc = &quot;Toggle Explorer&quot; &#125;</code> 绑定, 但是开启 tmux 后, <code>cmd+1</code> 映射到 <code>NeoVim</code> 中就不行了</p></blockquote><h3 id="2024-06-20"><a href="#2024-06-20" class="headerlink" title="2024-06-20"></a>2024-06-20</h3><blockquote><p>放弃 <code>WezTerm</code> -&gt; 转为 <code>Alacritty</code></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;最流行的终端&quot;&gt;&lt;a href=&quot;#最流行的终端&quot; class=&quot;headerlink&quot; title=&quot;最流行的终端&quot;&gt;&lt;/a&gt;最流行的终端&lt;/h2&gt;&lt;h2 id=&quot;横评&quot;&gt;&lt;a href=&quot;#横评&quot; class=&quot;headerlink&quot; title=&quot;横评&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="工具" scheme="http://yelog.org/categories/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="软件记录" scheme="http://yelog.org/categories/%E5%B7%A5%E5%85%B7/%E8%BD%AF%E4%BB%B6%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="mac" scheme="http://yelog.org/tags/mac/"/>
    
    <category term="efficiency" scheme="http://yelog.org/tags/efficiency/"/>
    
    <category term="terminal" scheme="http://yelog.org/tags/terminal/"/>
    
  </entry>
  
  <entry>
    <title>离线安装Home Assistant</title>
    <link href="http://yelog.org/2024/03/22/home-assistant/"/>
    <id>http://yelog.org/2024/03/22/home-assistant/</id>
    <published>2024-03-22T01:05:44.000Z</published>
    <updated>2024-08-12T09:33:12.274Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近搬到了新家，家里的智能设备也越来越多, 引入很多米家设备, 但博主使用的是苹果生态, 需要将这些不支持 <code>homekit</code> 的米家设备接入到 <code>homekit</code> 中, 经过调研发现 <code>Home Assistant</code> 是一个不错的选择, 本文会介绍联网安装的过程, 并且如果有需要联网的步骤, 也会提供<strong>离线安装</strong>的方法.</p><p>本篇主要介绍通过 <code>docker</code> 部署的方式</p><h2 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h2><p>如已有 <code>docker</code> 环境, 可以跳过这一步</p><pre><code class="bash">sudo apt-get updatesudo </code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近搬到了新家，家里的智能设备也越来越多, 引入很多米家设备, 但博主使用的是苹果生态, 需要将这些不支持 &lt;code&gt;homekit&lt;/c</summary>
      
    
    
    
    <category term="工具" scheme="http://yelog.org/categories/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="IOT" scheme="http://yelog.org/categories/%E5%B7%A5%E5%85%B7/IOT/"/>
    
    
    <category term="home-assistant" scheme="http://yelog.org/tags/home-assistant/"/>
    
    <category term="iot" scheme="http://yelog.org/tags/iot/"/>
    
  </entry>
  
  <entry>
    <title>K8s-内部培训</title>
    <link href="http://yelog.org/2024/02/05/k8s-inner-training/"/>
    <id>http://yelog.org/2024/02/05/k8s-inner-training/</id>
    <published>2024-02-05T01:17:27.000Z</published>
    <updated>2024-08-12T09:33:11.385Z</updated>
    
    <content type="html"><![CDATA[<h1 id="K8s-内部培训"><a href="#K8s-内部培训" class="headerlink" title="K8s 内部培训"></a>K8s 内部培训</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>K8s 为 Kubernetes 的简称, 是一个开源的<strong>容器编排</strong>平台, 最初是由 Google 工程师开发和设计的, 后于 2015 年捐赠给了<a href="https://www.cncf.io/">云原生计算机基金会-CNCF</a></p><h3 id="应用服务管理发展史"><a href="#应用服务管理发展史" class="headerlink" title="应用服务管理发展史"></a>应用服务管理发展史</h3><p>早期服务应用大多以单包的形式运行在服务器上, 当我们增加一些服务时, 比如添加 <code>JOB</code> 应用时, 我们会另开一个新的应用, 但基本用一台服务器上就能完成</p><p>所以我们早期应用的发展就如下面图表所示, 由于用户数量较少, 所以更新应用时短暂的暂停服务也是可以接受的</p><div style="display: none">┌──────────────**石器时代**───────────────┐     ┌──────────────**石器时代**───────────────┐     ┌──────────────**石器时代**───────────────┐│ ┌─────────────`Server1`───────────────┐ │     │ ┌─────────────`Server1`───────────────┐ │     │ ┌─────────────`Server1`───────────────┐ ││ │             ┌──☕──┐                │ │     │ │        ┌──☕──┐   ┌──☕──┐          │ │     │ │ ┌──☕──┐     ┌──☕──┐     ┌──☕──┐  │ ││ │             │ APP1 │                │ │     │ │        │ APP1 │   │ APP2 │          │ │     │ │ │ APP1 │     │ APP2 │     │ APP3 │  │ ││ │             └──────┘                │ │ ==> │ │        └──────┘   └──────┘          │ │ ==> │ │ └──────┘     └──────┘     └──────┘  │ ││ ├─────────────────────────────────────┤ │     │ ├─────────────────────────────────────┤ │     │ ├─────────────────────────────────────┤ ││ │ 安装: JDK8, Tomcat, 需要手动启动服务│ │     │ │ 安装: JDK8, Tomcat, 需要手动启动服务│ │     │ │ 安装: JDK8, Tomcat, 需要手动启动服务│ ││ └─────────────────────────────────────┘ │     │ └─────────────────────────────────────┘ │     │ └─────────────────────────────────────┘ │└─────────────────────────────────────────┘     └─────────────────────────────────────────┘     └─────────────────────────────────────────┘</div><p><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/202402051408786.png"></p><p>随着用户数量的上升, 应用的并发也随之提高, 单台服务器的压力也随之增大, 有了如下情况:</p><ol><li>高峰期经常出现卡顿</li><li>更新应用时的暂停服务已经不可接受</li><li>在服务器出现故障时的高可用有了更高的要求</li></ol><p>为了解决上面的问题, 我们就进入了下个时代(下图一), 采购多台服务器, 对应用进行支持集群的改造, 这时我们的应用分别在三台服务器上, 并发能力提高了3倍, 并且冗灾能力大幅提升</p><p>尽管我们解决了上面的问题, 但是带来了新的问题, 因为服务器数量过多, 在安装应用需要的工具如 JDK、Tomcat、Node、Nginx、Redis 等等, 可能会因为安装版本和服务器系统版本不一致导致应用运行失败</p><p>所以会在环境安装中浪费太多时间, 所以很多企业开始引入如 <code>Docker</code> 的虚拟化技术(下图二), 用来解决环境不一致的问题, 并且一并解决了守护进程, 开机启动等问题</p><p>这时我们通过 <code>docker-compose</code> 技术, 升级应用、调整配置相比以前大大简化, 但是随着应用规模的扩大, 对应用高可用有了更高的要求, 纷纷开始进行微服务拆分, 应用数量和服务器数量越来越多, 服务的运维管理越来越复杂、</p><p>大家开始开发各种集群管理, 让大家可以在一个地方并且可视化的管理集群中的所有 <code>Docker</code>, 以 Google 开源的 Kubernetes 做的最功能完善且灵活可配置, 从而开始爆火.</p><p>于是众多企业开始上K8s(下图三), 不仅解决运维复杂的问题, 而且带来了更多更好的特性:</p><ol><li>服务发现和负载均衡</li><li>存储编排</li><li>自动部署和回滚</li><li>自我修复</li><li>密钥和配置管理</li></ol><div style="display: block">┌──────────────**农耕文明**───────────────┐     ┌─────────────────**工业文明**───────────────┐     ┌─────────────────**信息文明**───────────────┐│ ┌─────────────`Server1`───────────────┐ │     │ ┌────────────────`Server1`───────────────┐ │     │ ┌────────────────`K8s 集群`──────────────┐ ││ │ ┌──☕──┐     ┌──☕──┐     ┌──☕──┐  │ │     │ │ ┌─────🐳────┐┌─────🐳────┐┌─────🐳────┐│ │     │ │ ┌─────🐳────┐┌─────🐳────┐┌─────🐳────┐│ ││ │ │ APP1 │     │ APP2 │     │ APP3 │  │ │     │ │ │   APP1    ││   APP2    ││   APP3    ││ │     │ │ │   POD1    ││   POD2    ││   POD3    ││ ││ │ └──────┘     └──────┘     └──────┘  │ │     │ │ ├───────────┤├───────────┤├───────────┤│ │     │ │ ├───────────┤├───────────┤├───────────┤│ ││ ├─────────────────────────────────────┤ │     │ │ │JDK8/Tomcat││JDK8/Tomcat││JDK8/Tomcat││ │     │ │ │JDK8/Tomcat││JDK8/Tomcat││JDK8/Tomcat││ ││ │ 安装: JDK8, Tomcat, 需要手动启动服务│ │     │ │ └───────────┘└───────────┘└───────────┘│ │     │ │ └───────────┘└───────────┘└───────────┘│ ││ └─────────────────────────────────────┘ │     │ └────────────────────────────────────────┘ │     │ │ ┌─────🐳────┐┌─────🐳────┐┌─────🐳────┐│ ││ ┌─────────────`Server2`───────────────┐ │     │ ┌────────────────`Server1`───────────────┐ │     │ │ │   POD4    ││   POD5    ││   POD6    ││ ││ │ ┌──☕──┐     ┌──☕──┐     ┌──☕──┐  │ │     │ │ ┌─────🐳────┐┌─────🐳────┐┌─────🐳────┐│ │     │ │ ├───────────┤├───────────┤├───────────┤│ ││ │ │ APP1 │     │ APP2 │     │ APP3 │  │ │     │ │ │   APP1    ││   APP2    ││   APP3    ││ │     │ │ │JDK8/Tomcat││JDK8/Tomcat││JDK8/Tomcat││ ││ │ └──────┘     └──────┘     └──────┘  │ │ ==> │ │ ├───────────┤├───────────┤├───────────┤│ │ ==> │ │ └───────────┘└───────────┘└───────────┘│ ││ ├─────────────────────────────────────┤ │     │ │ │JDK8/Tomcat││JDK8/Tomcat││JDK8/Tomcat││ │     │ │ ┌─────🐳────┐┌─────🐳────┐┌─────🐳────┐│ ││ │ 安装: JDK8, Tomcat, 需要手动启动服务│ │     │ │ └───────────┘└───────────┘└───────────┘│ │     │ │ │   POD7    ││   POD8    ││   POD9    ││ ││ └─────────────────────────────────────┘ │     │ └────────────────────────────────────────┘ │     │ │ ├───────────┤├───────────┤├───────────┤│ ││ ┌─────────────`Server3`───────────────┐ │     │ ┌────────────────`Server1`───────────────┐ │     │ │ │JDK8/Tomcat││JDK8/Tomcat││JDK8/Tomcat││ ││ │ ┌──☕──┐     ┌──☕──┐     ┌──☕──┐  │ │     │ │ ┌─────🐳────┐┌─────🐳────┐┌─────🐳────┐│ │     │ │ └───────────┘└───────────┘└───────────┘│ ││ │ │ APP1 │     │ APP2 │     │ APP3 │  │ │     │ │ │   APP1    ││   APP2    ││   APP3    ││ │     │ ├────────────────────────────────────────┤ ││ │ └──────┘     └──────┘     └──────┘  │ │     │ │ ├───────────┤├───────────┤├───────────┤│ │     │ │  ┌───────┐ ┌───────┐ ┌───────┐         │ ││ ├─────────────────────────────────────┤ │     │ │ │JDK8/Tomcat││JDK8/Tomcat││JDK8/Tomcat││ │     │ │  │Server1│ │Server2│ │Server3│ •••     │ ││ │ 安装: JDK8, Tomcat, 需要手动启动服务│ │     │ │ └───────────┘└───────────┘└───────────┘│ │     │ │  └───────┘ └───────┘ └───────┘         │ ││ └─────────────────────────────────────┘ │     │ └────────────────────────────────────────┘ │     │ └────────────────────────────────────────┘ │├─────────────────────────────────────────┤     ├────────────────────────────────────────────┤     ├────────────────────────────────────────────┤│ 优点: 节省资源, 需要掌握的知识较少      │     │ 优点: 环境搭建容易, 安装Docker和配置文件   │     │ 优点: 自动故障恢复, 监控完善, 操作方便     ││ 缺点: 运维操作繁杂, JDK版本难以统一     │     │ 缺点: 随着规模扩大, 日常运维也变得繁杂     │     │ 缺点: k8s 功能较多, 需要掌握的知识也多     │└─────────────────────────────────────────┘     └────────────────────────────────────────────┘     └────────────────────────────────────────────┘                图一                                               图二                                                图三</div><p><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/202402051410212.png"></p><h3 id="Kubernetes-组件"><a href="#Kubernetes-组件" class="headerlink" title="Kubernetes 组件"></a>Kubernetes 组件</h3><p><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/202402051554610.png" alt="Kubernetes 各组件"></p><ul><li><code>Control Plane Components</code>: 控制平面组件<ul><li><code>kube-apiserver</code>: 负责公开 Kubernetes API, 处理请求, 类似 cloud 中的网关</li><li><code>etcd</code>: key-value 存储, 用于保存集群数据</li><li><code>kube-scheduler</code>: 任务调度, 监听有新创建但未运行的pods, 选择节点来让 pod 在上面运行</li><li><code>kube-controller-manager</code>: 负责运行控制器进程, 有如下不同类型的控制器<ul><li><code>Node Controller</code>: 节点控制器, 负责节点出现故障时进行通知和响应</li><li><code>Job Controller</code>: 任务控制器, 检测代表一次性任务的 Job 对象, 然后创建 Pod 来运行这些任务直至完成</li><li><code>EndpointSlice Controller</code>: 端点分片控制器, 提供 Service 和 Pod 之间的链接</li><li><code>ServiceAccount Controller</code>: 为新的命名空间创建默认的服务账号</li></ul></li><li><code>cloud-controller-manager</code>: 云控制管理器, 集成云提供商的API, 我们内网部署的用不到</li></ul></li><li><code>Node Components</code>: 节点组件, 运行在各个节点, 负责维护运行的 Pod, 提供 Kubernetes 的运行环境<ul><li><code>kubelet</code>: 在每个节点中运行, 保证容器都运行在 Pod 中, kubelet 接受一组 PodSpec, 确保 PodSpec 中描述的容器处于运行状态且健康</li><li><code>kube-proxy</code>: 网络代理, 是实现 Service 的一部分</li><li><code>Container Runtime</code>: 容器运行时, Kubernetes 支持需要容器运行环境, 例如: docker, containerd, CRI-O</li></ul></li><li><code>Addons</code>: 插件, 提供集群级别的功能, 插件提供的资源属于 kube-system 命名空间<ul><li><code>DNS</code>: 提供集群内的域名系统</li><li><code>Web UI/Dashboard</code>: 通用的基于 Web 的用户界面, 它使用户可以集中管理集群中的应用已经集群本身</li><li><code>Container Resource Monitoring</code>: 将容器的一些常见的时间序列度量值保存到一个集中的数据库中, 并提供浏览这些数据的界面</li><li><code>Cluster-level Logging</code>: 集群级日志, 将容器日志保存到一个集中的日志存储中, 这种集中日志存储提供搜索和浏览接口</li><li><code>Network Plugins</code>: 网络插件, 实现容器网络接口(CNI)规范的软件组件, 负责为 Pod 分配 IP 地址, 并使这些 Pod 能在集群内部互相通信</li></ul></li></ul><h3 id="Kubernetes-架构"><a href="#Kubernetes-架构" class="headerlink" title="Kubernetes 架构"></a>Kubernetes 架构</h3><p><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/202402051553913.png"></p><h4 id="Node-节点"><a href="#Node-节点" class="headerlink" title="Node 节点"></a>Node 节点</h4><p>Kubernetes 通过将容器放入在节点(Node) 上运行的 Pod 来执行你的负载. 节点可以是一个虚拟机或物理机, 每个节点包含 Pod 所需的服务器, 这些节点由 <code>Control Plane</code> 负责管理</p><p>一个集群的节点数量可以是1个, 也可以是多个. 且节点名称是唯一的.</p><p>可以通过 <code>kubectl</code> 来创建和修改 Node 对象</p><pre><code class="bash"># 查一下集群中的所有节点信息kubectl get node# 查看某个节点详细信息kubectl descibe $NODENAME# 标记一个 Node 为不可调度kubectl cordon $NODENAME</code></pre><h4 id="Controllers-控制器"><a href="#Controllers-控制器" class="headerlink" title="Controllers 控制器"></a>Controllers 控制器</h4><p>在机器人和自动化领域, 又一个类似的概念叫控制回路 (Control Loop), 用于调节系统状态, 如: 房间里的温度自动调节器</p><p>当你设置了温度, 温度自动调节器让其当前状态接近期望温度; 在 Kubernetes 中, 控制器通过监控集群的公共状态, <strong>并致力于将当前的状态转为期望状态</strong></p><p>控制器是通过通知 <code>apiserver</code> 来管理状态的, 就像温度自动调节器是通过控制空调来调节气温的</p><h4 id="Container-Runtime-Interface-CRI-容器运行时接口"><a href="#Container-Runtime-Interface-CRI-容器运行时接口" class="headerlink" title="Container Runtime Interface&#x2F;CRI 容器运行时接口"></a>Container Runtime Interface&#x2F;CRI 容器运行时接口</h4><p>CRI 是一个插件接口, 它使 kubelet 能够使用各种容器运行时, 定义了主要 gRPC 协议, 用于节点组件 kubelet 和容器运行时之间的通信</p><h3 id="Containers-容器"><a href="#Containers-容器" class="headerlink" title="Containers 容器"></a>Containers 容器</h3><p><strong>容器</strong>将应用从底层主机设备中解耦, 这使得在不同的云或 OS 环境中部署更加容易</p><p>Kubernetes 集群中的每个节点都会运行容器, 这些容器构成分配给该节点的 Pod, 单个 Pod 中的容器会在共同调度下, 运行在相同的节点</p><p><strong>容器镜像</strong>是一个随时可以运行的软件包, 它包含了运行容器程序所需要的一切, 代码和它需要的运行时、应用程序和系统库, 以及一些基本设置</p><p><strong>容器运行时</strong>这个基础组件使 Kubernetes 能够有效运行容器, 他负责管理 Kubernetes 环境中的容器的执行和生命周期</p><h3 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h3><p>Pod 是可以在 Kubernetes 中创建和管理的、最小的可部署计算单元</p><p>Pod 是有一个或多个容器组成, 这些容器共享存储、网络、已经怎么样运行这些容器的声明, 统一调度.</p><p>此外还可以包含 init container, 用于做一些启动主应用前的准备工作, 比如通过 init container 注入 tingyun 等 agent 包</p><p>如下示例, 它由一个运行镜像 <code>nginx:1.14.2</code> 的容器组成</p><pre><code class="yaml">apiVersion: v1kind: Podmetadata:  name: nginx  labels:    app: my-nginxspec:  containers:  - name: nginx    image: nginx:1.14.2    ports:    - containerPort: 80</code></pre><p>要创建上面显示的 Pod, 保存上面内容到 <code>my-nginx.yaml</code>, 可以通过如下命令</p><pre><code class="bash">kubectl apply -f my-nginx.yaml</code></pre><h3 id="Workloads-工作负载"><a href="#Workloads-工作负载" class="headerlink" title="Workloads 工作负载"></a>Workloads 工作负载</h3><p>工作负载是在 Kubernetes 上运行的应用程序, 无论是又一个还是多个组件构成, 你都可以通过一组 Pod 来运行它, Pod 代表的是集群上处于运行状态的一组容器的集合, 但通常一个 Pod 内只运行一个容器</p><p>Kubernetes 提供若干种内置的工作负载资源:</p><ul><li><code>Deployment</code> 和 <code>ReplicaSet</code> Deployment 适合无状态应用, Deployment 中的所有 Pod 都是互相等价的</li><li><code>StatefulSet</code> 有状态应用, 比如可以独立持久化文件, 互不影响</li><li><code>DaemonSet</code> 提供节点本地支撑设施的 Pod, 保证每个节点上一个</li><li><code>Job</code> 和 <code>CronJob</code> 定义只需要执行一次并且执行后视为完完成的任务</li></ul><h3 id="Network-网络"><a href="#Network-网络" class="headerlink" title="Network 网络"></a>Network 网络</h3><h4 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h4><p><code>Service</code> 是将一个或者一组 Pod 公开代理给集群内部, 使之能够各个应用之间通信, 甚至用于公开到集群外(NodePort 或者 代理给 Ingress)</p><p>它提供了类似域名的访问方式, 使用者无需关心后面有多少个 Pod 在提供服务, 他们是否健康, 他们 IP 是否发生变化.</p><p>定义 Service</p><pre><code class="yaml">apiVersion: v1kind: Servicemetadata:  name: nginx-servicespec:  selector:    app: my-nginx  ports:  - name: name-of-service-port    protocol: TCP    port: 80    targetPort: http-web-svc</code></pre><p>服务类型(type):</p><ul><li><code>ClusterIp</code>: 默认值, 智能在集群内访问</li><li><code>NodePort</code>: 直接向集群外暴露, 通过节点端口访问</li><li><code>LoadBalancer</code>: 使用云平台的负载均衡, Kubernetes 不直接提供</li><li><code>Externalname</code>: 将服务映射到 externalName 字段的内容, 例如<code>api.foo.bar.example</code></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;K8s-内部培训&quot;&gt;&lt;a href=&quot;#K8s-内部培训&quot; class=&quot;headerlink&quot; title=&quot;K8s 内部培训&quot;&gt;&lt;/a&gt;K8s 内部培训&lt;/h1&gt;&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="运维" scheme="http://yelog.org/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
    <category term="docker" scheme="http://yelog.org/tags/docker/"/>
    
    <category term="k8s" scheme="http://yelog.org/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>swift 离线图片识别文字(ocr)</title>
    <link href="http://yelog.org/2024/01/02/macos-ocr-swift/"/>
    <id>http://yelog.org/2024/01/02/macos-ocr-swift/</id>
    <published>2024-01-02T02:09:19.000Z</published>
    <updated>2024-08-12T09:33:12.284Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近打算写一个 macos 翻译软件, 需要用到 ocr 图像识别, 并且因为速度问题, 一开始就考虑使用系统的自带能力来实现.</p><p>经过翻阅文档和 chatgpt 拉扯了一下午, 最终成功实现.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>代码逻辑为, 接受参数: 图片路径, 然后获取图片, 通过 <code>VNImageRequestHandler</code> 对图片进行文字识别</p><p>如下代码可以直接放进一个 <code>ocr.swift</code>, 然后执行 <code>swiftc -o ocr ocr.swift</code> , 在执行 <code>./ocr /Users/yelog/Desktop/3.png</code> 后面为你实际的有文字的图片路经</p><pre><code class="swift">////  ocr.swift//  Fast Translation////  Created by 杨玉杰 on 2023/12/31.//import SwiftUIimport Visionfunc handleDetectedText(request: VNRequest?, error: Error?) &#123;    if let error = error &#123;        print(&quot;ERROR: \(error)&quot;)        return    &#125;    guard let results = request?.results, results.count &gt; 0 else &#123;        print(&quot;No text found&quot;)        return    &#125;    for result in results &#123;        if let observation = result as? VNRecognizedTextObservation &#123;            for text in observation.topCandidates(1) &#123;                let string = text.string                print(&quot;识别: \(string)&quot;)            &#125;        &#125;    &#125;&#125;func ocrImage(path: String) &#123;    let cgImage = NSImage(byReferencingFile: path)?.ciImage()?.cgImage    let requestHandler = VNImageRequestHandler(cgImage: cgImage!)    let request = VNRecognizeTextRequest(completionHandler: handleDetectedText)    // 设置文本识别的语言为英文    request.recognitionLanguages = [&quot;en&quot;]    request.recognitionLevel = .accurate    do &#123;        try requestHandler.perform([request])    &#125; catch &#123;        print(&quot;Unable to perform the requests: \(error).&quot;)    &#125;&#125;extension NSImage &#123;    func ciImage() -&gt; CIImage? &#123;        guard let data = self.tiffRepresentation,              let bitmap = NSBitmapImageRep(data: data) else &#123;            return nil        &#125;        let ci = CIImage(bitmapImageRep: bitmap)        return ci    &#125;&#125;// 执行函数，从命令行参数中获取图片的地址ocrImage(path: CommandLine.arguments[1])</code></pre><p>然后准备待识别的有文字的图片</p><p><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/202401021353013.png" alt="待识别的图片"> </p><pre><code class="bash"># 编译 swift 文件swiftc -o ocr ocr.swift# 执行并且传递图片路径参数./ocr /Users/yelog/Desktop/3.png</code></pre><p><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/202401021354591.png" alt="执行识别效果"></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>最近打算着手写一些 macos 的小工具, 如果对 <code>swift</code> 或者 <code>macos</code> 感兴趣的可以关注或评论.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近打算写一个 macos 翻译软件, 需要用到 ocr 图像识别, 并且因为速度问题, 一开始就考虑使用系统的自带能力来实现.&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="开发" scheme="http://yelog.org/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="swift" scheme="http://yelog.org/categories/%E5%BC%80%E5%8F%91/swift/"/>
    
    
    <category term="swift" scheme="http://yelog.org/tags/swift/"/>
    
    <category term="macos" scheme="http://yelog.org/tags/macos/"/>
    
    <category term="ocr" scheme="http://yelog.org/tags/ocr/"/>
    
  </entry>
  
  <entry>
    <title>Caused by: java.lang.ClassNotFoundException: org.springframework.boot.loader.JarLauncher</title>
    <link href="http://yelog.org/2023/12/11/springboot-jarlauncher/"/>
    <id>http://yelog.org/2023/12/11/springboot-jarlauncher/</id>
    <published>2023-12-11T08:58:00.000Z</published>
    <updated>2024-08-12T09:33:12.220Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h2><p>今天同事再升级框架后(spring-cloud 2022.0.4 -&gt; 2023.0.0)(spring-boot 3.1.6 -&gt; 3.2.0)</p><p>同时因为 spring-boot 的版本问题, 需要将 maven 升级到 3.6.3+</p><p><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/202312111837604.png" alt="maven version"></p><p>升级后构建 jar 包和构建镜像都是正常的, 但是发布到测试环境就报错 <code>Caused by: java.lang.ClassNotFoundException: org.springframework.boot.loader.JarLauncher</code></p><p><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/202312111851862.png" alt="error log"></p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>报错为 JarLauncher 找不到, 检查了 <code>Jenkins</code> 中的打包任务, 发现并没有编译报错, 同事直接使用打包任务中产生的 xx.jar, 可以正常运行.</p><p>说明在打包 <code>Docker</code> 镜像前都没有问题, 这时就想起来我们在打包镜像时, 先解压 xx.jar, 然后直接执行 <code>org.springframework.boot.loader.JarLauncher</code>, 所以很可能是升级后, 启动文件 <code>JarLauncher</code> 的路径变了.</p><p>为了验证我们的猜想, 我们得看一下实际容器内的文件结构, 但是这时容器一直报错导致无法启动, 不能直接通过 <code>Rancher</code> 查看文件结构, 我们可以通过文件拷贝的方式来解决, 如下:</p><pre><code class="bash"># 下载有问题的镜像, 并且创建容器(不启动)docker create -it --name dumy 10.188.132.123:5000/lemes-cloud/lemes-gateway:develop-202312111536 bash# 直接拷贝容器内的我们想要看的目录docker cp dumy:/data .</code></pre><p>到本地后, 就可以通过合适的工具查找 <code>JarLauncher</code> 文件, 我这里通过 <code>vim</code> 来寻找, 如下图:</p><p><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/202312111902709.png" alt="JarLauncher Path"></p><p>发现比原来多了一层目录 <code>launch</code>, 所以问题就发生在这里了.</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>我们在打包脚本 <code>JenkinsCommon.groovy</code> 中根据当前打包的 JDK 版本来判断使用的启动类路径, 如下:</p><p><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/202312111905161.png" alt="Jenkins"></p><p>再次打包, 应用正常启动.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://docs.spring.io/spring-boot/docs/2.5.15/api/org/springframework/boot/loader/JarLauncher.html">JarLauncher</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题现象&quot;&gt;&lt;a href=&quot;#问题现象&quot; class=&quot;headerlink&quot; title=&quot;问题现象&quot;&gt;&lt;/a&gt;问题现象&lt;/h2&gt;&lt;p&gt;今天同事再升级框架后(spring-cloud 2022.0.4 -&amp;gt; 2023.0.0)(spring-boot 3</summary>
      
    
    
    
    <category term="后端" scheme="http://yelog.org/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="java" scheme="http://yelog.org/tags/java/"/>
    
    <category term="docker" scheme="http://yelog.org/tags/docker/"/>
    
    <category term="spring-boot" scheme="http://yelog.org/tags/spring-boot/"/>
    
  </entry>
  
  <entry>
    <title>ideavim 使用百分号%支持xml的对应标签跳转</title>
    <link href="http://yelog.org/2023/06/17/idea-tips-percent-mach-xml/"/>
    <id>http://yelog.org/2023/06/17/idea-tips-percent-mach-xml/</id>
    <published>2023-06-17T08:09:00.000Z</published>
    <updated>2024-08-12T09:33:12.028Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于最近几年使用 vim 的频率越来越高, 所以在 idea 中也大量开始使用 vim 技巧, 在一年多前碰到个问题, 终于在最近解决了。</p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在 idea 中, 在 normal 模式下, 使用 % 不能在匹配标签(xml&#x2F;html等) 之间跳转</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>在 <code>~/.ideavimrc</code> 中添加如下设置, 重启 idea 即可</p><pre><code class="bash">set matchit</code></pre><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/picgo_qiniu2023-06-17%2016.23.45.gif"></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>最近会把一些加的 tips 分享出来，大家有什么建议和问题都可以在评论区讨论.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;由于最近几年使用 vim 的频率越来越高, 所以在 idea 中也大量开始使用 vim 技巧, 在一年多前碰到个问题, 终于在最近解决了。&lt;</summary>
      
    
    
    
    <category term="工具" scheme="http://yelog.org/categories/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="IDEA" scheme="http://yelog.org/categories/%E5%B7%A5%E5%85%B7/IDEA/"/>
    
    
    <category term="efficiency" scheme="http://yelog.org/tags/efficiency/"/>
    
    <category term="vim" scheme="http://yelog.org/tags/vim/"/>
    
    <category term="IntellijIDEA" scheme="http://yelog.org/tags/IntellijIDEA/"/>
    
  </entry>
  
  <entry>
    <title>Raycast 最强效率软件推荐</title>
    <link href="http://yelog.org/2023/05/17/mac-raycast/"/>
    <id>http://yelog.org/2023/05/17/mac-raycast/</id>
    <published>2023-05-17T09:45:00.000Z</published>
    <updated>2024-08-12T09:33:11.882Z</updated>
    
    <content type="html"><![CDATA[<h2 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h2><p><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/picgo_qiniu202305171806865.png" alt="Raycast"></p><p>最近在很多平台上看到 Raycast 的推荐文章, 今天就尝试了一下, 发现确实不错, 完全可以替代我目前对 Alfred 的使用, 甚至很多地方做得更好, 所以本文就是介绍我使用 Raycast 的一些效果(多图预警)， 方便那些还没有接触这个软件的人对它有个了解, 如果有插件推荐, 欢迎在评论区进行讨论。</p><p>Raycast 是 MacMac 平台独占的效率工具, 主要包含如下功能:</p><ol><li>应用启动</li><li>文件查找</li><li>窗口管理</li><li>剪贴板历史</li><li>Snippets</li><li>应用菜单查询</li></ol><p>插件扩展功能</p><ol><li>翻译</li><li>斗图</li><li>结束进程</li><li>查询端口占用</li><li>查询ip</li></ol><p>除此之外, Raycast提供的在线插件商店, 可以很方便的进行功能扩展</p><p><a href="https://www.raycast.com/">Raycast官网</a></p><h2 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h2><h3 id="应用启动"><a href="#应用启动" class="headerlink" title="应用启动"></a>应用启动</h3><p><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/picgo_qiniu202305172245860.png"></p><p>并且支持卸载应用, 找到应用, <code>cmd+k</code> 打开操作菜单, 下拉到最后<br><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/picgo_qiniu202305181223320.png"></p><h3 id="文件查找"><a href="#文件查找" class="headerlink" title="文件查找"></a>文件查找</h3><p><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/picgo_qiniu202305172249647.png"></p><h3 id="窗口管理"><a href="#窗口管理" class="headerlink" title="窗口管理"></a>窗口管理</h3><p><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/picgo_qiniu202305172251703.png"></p><h3 id="剪贴板历史"><a href="#剪贴板历史" class="headerlink" title="剪贴板历史"></a>剪贴板历史</h3><p>推荐使用 <code>Clipboard History</code> 这个扩展，和 Alfred 的一样, 并且有分类，效果如下<br><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/picgo_qiniu202305181002644.png"></p><p>设置快捷键 <code>cmd+shift+v</code><br><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/picgo_qiniu202305181052831.png"></p><h3 id="Snippets"><a href="#Snippets" class="headerlink" title="Snippets"></a>Snippets</h3><p>通过 Snippets 可以保存自定义片段, 通过关键字快速查询并输出到光标处, 如常用语、 邮箱、手机号、税号、代码片段等等<br><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/picgo_qiniu202305181108693.png"></p><p>创建 Snippets 可以通过搜索 <code>Create Snippet</code>, 搜索 Snippets 可以通过搜索<code>Search Snippet</code></p><h3 id="应用菜单查询"><a href="#应用菜单查询" class="headerlink" title="应用菜单查询"></a>应用菜单查询</h3><p>查询当前激活应用的所有菜单, 不限层级. 可以通过搜索 <code>Search Menu Items</code> 来查询。<br><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/picgo_qiniu202305181231629.png"></p><h2 id="推荐插件"><a href="#推荐插件" class="headerlink" title="推荐插件"></a>推荐插件</h2><h3 id="Easydict-翻译软件"><a href="#Easydict-翻译软件" class="headerlink" title="Easydict(翻译软件)"></a>Easydict(翻译软件)</h3><p>超强的翻译软件， 完美替代我在 Alfred 的 workflow 中配置的有道翻译, 我配置了如下功能</p><ul><li>输入中文, 自动翻译成英文</li><li>输入英文, 自动翻译成中文</li><li>支持一键发音</li><li>Open AI 翻译长文本</li></ul><p><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/picgo_qiniu202305172258408.png"></p><h3 id="Doutu"><a href="#Doutu" class="headerlink" title="Doutu"></a>Doutu</h3><p>表情包查询，选中回车就复制到剪贴板了， 就可以粘贴到 Discord&#x2F;QQ&#x2F;Wechat 斗图了, 非常方便。</p><p><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/picgo_qiniu202305172300474.png"></p><h3 id="Kill-Process"><a href="#Kill-Process" class="headerlink" title="Kill Process"></a>Kill Process</h3><p>关键字查询, 并一键结束进程<br><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/picgo_qiniu202305181119726.png"></p><h3 id="Kill-Port"><a href="#Kill-Port" class="headerlink" title="Kill Port"></a>Kill Port</h3><p>查询端口占用的进程, 并支持一键结束进程<br><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/picgo_qiniu202305181120514.png"></p><h3 id="MyIp"><a href="#MyIp" class="headerlink" title="MyIp"></a>MyIp</h3><p>查询当前ip<br><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/picgo_qiniu202305181230312.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;软件介绍&quot;&gt;&lt;a href=&quot;#软件介绍&quot; class=&quot;headerlink&quot; title=&quot;软件介绍&quot;&gt;&lt;/a&gt;软件介绍&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/yelog/assets/images/picg</summary>
      
    
    
    
    <category term="工具" scheme="http://yelog.org/categories/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="软件记录" scheme="http://yelog.org/categories/%E5%B7%A5%E5%85%B7/%E8%BD%AF%E4%BB%B6%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="mac" scheme="http://yelog.org/tags/mac/"/>
    
    <category term="efficiency" scheme="http://yelog.org/tags/efficiency/"/>
    
  </entry>
  
  <entry>
    <title>[Java]通过 CompletableFuture 实现异步多线程优化请求处理速度</title>
    <link href="http://yelog.org/2022/08/01/[Java]optimize-request-processing-speed-by-completablefuture/"/>
    <id>http://yelog.org/2022/08/01/[Java]optimize-request-processing-speed-by-completablefuture/</id>
    <published>2022-08-01T12:06:14.000Z</published>
    <updated>2024-08-12T09:33:12.263Z</updated>
    
    <content type="html"><![CDATA[<h3 id="零、背景"><a href="#零、背景" class="headerlink" title="零、背景"></a>零、背景</h3><p>我们在写后端请求的时候, 可能涉及多次 SQL 执行(或其他操作), 当这些请求相互不关联, 在顺序执行时就浪费了时间, 这些不需要先后顺序的操作可以通过多线程进行同时执行, 来加速整个逻辑的执行速度.</p><p>既然有了目标和大致思路, 如果有做过前端的小伙伴应该能想起来 Js 里面有个 <code>Promise.all</code> 来解决这个问题, 在 Java 里也有类似功能的类 <code>CompletableFuture</code> , 它可以实现多线程和线程阻塞, 这样能够保证等待多个线程执行完成后再继续操作.</p><h3 id="一、CompletableFuture-是什么"><a href="#一、CompletableFuture-是什么" class="headerlink" title="一、CompletableFuture 是什么"></a>一、CompletableFuture 是什么</h3><p>首先我们先了解一下 <code>CompletableFuture</code> 是干什么, 接下来我们通过简单的示例来介绍他的作用.</p><pre><code class="java"> long startTime = System.currentTimeMillis();//生成几个任务List&lt;CompletableFuture&lt;String&gt;&gt; futureList = new ArrayList&lt;&gt;();futureList.add(CompletableFuture.supplyAsync(()-&gt;&#123;    sleep(4000);    System.out.println(&quot;任务1 完成&quot;);    return &quot;任务1的数据&quot;;&#125;));futureList.add(CompletableFuture.supplyAsync(()-&gt;&#123;    sleep(2000);    System.out.println(&quot;任务2 完成&quot;);    return &quot;任务2的数据&quot;;&#125;));futureList.add(CompletableFuture.supplyAsync(()-&gt;&#123;    sleep(3000);    System.out.println(&quot;任务3 完成&quot;);    return &quot;任务3的数据&quot;;&#125;));//完成任务CompletableFuture&lt;Void&gt; allTask = CompletableFuture.allOf(futureList.toArray(new CompletableFuture[0]))        .whenComplete((t, e) -&gt; &#123;            System.out.println(&quot;所有任务都完成了， 返回结果集: &quot;                    + futureList.stream().map(CompletableFuture::join).collect(Collectors.joining(&quot;,&quot;)));        &#125;);// 阻塞主线程allTask.join();System.out.println(&quot;main end, cost: &quot; + (System.currentTimeMillis() - startTime));</code></pre><p>执行结果</p><pre><code class="bash">任务2 完成任务3 完成任务1 完成所有任务都完成了， 返回结果集: 任务1的数据,任务2的数据,任务3的数据main end, cost: 4032</code></pre><blockquote><p><strong>结果分析:</strong> 我们需要执行3个任务, 3个任务同时执行, 互不影响</p></blockquote><ol><li>其中任务2耗时最短,提前打印完成</li><li>其次是任务3</li><li>最后是执行1完成</li><li>当所有任务完成后, 触发 <code>whenComplete</code> 方法, 打印任务的返回结果</li><li>最后打印总耗时为 4.032s</li><li>结论: 多线程执行后, 耗时取决于最耗时的操作, 而单线程是所有操作耗时之和</li></ol><h3 id="二、封装工具类"><a href="#二、封装工具类" class="headerlink" title="二、封装工具类"></a>二、封装工具类</h3><p>经过上面的测试, 通过 <code>CompletableFuture</code> 已经能够实现我们的预想, 为了操作方便, 我们将封装起来, 便于统一管理</p><pre><code class="java">package org.yelog.java.usage.concurrent;import java.util.ArrayList;import java.util.List;import java.util.concurrent.CompletableFuture;import java.util.function.Consumer;import java.util.function.Function;import java.util.function.Predicate;/** * 执行并发任务 * * @author yangyj13 * @date 11/7/22 9:49 PM */public class MultiTask&lt;T&gt; &#123;    private List&lt;CompletableFuture&lt;T&gt;&gt; futureList;    /**     * 添加待执行的任务     *     * @param completableFuture 任务     * @return 当前对象     */    public MultiTask&lt;T&gt; addTask(CompletableFuture&lt;T&gt; completableFuture) &#123;        if (futureList == null) &#123;            futureList = new ArrayList&lt;&gt;();        &#125;        futureList.add(completableFuture);        return this;    &#125;    /**     * 添加待执行的任务(无返回)     *     * @param task 任务     * @return 当前对象     */    public MultiTask&lt;T&gt; addTask(Consumer&lt;T&gt; task) &#123;        addTask(CompletableFuture.supplyAsync(() -&gt; &#123;            task.accept(null);            return null;        &#125;));        return this;    &#125;    /**     * 添加待执行的任务(有返回)     *     * @param task 任务     * @return 当前对象     */    public MultiTask&lt;T&gt; addTask(Function&lt;Object, T&gt; task) &#123;        addTask(CompletableFuture.supplyAsync(() -&gt; task.apply(null)));        return this;    &#125;    /**     * 开始执行任务     *     * @param callback                当所有任务都完成后触发的回调方法     * @param waitTaskExecuteComplete 是否阻塞主线程     */    private void execute(Consumer&lt;List&lt;T&gt;&gt; callback, Boolean waitTaskExecuteComplete) &#123;        CompletableFuture&lt;Void&gt; allFuture = CompletableFuture.allOf(futureList.toArray(new CompletableFuture[0]))                .whenComplete((t, e) -&gt; &#123;                    if (callback != null) &#123;                        List&lt;T&gt; objectList = new ArrayList&lt;&gt;();                        futureList.forEach((future) -&gt; &#123;                            objectList.add(future.join());                        &#125;);                        callback.accept(objectList);                    &#125;                &#125;);        if (callback != null || waitTaskExecuteComplete == null || waitTaskExecuteComplete) &#123;            allFuture.join();        &#125;    &#125;    /**     * 开始执行任务     * 等待所有任务完成（阻塞主线程）     */    public void execute() &#123;        execute(null, true);    &#125;    /**     * 开始执行任务     *     * @param waitTaskExecuteComplete 是否阻塞主线程     */    public void execute(Boolean waitTaskExecuteComplete) &#123;        execute(null, waitTaskExecuteComplete);    &#125;    /**     * 开始执行任务     *     * @param callback 当所有任务都完成后触发的回调方法     */    public void execute(Consumer&lt;List&lt;T&gt;&gt; callback) &#123;        execute(callback, true);    &#125;&#125;</code></pre><p>那么上一步我们测试的流程转换成工具类后如下</p><pre><code class="java">long startTime = System.currentTimeMillis();MultiTask&lt;String&gt; multiTask = new MultiTask&lt;&gt;();multiTask.addTask(t -&gt; &#123;    sleep(1000);    System.out.println(&quot;任务1 完成&quot;);&#125;).addTask(t -&gt; &#123;    sleep(3000);    System.out.println(&quot;任务2 完成&quot;);&#125;).addTask(CompletableFuture.supplyAsync(()-&gt;&#123;    sleep(2000);    System.out.println(&quot;任务3 完成&quot;);    return &quot;任务3的数据&quot;;&#125;)).execute(resultList-&gt;&#123;    System.out.println(&quot;all complete: &quot; + resultList);&#125;);System.out.println(&quot;main end, cost: &quot; + (System.currentTimeMillis() - startTime));</code></pre><h3 id="三、应用到实际的效果"><a href="#三、应用到实际的效果" class="headerlink" title="三、应用到实际的效果"></a>三、应用到实际的效果</h3><p>执行两次数据库的操作如下</p><pre><code class="java">public interface TestMapper &#123;    @Select(&quot;select count(*) from test_user where score &lt; 1000 and user_id = #&#123;userId&#125;&quot;)    int countScoreLess1000(Integer userId);    @Select(&quot;select count(1) from test_log where success = true and user_id = #&#123;userId&#125;&quot;)    int countSuccess(Integer userId);&#125;</code></pre><p>调用方法:</p><pre><code class="java">long start = System.currentTimeMillis();testMapper.countScoreLess1000(userId);long countScoreLess1000End = System.currentTimeMillis();log.info(&quot;countScoreLess1000 cost: &quot; + (countScoreLess1000End - start));testMapper.countSuccess(userId);long countSuccessEnd = System.currentTimeMillis();log.info(&quot;countSuccess cost: &quot; + (countSuccessEnd - countScoreLess1000End));log.info(&quot;all cost: &quot; + (countSuccessEnd - start));</code></pre><p>顺序执行的平均时间如下</p><pre><code class="bash">countScoreLess1000 cost: 368countSuccess cost: 404all cost: 772</code></pre><p>当我们应用的上面的工具类后的调用方法</p><pre><code class="java">MultiTask multiTask = new MultiTask&lt;&gt;();multiTask.addTask(t -&gt; &#123;    testMapper.countScoreLess1000(userId);    log.info(&quot;countScoreLess1000 cost: &quot; + (System.currentTimeMillis() - start));&#125;).addTask(t -&gt; &#123;    testMapper.countSuccess(userId);    log.info(&quot;countSuccess cost: &quot; + (System.currentTimeMillis() - start));&#125;).execute();log.info(&quot;all cost: &quot; + (System.currentTimeMillis() - start));</code></pre><p>效果如下</p><pre><code class="bash">countScoreLess1000 cost: 433countSuccess cost: 463all cost: 464</code></pre><p>可以看到各子任务执行时长是差不多的, 但是总耗时使用多线程后有了明显下降</p><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>通过使用 <code>CompletableFuture</code> 实现多线程阻塞执行后, 大幅降低这类请求, 并且当可以异步执行的子任务越多, 效果越明显.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;零、背景&quot;&gt;&lt;a href=&quot;#零、背景&quot; class=&quot;headerlink&quot; title=&quot;零、背景&quot;&gt;&lt;/a&gt;零、背景&lt;/h3&gt;&lt;p&gt;我们在写后端请求的时候, 可能涉及多次 SQL 执行(或其他操作), 当这些请求相互不关联, 在顺序执行时就浪费了时间, 这</summary>
      
    
    
    
    <category term="后端" scheme="http://yelog.org/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="java" scheme="http://yelog.org/tags/java/"/>
    
    <category term="concurrent" scheme="http://yelog.org/tags/concurrent/"/>
    
  </entry>
  
  <entry>
    <title>基于 nacos/灰度发布 实现减少本地启动微服务数量的实践</title>
    <link href="http://yelog.org/2022/08/01/reducing-local-springcloud-base-on-nacos-and-gray-release/"/>
    <id>http://yelog.org/2022/08/01/reducing-local-springcloud-base-on-nacos-and-gray-release/</id>
    <published>2022-08-01T12:06:14.000Z</published>
    <updated>2024-08-12T09:33:12.211Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p>后台框架是基于 spring cloud 的微服务体系, 当开发同学在自己电脑上进行开发工作时, 比如开发订单模块, 除了需要启动订单模块外, 还需要启动网关模块、权限校验模块、公共服务模块等依赖模块, 非常消耗开发同学的本地电脑的资源, 也及其浪费时间.</p><p><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/picgo_qiniu20220801233224.png" alt="Spring Cloud"></p><h2 id="二、解决方案"><a href="#二、解决方案" class="headerlink" title="二、解决方案"></a>二、解决方案</h2><h3 id="2-1-目标和关键问题"><a href="#2-1-目标和关键问题" class="headerlink" title="2.1 目标和关键问题"></a>2.1 目标和关键问题</h3><p>能不能开发同学本地只需要启动需要开发的模块:订单模块, 其他模块均适用测试环境中正在运行的服务.</p><p>既然要实现的目标有了, 我们就开始研究可行性和关键问题</p><ol><li>开发环境和测试环境要在同一个 nacos 的 namespace 中, 这样才有可能让开发环境调用到测试环境的服务.</li><li>测试环境只能调用测试环境的微服务, 实现和开发环境的服务隔离</li><li>开发同学之间的微服务也要实现服务隔离</li></ol><h3 id="2-2-思路"><a href="#2-2-思路" class="headerlink" title="2.2 思路"></a>2.2 思路</h3><p>既要在同一个 namespace 下, 又要能够实现不同人访问不同的副本, 很容易想到可以利用<code>灰度发布</code>来实现:</p><ol><li>测试环境设置 metadata <code>lemes-env=product</code> 来标识测试环境副本, 用于区分开发环境的微服务测测试环境的微服务</li><li>开发同学本地启动注册开发环境副本, 都会携带唯一IP, 则我们可以通过IP来区分不同开发同学的副本</li></ol><p>假设我们需要开发的 API 的后台服务调用链条如下:</p><p><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/picgo_qiniu20220802004250.png" alt="请求调用"></p><p>我们需要开发的 API 为 <code>/addMo</code>, 打算写在 <code>Order</code> 这个微服务里面, 并且他会调用 <code>common</code> 这个微服务的 <code>/getDict</code> 获取一个字典数据, <code>/getDict</code> 是现成的, 不需要开发, 如果是之前的情况, 开发本地至少需要启动5个微服务才能进行调试.</p><p><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/picgo_qiniu20220802004109.png" alt="实现效果"></p><h2 id="三、具体实现"><a href="#三、具体实现" class="headerlink" title="三、具体实现"></a>三、具体实现</h2><h3 id="3-1-测试环境设置-metadata"><a href="#3-1-测试环境设置-metadata" class="headerlink" title="3.1 测试环境设置 metadata"></a>3.1 测试环境设置 metadata</h3><p>由于测试环境都是通过容器部署的, 那么启动方式就是下面容器中的 <code>CMD</code>, 我们在其中加入 <code>-Dspring.cloud.nacos.discovery.metadata.lemes-env=product</code>, 用于区分开发环境的微服务测测试环境的微服务</p><pre><code class="Dockerfile"># 说明：Dockerfile 过程分为两部分。第一次用来解压 jar 包，并不会在目标镜像内产生 history/layer。第二部分将解压内容分 layer 拷贝到目标镜像内# 目的：更新镜像时，只需要传输代码部分，依赖没有变动则不更新，节省发包时的网络传输量# 原理：在第二部分中，每次 copy 就会在目标镜像内产生一层 layer，将依赖和代码分开，#      绝大部分更新都不会动到依赖，所以只需更新代码几十k左右的代码层即可FROM 10.176.66.20:5000/library/amazoncorretto:11.0.11  as builderWORKDIR /buildARG ARTIFACT_IDCOPY target/$&#123;ARTIFACT_ID&#125;.jar app.jarRUN java -Djarmode=layertools -jar app.jar extract &amp;&amp; rm app.jarFROM 10.176.66.20:5000/library/amazoncorretto:11.0.11LABEL maintainer=&quot;yangyj13@lenovo.com&quot;WORKDIR /dataARG ARTIFACT_IDENV ARTIFACT_ID $&#123;ARTIFACT_ID&#125;# 依赖COPY --from=builder /build/dependencies/ ./COPY --from=builder /build/snapshot-dependencies/ ./COPY --from=builder /build/spring-boot-loader/ ./# 应用代码COPY --from=builder /build/application/ ./# 容器运行时启动命令CMD echo &quot;NACOS_ADDR: $&#123;NACOS_ADDR&#125;&quot;; \    echo &quot;JAVA_OPTS: $&#123;JAVA_OPTS&#125;&quot;; \    echo &quot;TZ: $&#123;TZ&#125;&quot;; \    echo &quot;ARTIFACT_ID: $&#123;ARTIFACT_ID&#125;&quot;; \    # 去除了 server 的应用名    REAL_APP_NAME=$&#123;ARTIFACT_ID//-server/&#125;; \    echo &quot;REAL_APP_NAME: $&#123;REAL_APP_NAME&#125;&quot;; \    # 获取当前时间    now=`date +%F+%T+%Z`; \    # java 启动命令    java $JAVA_OPTS \    -Dtingyun.app_name=$&#123;REAL_APP_NAME&#125;-$&#123;TINGYUN_SUFFIX&#125; \    -Dspring.cloud.nacos.discovery.metadata.lemes-env=product \    -Dspring.cloud.nacos.discovery.metadata.startup-time=$&#123;now&#125; \    -Dspring.cloud.nacos.discovery.server-addr=$&#123;NACOS_ADDR&#125; \    -Dspring.cloud.nacos.discovery.group=$&#123;NACOS_GROUP&#125; \    -Dspring.cloud.nacos.config.namespace=$&#123;NACOS_NAMESPACE&#125; \    -Dspring.cloud.nacos.discovery.namespace=$&#123;NACOS_NAMESPACE&#125; \    -Dspring.cloud.nacos.discovery.ip=$&#123;HOST_IP&#125; \    org.springframework.boot.loader.JarLauncher</code></pre><p><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/picgo_qiniu20220802135945.png" alt="set nacos metadata"></p><h3 id="3-2-开发前端传递开启智能连接"><a href="#3-2-开发前端传递开启智能连接" class="headerlink" title="3.2 开发前端传递开启智能连接"></a>3.2 开发前端传递开启智能连接</h3><pre><code class="js">const devIp = getLocalIP(&#39;10.&#39;)module.exports = &#123;  devServer: &#123;    proxy: &#123;      &#39;/lemes-api&#39;: &#123;        target: &#39;http://10.176.66.58/lemes-api&#39;,        ws: true,        pathRewrite: &#123;          &#39;^/lemes-api&#39;: &#39;/&#39;        &#125;,        headers: &#123;          &#39;dev-ip&#39;: devIp,          &#39;dev-sc&#39;: &#39;true&#39;        &#125;      &#125;    &#125;  &#125;,&#125;// 获取本机 IPfunction getLocalIP(prefix) &#123;  const excludeNets = [&#39;docker&#39;, &#39;cni&#39;, &#39;flannel&#39;, &#39;vi&#39;, &#39;ve&#39;]  const os = require(&#39;os&#39;)  const osType = os.type() // 系统类型  const netInfo = os.networkInterfaces() // 网络信息  const ipList = []  if (prefix) &#123;    for (const netInfoKey in netInfo) &#123;      if (excludeNets.filter(item =&gt; netInfoKey.startsWith(item)).length === 0) &#123;        for (let i = 0; i &lt; netInfo[netInfoKey].length; i++) &#123;          const net = netInfo[netInfoKey][i]          if (net.family === &#39;IPv4&#39; &amp;&amp; net.address.startsWith(prefix)) &#123;            ipList.push(net.address)          &#125;        &#125;      &#125;    &#125;  &#125;  if (ipList.length === 0) &#123;    if (osType === &#39;Windows_NT&#39;) &#123;      for (const dev in netInfo) &#123;        // win7的网络信息中显示为本地连接，win10显示为以太网        if (dev === &#39;本地连接&#39; || dev === &#39;以太网&#39;) &#123;          for (let j = 0; j &lt; netInfo[dev].length; j++) &#123;            if (netInfo[dev][j].family === &#39;IPv4&#39;) &#123;              ipList.push(netInfo[dev][j].address)            &#125;          &#125;        &#125;      &#125;    &#125; else if (osType === &#39;Linux&#39;) &#123;      ipList.push(netInfo.eth0[0].address)    &#125; else if (osType === &#39;Darwin&#39;) &#123;      ipList.push(netInfo.en0[0].address)    &#125;  &#125;  console.log(&#39;识别到的网卡信息&#39;, JSON.stringify(ipList))  return ipList.length &gt; 0 ? ipList[0] : &#39;&#39;&#125;</code></pre><h3 id="3-3-后端灰度处理"><a href="#3-3-后端灰度处理" class="headerlink" title="3.3 后端灰度处理"></a>3.3 后端灰度处理</h3><p>不论是 <code>gateway</code> 还是 <code>openfeign</code> 都是通过 spring 的 <code>loadbalancer</code> 进行应用选择的, 那我们通过实现或者继承 <code>ReactorServiceInstanceLoadBalancer</code> 来重写选择的过程.</p><pre><code class="java">@Log4j2public class LemesLoadBalancer implements ReactorServiceInstanceLoadBalancer&#123;    @Autowired    private NacosDiscoveryProperties nacosDiscoveryProperties;    final AtomicInteger position;    // loadbalancer 提供的访问当前服务的名称    final String serviceId;    // loadbalancer 提供的访问的服务列表    ObjectProvider&lt;ServiceInstanceListSupplier&gt; serviceInstanceListSupplierProvider;    public LemesLoadBalancer(ObjectProvider&lt;ServiceInstanceListSupplier&gt; serviceInstanceListSupplierProvider, String serviceId) &#123;        this(serviceInstanceListSupplierProvider, serviceId, new Random().nextInt(1000));    &#125;    public LemesLoadBalancer(ObjectProvider&lt;ServiceInstanceListSupplier&gt; serviceInstanceListSupplierProvider,                             String serviceId, int seedPosition) &#123;        this.serviceId = serviceId;        this.serviceInstanceListSupplierProvider = serviceInstanceListSupplierProvider;        this.position = new AtomicInteger(seedPosition);    &#125;    @Override    public Mono&lt;Response&lt;ServiceInstance&gt;&gt; choose(Request request) &#123;        ServiceInstanceListSupplier supplier = serviceInstanceListSupplierProvider                .getIfAvailable(NoopServiceInstanceListSupplier::new);        RequestDataContext context = (RequestDataContext) request.getContext();        RequestData clientRequest = context.getClientRequest();        return supplier.get(request).next()                .map(serviceInstances -&gt; processInstanceResponse(clientRequest,supplier, serviceInstances));    &#125;    private Response&lt;ServiceInstance&gt; processInstanceResponse(RequestData clientRequest,ServiceInstanceListSupplier supplier,                                                              List&lt;ServiceInstance&gt; serviceInstances) &#123;        Response&lt;ServiceInstance&gt; serviceInstanceResponse = getInstanceResponse(clientRequest,serviceInstances);        if (supplier instanceof SelectedInstanceCallback &amp;&amp; serviceInstanceResponse.hasServer()) &#123;            ((SelectedInstanceCallback) supplier).selectedServiceInstance(serviceInstanceResponse.getServer());        &#125;        return serviceInstanceResponse;    &#125;    private Response&lt;ServiceInstance&gt; getInstanceResponse(RequestData clientRequest, List&lt;ServiceInstance&gt; instances) &#123;        if (instances.isEmpty()) &#123;            if (log.isWarnEnabled()) &#123;                log.warn(&quot;No servers available for service: &quot; + serviceId);            &#125;            return new EmptyResponse();        &#125;        int pos = Math.abs(this.position.incrementAndGet());        // 筛选后的服务列表        List&lt;ServiceInstance&gt; filteredInstances;        String devSmartConnect = clientRequest.getHeaders().getFirst(CommonConstants.DEV_SMART_CONNECT);        if (StrUtil.equals(devSmartConnect, &quot;true&quot;)) &#123;            String devIp = clientRequest.getHeaders().getFirst(CommonConstants.DEV_IP);            // devIp 为空，为异常情况不处理，返回空实例集合            if (StrUtil.isBlank(devIp)) &#123;                log.warn(&quot;devIp is NULL,No servers available for service: &quot; + serviceId);                return new EmptyResponse();            &#125;            // 智能连接: 如果本地启动了服务，则优先访问本地服务，如果本地没有启动，则访问测试环境服务            // 优先调用本地自有服务            filteredInstances = instances.stream().filter(item -&gt; StrUtil.equals(devIp, item.getHost())).collect(Collectors.toList());            // 如果本地服务没有开启，则调用生产/测试服务            if (CollUtil.isEmpty(filteredInstances)) &#123;                filteredInstances = instances.stream()                        .filter(item -&gt; StrUtil.equals(CommonConstants.LEMES_ENV_PRODUCT, item.getMetadata().get(&quot;lemes-env&quot;)))                        .collect(Collectors.toList());                // 解决开发环境无法访问 k8s 集群内 ip 的问题                String oneNacosIp = nacosDiscoveryProperties.getServerAddr().split(&quot;,&quot;)[0].replaceAll(&quot;:[\\s\\S]*&quot;, &quot;&quot;);                filteredInstances.forEach(item -&gt; &#123;                    NacosServiceInstance instance = (NacosServiceInstance) item;                    // cloud 以 80 端口启动，认为是 k8s 内的应用                    if (instance.getPort() == 80) &#123;                        instance.setHost(oneNacosIp);                        instance.setPort(Integer.parseInt(item.getMetadata().get(&quot;port&quot;)));                    &#125;                &#125;);            &#125;        &#125; else &#123;            // 不是智能访问，则只访问一个环境            // 当前服务 ip            String currentIp = nacosDiscoveryProperties.getIp();            String lemesEnv = nacosDiscoveryProperties.getMetadata().get(&quot;lemes-env&quot;);            filteredInstances = instances.stream()                    .filter(item -&gt; StrUtil.equals(lemesEnv, CommonConstants.LEMES_ENV_PRODUCT)                            // 访问测试环境                            ? StrUtil.equals(CommonConstants.LEMES_ENV_PRODUCT, item.getMetadata().get(&quot;lemes-env&quot;))                            // 访问开发环境                            : StrUtil.equals(currentIp, item.getHost()))                    .collect(Collectors.toList());        &#125;        if (filteredInstances.isEmpty()) &#123;            log.warn(&quot;No oneself servers and beta servers available for service: &quot; + serviceId + &quot;, use other instances&quot;);            // 找不到自己注册IP对应的服务和测试服务，则用nacos中其它的服务            filteredInstances = instances;        &#125;        //最终的返回的 serviceInstance        ServiceInstance instance = filteredInstances.get(pos % filteredInstances.size());        return new DefaultResponse(instance);    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、背景&quot;&gt;&lt;a href=&quot;#一、背景&quot; class=&quot;headerlink&quot; title=&quot;一、背景&quot;&gt;&lt;/a&gt;一、背景&lt;/h2&gt;&lt;p&gt;后台框架是基于 spring cloud 的微服务体系, 当开发同学在自己电脑上进行开发工作时, 比如开发订单模块, 除了需</summary>
      
    
    
    
    <category term="后端" scheme="http://yelog.org/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="java" scheme="http://yelog.org/tags/java/"/>
    
    <category term="k8s" scheme="http://yelog.org/tags/k8s/"/>
    
    <category term="nacos" scheme="http://yelog.org/tags/nacos/"/>
    
    <category term="springcloud" scheme="http://yelog.org/tags/springcloud/"/>
    
    <category term="gray-release" scheme="http://yelog.org/tags/gray-release/"/>
    
  </entry>
  
  <entry>
    <title>基于 nacos/springcloud/k8s 的不停机服务更新[graceful shutdown]</title>
    <link href="http://yelog.org/2022/07/27/springboot-graceful-shutdown-based-on-nacos2-and-k8s/"/>
    <id>http://yelog.org/2022/07/27/springboot-graceful-shutdown-based-on-nacos2-and-k8s/</id>
    <published>2022-07-27T07:35:39.000Z</published>
    <updated>2024-08-12T09:33:11.981Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我们的 SpringCloud 是部署在 k8s 上的, 当通过 k8s 进行滚动升级时, 会有请求 500 的情况, 不利于用户体验, 严重的可能造成数据错误的问题</p><blockquote><p>k8s 滚动更新策略介绍<br>假设我们要升级的微服务在环境上为3个副本的集群, 升级应用时, 会先启动1个新版本的副本, 然后下线一个旧版本的副本, 之后再启动1个新版本的副本, 一次类推,直到所有旧副本都替换新副本.</p></blockquote><p>通过链路追踪分析, 报错的原因分别由以下两种情况</p><ol><li>SpringCloud 中的微服务在升级过程中, 当旧的微服务中还有没有处理完成的请求时, 就开始关闭动作, 造成请求中断</li><li>当旧应用执行关闭动作时, 已经开始拒绝请求, 但是 nacos 中的路由并没有及时更新, 造成 gateway&#x2F;openfeign 在路由时仍会命中正在关闭的应用, 造成请求报错</li></ol><p>为了解决这个问题, 我们将利用 springboot 的 graceful shutdown 功能和 nacos 的主动下线功能来解决这个问题. 具体思路如下:</p><p>比如当我们执行订单微服务(3个副本)滚动更新时</p><ol><li>先启动一个新版本<code>副本4</code></li><li>然后准备关闭<code>副本1</code>, 在关闭之前先通知 nacos 订单服务的<code>副本1</code>下线, 然后由 nacos 通知给其他应用(nacos2.x 是grpc, 所以通知速度比较快), 这样, 订单服务的<code>副本1</code>就不会再接收到请求, 然后执行 graceful shutdown(springboot 原生支持, 启用方法可以看后面代码), 所有请求处理完成后关闭应用. 这样就完成了 <code>副本1</code> 的关闭</li><li>启动新版本<code>副本5</code></li><li>再优雅关闭<code>副本2</code>(参考第2点<code>副本1</code>的流程)</li><li>然后启动新版本<code>副本6</code></li><li>再优雅关闭<code>副本3</code></li><li>完成了服务不中断的应用升级</li></ol><h2 id="实现关键点"><a href="#实现关键点" class="headerlink" title="实现关键点"></a>实现关键点</h2><p>为了实现上面背景中提到的思路, 主要从如下几个方面入手</p><h3 id="创建从-nacos-中下线副本的API"><a href="#创建从-nacos-中下线副本的API" class="headerlink" title="创建从 nacos 中下线副本的API"></a>创建从 nacos 中下线副本的API</h3><p>我们通过创建自定义名为 <code>deregister</code> 的 <code>endpoint</code> 来通知 <code>nacos</code> 下线副</p><pre><code class="java">import com.alibaba.cloud.nacos.NacosDiscoveryProperties;import com.alibaba.cloud.nacos.registry.NacosRegistration;import com.alibaba.cloud.nacos.registry.NacosServiceRegistry;import lombok.extern.log4j.Log4j2;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.actuate.endpoint.annotation.Endpoint;import org.springframework.boot.actuate.endpoint.annotation.ReadOperation;import org.springframework.stereotype.Component;@Component@Endpoint(id = &quot;deregister&quot;)@Log4j2public class LemesNacosServiceDeregisterEndpoint &#123;    @Autowired    private NacosDiscoveryProperties nacosDiscoveryProperties;    @Autowired    private NacosRegistration nacosRegistration;    @Autowired    private NacosServiceRegistry nacosServiceRegistry;    /**     * 从 nacos 中主动下线，用于 k8s 滚动更新时，提前下线分流流量     *     * @param     * @return com.lenovo.lemes.framework.core.util.ResultData&lt;java.lang.String&gt;     * @author Yujie Yang     * @date 4/6/22 2:57 PM     */    @ReadOperation    public String endpoint() &#123;        String serviceName = nacosDiscoveryProperties.getService();        String groupName = nacosDiscoveryProperties.getGroup();        String clusterName = nacosDiscoveryProperties.getClusterName();        String ip = nacosDiscoveryProperties.getIp();        int port = nacosDiscoveryProperties.getPort();        log.info(&quot;deregister from nacos, serviceName:&#123;&#125;, groupName:&#123;&#125;, clusterName:&#123;&#125;, ip:&#123;&#125;, port:&#123;&#125;&quot;, serviceName, groupName, clusterName, ip, port);        // 设置服务下线        nacosServiceRegistry.setStatus(nacosRegistration, &quot;DOWN&quot;);        return &quot;success&quot;;    &#125;&#125;</code></pre><h3 id="支持-Graceful-Shutdown"><a href="#支持-Graceful-Shutdown" class="headerlink" title="支持 Graceful Shutdown"></a>支持 Graceful Shutdown</h3><p>由于 springboot 原生支持, 我们只需要在 <code>bootstrap.yaml</code> 中添加如下配置即可</p><pre><code class="yaml">server:  # 开启优雅下线  shutdown: gracefulspring:  lifecycle:    # 优雅下线超时时间    timeout-per-shutdown-phase: 5m# 暴露 shutdown 接口management:  endpoint:    shutdown:      enabled: true  endpoints:    web:      exposure:        include: shutdown</code></pre><h3 id="K8s-配置"><a href="#K8s-配置" class="headerlink" title="K8s 配置"></a>K8s 配置</h3><p>有了上面两个 API, 接下来就配置到 k8s 上</p><ol><li>terminationGracePeriodSeconds 如果关闭应用的时间超过 10 分钟, 则向容器发送 TERM 信号, 防止应用长时间下线不了</li><li>preStop 先执行下线操作, 等待30s, 留够通知到其他应用的时间, 然后执行 graceful shutdown 关闭应用</li></ol><pre><code class="yaml">---apiVersion: apps/v1kind: Deploymentmetadata:  name: lemes-service-common  labels:    app: lemes-service-commonspec:  replicas: 2  selector:    matchLabels:      app: lemes-service-common#  strategy:#    type: RollingUpdate#    rollingUpdate:##     replicas - maxUnavailable &lt; running num  &lt; replicas + maxSurge#      maxUnavailable: 1#      maxSurge: 1  template:    metadata:      labels:        app: lemes-service-common    spec:#      容器重启策略 Never Always OnFailure#      restartPolicy: Never#     如果关闭时间超过10分钟， 则向容器发送 TERM 信号      terminationGracePeriodSeconds: 600      affinity:        podAntiAffinity:          preferredDuringSchedulingIgnoredDuringExecution:            - podAffinityTerm:                topologyKey: &quot;kubernetes.io/hostname&quot;                labelSelector:                  matchExpressions:                    - key: app                      operator: In                      values:                        - lemes-service-common              weight: 100#          requiredDuringSchedulingIgnoredDuringExecution:#            - labelSelector:#                matchExpressions:#                  - key: app#                    operator: In#                    values:#                      - lemes-service-common#              topologyKey: &quot;kubernetes.io/hostname&quot;      volumes:        - name: lemes-host-path          hostPath:            path: /data/logs            type: DirectoryOrCreate        - name: sidecar          emptyDir: &#123; &#125;      containers:        - name: lemes-service-common          image: 10.176.66.20:5000/lemes-cloud/lemes-service-common-server:v0.1          imagePullPolicy: Always          volumeMounts:            - name: lemes-host-path              mountPath: /data/logs            - name: sidecar              mountPath: /sidecar          ports:            - containerPort: 80          resources:#           资源通常情况下的占用            requests:              memory: &#39;2048Mi&#39;#           资源占用上限            limits:              memory: &#39;4096Mi&#39;          livenessProbe:            httpGet:              path: /actuator/health/liveness              port: 80            initialDelaySeconds: 5#           探针可以连续失败的次数            failureThreshold: 10#           探针超时时间            timeoutSeconds: 10#           多久执行一次探针查询            periodSeconds: 10          startupProbe:            httpGet:              path: /actuator/health/liveness              port: 80            failureThreshold: 30            timeoutSeconds: 10            periodSeconds: 10          readinessProbe:            httpGet:              path: /actuator/health/readiness              port: 80            initialDelaySeconds: 5            timeoutSeconds: 10            periodSeconds: 10          lifecycle:            preStop:              exec:#               应用关闭操作：1. 从 nacos 下线，2. 等待30s, 保证 nacos 通知到其他应用 2.触发 springboot 的 graceful shutdown                command:                  - sh                  - -c                  - curl http://127.0.0.1/actuator/deregister;sleep 30;curl -X POST http://127.0.0.1/actuator/shutdown;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;我们的 SpringCloud 是部署在 k8s 上的, 当通过 k8s 进行滚动升级时, 会有请求 500 的情况, 不利于用户体验, 严</summary>
      
    
    
    
    <category term="后端" scheme="http://yelog.org/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="java" scheme="http://yelog.org/tags/java/"/>
    
    <category term="k8s" scheme="http://yelog.org/tags/k8s/"/>
    
    <category term="nacos" scheme="http://yelog.org/tags/nacos/"/>
    
    <category term="springcloud" scheme="http://yelog.org/tags/springcloud/"/>
    
  </entry>
  
  <entry>
    <title>2022年我在使用这些vim插件</title>
    <link href="http://yelog.org/2022/06/27/vim-plugs-2022/"/>
    <id>http://yelog.org/2022/06/27/vim-plugs-2022/</id>
    <published>2022-06-27T07:07:39.000Z</published>
    <updated>2024-08-12T09:33:11.752Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从第一次接触 <code>vim</code> 已逾期 10 年, 期间大部分都是一些简单操作,<br>最近一两年开始深度使用 <code>vim</code>, 目前使用 <code>neovim</code> 版本.<br>本文将记录一些笔者觉得好用的一些 <code>Plugin</code>, 本文也将持续更新.</p><blockquote><p>注意: 笔者使用的插件管理器是 <a href="https://github.com/junegunn/vim-plug">vim-plug</a>,<br>所以以下示例都是基于 <code>vim-plug</code> 来写的.</p></blockquote><h2 id="Goto-Open"><a href="#Goto-Open" class="headerlink" title="Goto&#x2F;Open"></a>Goto&#x2F;Open</h2><h3 id="vim-open-url"><a href="#vim-open-url" class="headerlink" title="vim-open-url"></a>vim-open-url</h3><p><a href="https://github.com/dhruvasagar/vim-open-url">vim-open-url</a><br>可以用浏览器打开光标下的 url. </p><ul><li><code>gB</code> 用默认浏览器打开光标下的 url</li><li><code>g&lt;CR&gt;</code> 使用默认搜索引擎搜索光标下的单词</li><li><code>gG</code> 使用 Google 搜索光标下的单词</li><li><code>gW</code> 使用 Wikipedia 搜索光标下的单词</li></ul><pre><code class="vim">Plug &#39;dhruvasagar/vim-open-url&#39;</code></pre><h2 id="Auto-Complete"><a href="#Auto-Complete" class="headerlink" title="Auto Complete"></a>Auto Complete</h2><h3 id="neoclide-coc-nvim"><a href="#neoclide-coc-nvim" class="headerlink" title="neoclide&#x2F;coc.nvim"></a>neoclide&#x2F;coc.nvim</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;从第一次接触 &lt;code&gt;vim&lt;/code&gt; 已逾期 10 年, 期间大部分都是一些简单操作,&lt;br&gt;最近一两年开始深度使用 &lt;code&gt;</summary>
      
    
    
    
    <category term="运维" scheme="http://yelog.org/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
    <category term="vim" scheme="http://yelog.org/tags/vim/"/>
    
    <category term="neovim" scheme="http://yelog.org/tags/neovim/"/>
    
  </entry>
  
  <entry>
    <title>el-drawer 实现鼠标拖拽宽度[ElementUI]</title>
    <link href="http://yelog.org/2022/06/24/el-drawer-drag-width/"/>
    <id>http://yelog.org/2022/06/24/el-drawer-drag-width/</id>
    <published>2022-06-24T11:38:00.000Z</published>
    <updated>2024-08-12T09:33:11.941Z</updated>
    
    <content type="html"><![CDATA[<h3 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h3><p><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/picgo_qiniu2022-06-25%2010.12.32.gif" alt="el-drawer-drag-width"></p><h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><p>通过指令的方式, 在 <code>drawer</code> 的左侧边缘, 添加一个触发拖拽的长条形区域, 监听鼠标左键按下时启动 <code>document.onmousemove</code> 的监听, 监听鼠标距离浏览器右边的距离, 设置为 <code>drawer</code> 的宽度, 并添加约束: 不能小于浏览器宽度的 20%, 不能大于浏览器宽度的 80%.</p><h3 id="指令代码"><a href="#指令代码" class="headerlink" title="指令代码"></a>指令代码</h3><p>创建文件 <code>src/directive/elment-ui/drawer-drag-width.js</code>, 内容如下</p><pre><code class="js">import Vue from &#39;vue&#39;/** * el-drawer 拖拽指令 */Vue.directive(&#39;el-drawer-drag-width&#39;, &#123;  bind(el, binding, vnode, oldVnode) &#123;    const drawerEle = el.querySelector(&#39;.el-drawer&#39;)    console.log(drawerEle)    // 创建触发拖拽的元素    const dragItem = document.createElement(&#39;div&#39;)    // 将元素放置到抽屉的左边边缘    dragItem.style.cssText = &#39;height: 100%;width: 5px;cursor: w-resize;position: absolute;left: 0;&#39;    drawerEle.append(dragItem)    dragItem.onmousedown = (downEvent) =&gt; &#123;      // 拖拽时禁用文本选中      document.body.style.userSelect = &#39;none&#39;      document.onmousemove = function(moveEvent) &#123;        // 获取鼠标距离浏览器右边缘的距离        let realWidth = document.body.clientWidth - moveEvent.pageX        const width30 = document.body.clientWidth * 0.2        const width80 = document.body.clientWidth * 0.8        // 宽度不能大于浏览器宽度 80%，不能小于宽度的 20%        realWidth = realWidth &gt; width80 ? width80 : realWidth &lt; width30 ? width30 : realWidth        drawerEle.style.width = realWidth + &#39;px&#39;      &#125;      document.onmouseup = function(e) &#123;        // 拖拽时结束时，取消禁用文本选中        document.body.style.userSelect = &#39;initial&#39;        document.onmousemove = null        document.onmouseup = null      &#125;    &#125;  &#125;&#125;)</code></pre><p>然后在 <code>main.js</code> 中将其导入</p><pre><code class="js">import &#39;./directive/element-ui/drawer-drag-width&#39;</code></pre><h3 id="指令使用"><a href="#指令使用" class="headerlink" title="指令使用"></a>指令使用</h3><p>在 <code>el-drawer</code>  上添加指令 <code>v-el-drawer-drag-width</code> 即可, 如下</p><pre><code class="html">&lt;el-drawer  v-el-drawer-drag-width  :visible.sync=&quot;helpDrawer.show&quot;  direction=&quot;rtl&quot;  class=&quot;my-drawer&quot;&gt;  &lt;template #title&gt;    &lt;div class=&quot;draw-title&quot;&gt;&#123;&#123; helpDrawer.title &#125;&#125;&lt;/div&gt;  &lt;/template&gt;  &lt;Editor    v-model=&quot;helpDrawer.html&quot;    v-loading=&quot;helpDrawer.loading&quot;    class=&quot;my-wang-editor&quot;    style=&quot;overflow-y: auto;&quot;    :default-config=&quot;helpDrawer.editorConfig&quot;    :mode=&quot;helpDrawer.mode&quot;    @onCreated=&quot;onCreatedHelp&quot;  /&gt;&lt;/el-drawer&gt;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;实现效果&quot;&gt;&lt;a href=&quot;#实现效果&quot; class=&quot;headerlink&quot; title=&quot;实现效果&quot;&gt;&lt;/a&gt;实现效果&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/yelog/assets/images/picg</summary>
      
    
    
    
    <category term="大前端" scheme="http://yelog.org/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="ElementUI" scheme="http://yelog.org/tags/ElementUI/"/>
    
    <category term="Vue" scheme="http://yelog.org/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud系列之接入SkyWalking进行链路追踪和日志收集</title>
    <link href="http://yelog.org/2021/09/26/spring-cloud-skywalking/"/>
    <id>http://yelog.org/2021/09/26/spring-cloud-skywalking/</id>
    <published>2021-09-26T10:08:00.000Z</published>
    <updated>2024-08-12T09:33:12.244Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前一段时间一直在研究升级公司项目的架构，在不断学习和试错后，最终确定了一套基于 k8s 的高可用架构体系，未来几期会将这套架构体系的架设过程和注意事项以系列文章的形式分享出来，敬请期待！</p><p>由于集群和分布式规模的扩大，对微服务链路的监控和日志收集，越来越有必要性，所以在筛选了了一些方案后，发现 SkyWalking 完美符合我们的预期，对链路追踪和日志收集都有不错的实现。</p><h2 id="SkyWalking-简介"><a href="#SkyWalking-简介" class="headerlink" title="SkyWalking 简介"></a>SkyWalking 简介</h2><p>SkyWalking 是一款 APM（应用程序监控）系统，转为微服务、云原生、基于容器的架构而设计。主要包含了一下核心功能</p><ol><li>对服务、运行实例、API进行指标分析</li><li>链路检测，检查缓慢的服务和API</li><li>对基础设施（VM、网络、磁盘、数据库）进行监控</li><li>对超出阈值的情况进行警报</li><li>等等</li></ol><p>开源地址：<a href="https://github.com/apache/skywalking">apache&#x2F;skywalking</a></p><p>官网：<a href="https://skywalking.apache.org/">Apache SkyWalking</a></p><h2 id="SpringCloud-整合-SkyWalking"><a href="#SpringCloud-整合-SkyWalking" class="headerlink" title="SpringCloud 整合 SkyWalking"></a>SpringCloud 整合 SkyWalking</h2><h3 id="1-搭建-SkyWalking-服务"><a href="#1-搭建-SkyWalking-服务" class="headerlink" title="1. 搭建 SkyWalking 服务"></a>1. 搭建 SkyWalking 服务</h3><p>在使用 SkyWalking 进行链路追踪和日志收集之前，需要先搭建起一套 SkyWalking 的服务，然后才能通过 agent 将 SpringCloud 的运行状态和日志发送给 SkyWalking 进行解析和展示。</p><p>SkyWalking 的搭建方式有很多中，我这里介绍两种 docker-compose（非高可用，快速启动，方便测试、学习） 和 k8s（高可用、生产级别）</p><h4 id="docker-compose-的方式"><a href="#docker-compose-的方式" class="headerlink" title="docker-compose 的方式"></a>docker-compose 的方式</h4><p>docker 和 docker-compose 的安装不是本文的重点，所以有需要可以自行查询。</p><p>以下操作会启动三个容器</p><ol><li><code>elasticsearch</code> 作为 skywalking 的存储，保存链路和日志数据等</li><li><code>oap</code> 数据接收和分析 Observability Analysis Platform</li><li><code>ui</code> web端的数据展示</li></ol><pre><code class="bash"># 创建配置文件保存的目录mkdir -p /data/docker/admin/skywalking# 切换到刚创建的目录cd /data/docker/admin/skywalking# 将下面的 docker-compose.yml 文件保存到这个目录vi docker-compose.yml# 拉去镜像并启动docker-compose up -d# 查看日志docker-compose logs -f</code></pre><p>docker-compose.yml</p><pre><code class="yaml">version: &#39;3.8&#39;services:  elasticsearch:    image: docker.elastic.co/elasticsearch/elasticsearch:7.14.1    container_name: elasticsearch    restart: always    ports:      - 9200:9200    healthcheck:      test: [&quot;CMD-SHELL&quot;, &quot;curl --silent --fail localhost:9200/_cluster/health || exit 1&quot;]      interval: 30s      timeout: 10s      retries: 3      start_period: 40s    environment:      - discovery.type=single-node      - bootstrap.memory_lock=true      - &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;      - TZ=Asia/Shanghai    ulimits:      memlock:        soft: -1        hard: -1  oap:    image: apache/skywalking-oap-server:8.7.0-es7    container_name: oap    depends_on:      - elasticsearch    links:      - elasticsearch    restart: always    ports:      - 11800:11800      - 12800:12800    healthcheck:      test: [&quot;CMD-SHELL&quot;, &quot;/skywalking/bin/swctl&quot;]      interval: 30s      timeout: 10s      retries: 3      start_period: 40s    environment:      TZ: Asia/Shanghai      SW_STORAGE: elasticsearch7      SW_STORAGE_ES_CLUSTER_NODES: elasticsearch:9200  ui:    image: apache/skywalking-ui:8.7.0    container_name: ui    depends_on:      - oap    links:      - oap    restart: always    ports:      - 8088:8080    environment:      TZ: Asia/Shanghai      SW_OAP_ADDRESS: http://oap:12800</code></pre><p>启动之后浏览器访问 <code>服务ip:8080</code> 即可</p><h4 id="k8s"><a href="#k8s" class="headerlink" title="k8s"></a>k8s</h4><p>等待更新。。</p><h3 id="2-下载-agent-代理包"><a href="#2-下载-agent-代理包" class="headerlink" title="2. 下载 agent 代理包"></a>2. 下载 agent 代理包</h3><p>点击链接进行下载，<a href="https://archive.apache.org/dist/skywalking/8.7.0/apache-skywalking-apm-8.7.0.tar.gz">skywalking-apm-8.7</a></p><blockquote><p>其他版本可以看 <a href="https://archive.apache.org/dist/skywalking/">apache 归档站</a>，找到对应版本的 <code>.tar.gz</code> 后缀的包，进行下载</p></blockquote><p>通过命令或者软件进行解压 <code>tar -zxvf apache-skywalking-apm-8.7.0.tar.gz</code></p><h3 id="3-java-命令使用代码启动-jar-包"><a href="#3-java-命令使用代码启动-jar-包" class="headerlink" title="3. java 命令使用代码启动 jar 包"></a>3. java 命令使用代码启动 jar 包</h3><p>springcloud&#x2F;springboot 一般是通过 <code>java -jar xxx.jar</code> 进行启动。我们只需要在其中加上 <code>-javaagent</code> 参数即可，如下</p><p>其中 <strong>自定义服务名</strong> 可以改为应用名 如 <code>lemes-auth</code>，<strong>服务ip</strong> 为第一步搭建的 SkyWalking 服务的ip，<strong>端口11800</strong> 为启动的 oap 这个容器的端口</p><pre><code class="bash">java -javaagent:上一步解压目录/agent/skywalking-agent.jar=agent.service_name=自定义服务名,collector.backend_service=服务ip:11800 -jar xx.jar</code></pre><p>执行命令启动后，访问以下接口，就可以在第一步 <code>服务ip:8080</code> 中看到访问的链接和调用链路。</p><p><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/picgo_qiniu20210926164151.png" alt="链路追踪"><br><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/picgo_qiniu20210926164350.png" alt="拓扑图"></p><h3 id="4-开启日志收集"><a href="#4-开启日志收集" class="headerlink" title="4. 开启日志收集"></a>4. 开启日志收集</h3><p>本文主要以 log4j2 来介绍，其他的大同小异，可以网上找教程。SpringCloud 集成 log4j2 不是本文重点，所以请自行 Google。</p><h4 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h4><p>要开启日志收集，必须要添加依赖，如下</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.apache.skywalking&lt;/groupId&gt;    &lt;artifactId&gt;apm-toolkit-log4j-2.x&lt;/artifactId&gt;    &lt;version&gt;8.7.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><h4 id="修改-log4j2-xml"><a href="#修改-log4j2-xml" class="headerlink" title="修改 log4j2.xml"></a>修改 log4j2.xml</h4><p>需要修改 log4j2.xml 主要添加下面两个关键点</p><ul><li>添加 <code>%traceId</code> 来打印 traceid</li><li>声明 GRPCLogClientAppender</li></ul><p>完整内容如下</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!--日志级别以及优先级排序: OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt; ALL --&gt;&lt;!-- Configuration后面的status，这个用于设置log4j2自身内部的信息输出，可以不设置，当设置成trace时，     你会看到log4j2内部各种详细输出。可以设置成OFF(关闭) 或 Error(只输出错误信息)。--&gt;&lt;!--monitorInterval：Log4j能够自动检测修改配置 文件和重新配置本身，设置间隔秒数--&gt;&lt;configuration status=&quot;WARN&quot; monitorInterval=&quot;30&quot;&gt;    &lt;Properties&gt;        &lt;Property name=&quot;log.path&quot;&gt;logs/lemes-auth&lt;/Property&gt;        &lt;Property name=&quot;logging.lemes.pattern&quot;&gt;            %d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%-5level] [%traceId] [%logger&#123;50&#125;.%M:%L] - %msg%n        &lt;/Property&gt;    &lt;/Properties&gt;    &lt;Appenders&gt;        &lt;!-- 输出控制台日志的配置 --&gt;        &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;            &lt;!--控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt;            &lt;ThresholdFilter level=&quot;debug&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt;            &lt;!-- 输出日志的格式 --&gt;            &lt;PatternLayout pattern=&quot;$&#123;logging.lemes.pattern&#125;&quot;/&gt;        &lt;/Console&gt;        &lt;RollingRandomAccessFile name=&quot;debugRollingFile&quot; fileName=&quot;$&#123;log.path&#125;/debug.log&quot;                                 filePattern=&quot;$&#123;log.path&#125;/debug/$$&#123;date:yyyy-MM&#125;/debug.%d&#123;yyyy-MM-dd&#125;-%i.log.gz&quot;&gt;            &lt;ThresholdFilter level=&quot;debug&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt;            &lt;PatternLayout charset=&quot;UTF-8&quot; pattern=&quot;$&#123;logging.lemes.pattern&#125;&quot;/&gt;            &lt;Policies&gt;                &lt;TimeBasedTriggeringPolicy interval=&quot;1&quot;/&gt;                &lt;SizeBasedTriggeringPolicy size=&quot;100 MB&quot;/&gt;            &lt;/Policies&gt;            &lt;DefaultRolloverStrategy max=&quot;30&quot;/&gt;        &lt;/RollingRandomAccessFile&gt;        &lt;GRPCLogClientAppender name=&quot;grpc-log&quot;&gt;            &lt;PatternLayout pattern=&quot;$&#123;logging.lemes.pattern&#125;&quot;/&gt;        &lt;/GRPCLogClientAppender&gt;    &lt;/Appenders&gt;    &lt;Loggers&gt;        &lt;!-- ALL &lt; TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL &lt; OFF --&gt;        &lt;Logger name=&quot;com.lenovo.lemes&quot; level=&quot;debug&quot;/&gt;        &lt;Logger name=&quot;org.apache.kafka&quot; level=&quot;warn&quot;/&gt;        &lt;Root level=&quot;info&quot;&gt;            &lt;AppenderRef ref=&quot;Console&quot;/&gt;            &lt;AppenderRef ref=&quot;debugRollingFile&quot;/&gt;            &lt;AppenderRef ref=&quot;grpc-log&quot;/&gt;        &lt;/Root&gt;    &lt;/Loggers&gt;&lt;/configuration&gt;</code></pre><h4 id="启动命令中声明上报日志"><a href="#启动命令中声明上报日志" class="headerlink" title="启动命令中声明上报日志"></a>启动命令中声明上报日志</h4><p>在上一步的 agent 中添加上报日志的参数 <code>plugin.toolkit.log.grpc.reporter.server_host=服务ip,plugin.toolkit.log.grpc.reporter.server_port=11800</code></p><p>完整如下</p><pre><code class="bash">java -javaagent:上一步解压目录/agent/skywalking-agent.jar=agent.service_name=自定义服务名,collector.backend_service=服务ip:11800,plugin.toolkit.log.grpc.reporter.server_host=服务ip,plugin.toolkit.log.grpc.reporter.server_port=11800 -jar xx.jar</code></pre><h4 id="日志收集效果"><a href="#日志收集效果" class="headerlink" title="日志收集效果"></a>日志收集效果</h4><p>这样启动日志中就会打印 traceid , <code>N/A</code> 代表的是非请求的日志，有 traceid 的为 api 请求日志</p><p><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/picgo_qiniu20210926170409.png" alt="traceid"></p><p>在 skywalking 中就能看到我们上报的日志</p><p><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/picgo_qiniu20210926170953.png" alt="skywalking 日志上报"></p><p>重点：SkyWalking 可以在链路追踪中查看当前请求的所有日志（不同实例&#x2F;模块）</p><p><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/picgo_qiniu20210926171217.png" alt="SkyWalking 链路日志"></p><p><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/picgo_qiniu20210926171256.png" alt="SkyWalking 链路日志"></p><h3 id="5-兼容-spring-cloud-gateway"><a href="#5-兼容-spring-cloud-gateway" class="headerlink" title="5. 兼容 spring-cloud-gateway"></a>5. 兼容 spring-cloud-gateway</h3><p>经过上面的步骤之后，链路已经搭建完成，查看发现了一个问题，gateway 模块的 <code>traceId</code> 和 业务模块的 <code>traceId</code> 不统一。</p><p><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/picgo_qiniu20210926164350.png" alt="拓扑图"></p><p>这是由于 SkyWalking 对于 <code>spring-cloud-gateway</code> 的支持不是默认的，所以需要将 <code>agent/optional-plugins/apm-spring-cloud-gateway-2.1.x-plugin-8.7.0.jar</code> 复制到 <code>agent/plugins</code> 下，然后重启即可。</p><p><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/picgo_qiniu20210926180619.png" alt="优化过 gateway 的拓扑图"></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>SkyWalking 上面这两个功能就已经非常强大，能够有效帮助我们优化我们的程序，监控系统的问题，并及时报警。日志收集也解决的在大规模分布式集群下日志查询难的问题。</p><p>SkyWalking 还支持 VM、浏览器、k8s等监控，后续如果有实践，将会逐步更新。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前一段时间一直在研究升级公司项目的架构，在不断学习和试错后，最终确定了一套基于 k8s 的高可用架构体系，未来几期会将这套架构体系的架设过程</summary>
      
    
    
    
    <category term="后端" scheme="http://yelog.org/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="java" scheme="http://yelog.org/tags/java/"/>
    
    <category term="SpringCloud" scheme="http://yelog.org/tags/SpringCloud/"/>
    
    <category term="SkyWalking" scheme="http://yelog.org/tags/SkyWalking/"/>
    
  </entry>
  
  <entry>
    <title>3-hexo添加自定义图标</title>
    <link href="http://yelog.org/2020/12/28/3-hexo-add-icon/"/>
    <id>http://yelog.org/2020/12/28/3-hexo-add-icon/</id>
    <published>2020-12-28T14:00:00.000Z</published>
    <updated>2024-08-12T09:33:12.053Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>鉴于许多人问过如何添加自定义图标，这里就详细说明一下，以备后人乘凉。</p><p>这篇文章主要讲解是从 <a href="https://www.iconfont.cn/">iconfont</a> 添加图标。</p><h2 id="二、添加彩色图标"><a href="#二、添加彩色图标" class="headerlink" title="二、添加彩色图标"></a>二、添加彩色图标</h2><h3 id="2-1-登录并添加图标"><a href="#2-1-登录并添加图标" class="headerlink" title="2.1 登录并添加图标"></a>2.1 登录并添加图标</h3><p>访问 <a href="https://www.iconfont.cn/">iconfont</a>，点击如下图位置登录，可以使用 <code>Github</code> 账号登录。</p><p><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/picgo_qiniu20201228230707.png" alt="iconfont 登录"></p><p>登录成功后，搜索合适的图标，然后点击添加到购物车，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/picgo_qiniu20201228231118.png"></p><p>添加了多个后，可以点击右上角的“购物车”，添加到项目，点击加号创建项目，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/picgo_qiniu20201228231558.png"></p><p>添加完成后回到项目页面，找到自己刚刚创建的项目。</p><blockquote><p>如果没有到项目页面，可以点击上面菜单进入：资源管理 -&gt; 我的项目</p></blockquote><h3 id="2-2-引入-3-hexo-中"><a href="#2-2-引入-3-hexo-中" class="headerlink" title="2.2 引入 3-hexo 中"></a>2.2 引入 3-hexo 中</h3><p>点击下载到本地，解压并复制其中的 <code>iconfont.js</code> 到项目 <code>3-hexo/source/js/</code> 下，并改名 <code>custom-iconfont.js</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/picgo_qiniu20201229003210.png"></p><p>在文件 <code>3-hexo/layout/_partial/meta.ejs</code> 最后追加下面一行。</p><pre><code class="html">&lt;script src=&quot;&lt;%=theme.blog_path?theme.blog_path.lastIndexOf(&quot;/&quot;) === theme.blog_path.length-1?theme.blog_path.slice(0, theme.blog_path.length-1):theme.blog_path:&#39;&#39; %&gt;/js/custom-iconfont.js?v=&lt;%=theme.version%&gt;&quot; &gt;&lt;/script&gt;</code></pre><h3 id="2-3-在配置文件中添加生效"><a href="#2-3-在配置文件中添加生效" class="headerlink" title="2.3 在配置文件中添加生效"></a>2.3 在配置文件中添加生效</h3><p>修改 <code>3-hexo/_config.yml</code> 如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/picgo_qiniu20201229001129.png"></p><p>完成！</p><blockquote><p>图标名如上面的 <code>gitee</code> 可以在 网站上修改，如下图所示<br><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/picgo_qiniu20201229002057.png"></p></blockquote><h2 id="三、添加黑白图标"><a href="#三、添加黑白图标" class="headerlink" title="三、添加黑白图标"></a>三、添加黑白图标</h2><p><code>link.theme=white</code></p><h3 id="3-1-同-2-1"><a href="#3-1-同-2-1" class="headerlink" title="3.1 同 2.1"></a>3.1 同 2.1</h3><h3 id="3-2-引入-3-hexo-中"><a href="#3-2-引入-3-hexo-中" class="headerlink" title="3.2 引入 3-hexo 中"></a>3.2 引入 3-hexo 中</h3><p>点击生成代码，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/yelog/assets/images/picgo_qiniu20201228231715.png"></p><p>复制生成的代码，修改 <code>font-family</code> 的值为 <code>custom-iconfont</code>，添加到 <code>3-hexo/source/css/_partial/font.styl</code> 最后，并写入图标信息，<code>content</code> 可以移到图标上进行复制，注意前面斜杠转译和去掉后面的分号。</p><pre><code class="css">@font-face &#123;  font-family: &#39;custom-iconfont&#39;;  /* project id 2298064 */  src: url(&#39;//at.alicdn.com/t/font_2298064_34vkk4c9945.eot&#39;);  src: url(&#39;//at.alicdn.com/t/font_2298064_34vkk4c9945.eot?#iefix&#39;) format(&#39;embedded-opentype&#39;),  url(&#39;//at.alicdn.com/t/font_2298064_34vkk4c9945.woff2&#39;) format(&#39;woff2&#39;),  url(&#39;//at.alicdn.com/t/font_2298064_34vkk4c9945.woff&#39;) format(&#39;woff&#39;),  url(&#39;//at.alicdn.com/t/font_2298064_34vkk4c9945.ttf&#39;) format(&#39;truetype&#39;),  url(&#39;//at.alicdn.com/t/font_2298064_34vkk4c9945.svg#iconfont&#39;) format(&#39;svg&#39;);&#125;.icon-gitee:before &#123;  content: &quot;\e602&quot;;&#125;.icon-youtubeautored:before &#123;  content: &quot;\e649&quot;;&#125;</code></pre><h3 id="3-3-在配置文件中添加生效-同2-2"><a href="#3-3-在配置文件中添加生效-同2-2" class="headerlink" title="3.3 在配置文件中添加生效 同2.2"></a>3.3 在配置文件中添加生效 同2.2</h3><p>结束！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;鉴于许多人问过如何添加自定义图标，这里就详细说明一下，以备后人乘凉。&lt;/p&gt;
&lt;p&gt;这篇文章主要讲解是从 &lt;a href=&quot;</summary>
      
    
    
    
    <category term="工具" scheme="http://yelog.org/categories/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="hexo" scheme="http://yelog.org/categories/%E5%B7%A5%E5%85%B7/hexo/"/>
    
    
    <category term="3-hexo" scheme="http://yelog.org/tags/3-hexo/"/>
    
    <category term="hexo" scheme="http://yelog.org/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>一文看懂JavaScript中的Promise</title>
    <link href="http://yelog.org/2020/10/20/know-javascript-promise/"/>
    <id>http://yelog.org/2020/10/20/know-javascript-promise/</id>
    <published>2020-10-20T11:43:44.000Z</published>
    <updated>2024-08-12T09:33:11.924Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Promise-是什么"><a href="#一、Promise-是什么" class="headerlink" title="一、Promise 是什么"></a>一、Promise 是什么</h2><p><code>Promise</code> 是 <code>ES6</code> 提供的原生对象，用来处理异步操作</p><p>它有三种状态</p><ul><li><code>pending</code>: 初始状态，不是成功或失败状态。</li><li><code>fulfilled</code>: 意味着操作成功完成。</li><li><code>rejected</code>: 意味着操作失败。</li></ul><h2 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a>二、使用</h2><h3 id="2-1-创建-Promise"><a href="#2-1-创建-Promise" class="headerlink" title="2.1 创建 Promise"></a>2.1 创建 Promise</h3><p>通过 <code>new Promise</code> 来实例化，支持链式调用</p><pre><code class="javascript">new Promise((resolve, reject)=&gt;&#123;  // 逻辑&#125;).then(()=&gt;&#123;  //当上面&quot;逻辑&quot;中调用 resolve() 时触发此方法&#125;).catch(()=&gt;&#123;  //当上面&quot;逻辑&quot;中调用 reject() 时触发此方法&#125;)</code></pre><h3 id="2-2-执行顺序"><a href="#2-2-执行顺序" class="headerlink" title="2.2 执行顺序"></a>2.2 执行顺序</h3><p><code>Promise</code>一旦创建就立即执行，并且无法中途取消，执行逻辑和顺序可以从下面的示例中获得</p><p>如下，可修改 <code>if</code> 条件来改变异步结果，下面打印开始的数字是执行顺序</p><p><a href="https://jsbin.com/cijuwakeha/1/edit?js,console">在线调试此示例 - jsbin</a></p><pre><code class="javascript">console.log(&#39;1.开始创建并执行 Promise&#39;)new Promise(function(resolve, reject) &#123;  console.log(&#39;2.由于创建会立即执行，所以会立即执行到本行&#39;)  setTimeout(()=&gt;&#123; // 模拟异步请求    console.log(&#39;4. 1s之期已到，开始执行异步操作&#39;)    if (true) &#123;        // 一般我们符合预期的结果时调用 resolve()，会在 .then 中继续执行        resolve(&#39;成功&#39;)    &#125; else &#123;        // 不符合预期时调用 reject()，会在 .catch 中继续执行        reject(&#39;不符合预期&#39;)    &#125;  &#125;, 1000)&#125;).then((res)=&gt;&#123;  console.log(&#39;5.调用了then，接收数据：&#39; + res)&#125;).catch((error)=&gt;&#123;  console.log(&#39;5.调用了catch，错误信息：&#39; + error)&#125;)console.log(&#39;3.本行为同步操作，所以先于 Promise 内的异步操作（setTimeout）&#39;)</code></pre><p>执行结果如下</p><pre><code class="javascript">&quot;1.开始创建并执行 Promise&quot;&quot;2.由于创建会立即执行，所以会立即执行到本行&quot;&quot;3.本行为同步操作，所以先于 Promise 内的异步操作（setTimeout）&quot;&quot;4. 1s之期已到，开始执行异步操作&quot;&quot;5.调用了then，接收数据：成功&quot;</code></pre><h3 id="2-3-用函数封装-Promise"><a href="#2-3-用函数封装-Promise" class="headerlink" title="2.3 用函数封装 Promise"></a>2.3 用函数封装 Promise</h3><p>这是比较常用的方法，如下用 <code>setTimeout</code> 模拟异步请求，封装通用请求函数</p><p><a href="https://jsbin.com/figuhohoki/1/edit?js,console">在线调试此示例 - jsbin</a></p><pre><code class="javascript">// 这是一个异步方法function ajax(url)&#123;  return new Promise(resolve=&gt;&#123;    console.log(&#39;异步方法开始执行&#39;)    setTimeout(()=&gt;&#123;      console.log(&#39;异步方法执行完成&#39;)      resolve(url+&#39;的结果集&#39;)    &#125;, 1000)  &#125;)&#125;// 调用请求函数，并接受处理返回结果ajax(&#39;/user/list&#39;).then((res)=&gt;&#123;  console.log(res)&#125;)</code></pre><p>执行结果</p><pre><code class="javascript">&quot;异步方法开始执行&quot;&quot;异步方法执行完成&quot;&quot;/user/list的结果集&quot;</code></pre><h2 id="三、高级用法"><a href="#三、高级用法" class="headerlink" title="三、高级用法"></a>三、高级用法</h2><h3 id="3-1-同时支持Callback与Promise"><a href="#3-1-同时支持Callback与Promise" class="headerlink" title="3.1 同时支持Callback与Promise"></a>3.1 同时支持Callback与Promise</h3><p><a href="https://jsbin.com/qitewirina/1/edit?js,console">在线调试此示例 - jsbin</a></p><pre><code class="javascript">function ajax(url, success, fail) &#123;  if (typeof success === &#39;function&#39;) &#123;    setTimeout(() =&gt; &#123;      if (true) &#123;        success(&#123;user: &#39;羊&#39;&#125;)      &#125; else if (typeof fail === &#39;function&#39;) &#123;        console.log(typeof fail)        fail(&#39;用户不存在&#39;)      &#125;    &#125;, 1000)  &#125; else &#123;    return new Promise((resolve, reject) =&gt; &#123;      this.ajax(url, resolve, reject)    &#125;)  &#125;&#125;// callback 调用方式ajax(&#39;/user/get&#39;, (res)=&gt;&#123;  console.log(&#39;Callback请求成功！返回结果:&#39;, res)&#125;, (error)=&gt;&#123;  console.log(&#39;Callback请求失败！错误信息:&#39;, error)&#125;)// Promise 调用方式ajax(&#39;/user/get&#39;).then((res)=&gt;&#123;  console.log(&#39;Pormise请求成功！返回结果：&#39;, res)&#125;).catch((error)=&gt;&#123;  console.log(&#39;Promise请求失败！返回结果：&#39;, error)&#125;)</code></pre><p>执行结果</p><pre><code class="javascript">Callback请求成功！返回结果: &#123;user: &quot;羊&quot;&#125;Pormise请求成功！返回结果： &#123;user: &quot;羊&quot;&#125;</code></pre><h3 id="3-2-链式调用"><a href="#3-2-链式调用" class="headerlink" title="3.2 链式调用"></a>3.2 链式调用</h3><p><code>.then</code> 支持返回 <code>Promise</code> 对象进行链式调用</p><pre><code class="javascript">ajax(&#39;/user/info&#39;).then((res)=&gt;&#123;  // 用户信息查询成功后，可以根据返回结果查询后续信息  console.log(&#39;用户信息:&#39;, res)  return ajax(&#39;/user/score&#39;)&#125;).then((res)=&gt;&#123;  console.log(&#39;用户成绩:&#39;, res)  return ajax(&#39;/user/friends&#39;)&#125;).then((res)=&gt;&#123;  console.log(&#39;用户朋友:&#39;, res)&#125;)</code></pre><h3 id="3-3-Promise-all"><a href="#3-3-Promise-all" class="headerlink" title="3.3 Promise.all"></a>3.3 Promise.all</h3><p><code>Promise.all</code> 方法用于将多个 <code>Promise</code> 实例，包装成一个新的 <code>Promise</code> 实例。<br><a href="https://jsbin.com/xojifuzapo/1/edit?js,console">在线调试此示例 - jsbin</a></p><pre><code class="javascript">// 生成一个Promise对象的数组var promises = [2, 3, 5, 7, 11, 13].map(function(id)&#123;  return new Promise((resolve, reject)=&gt;&#123;    if (id % 3 === 0) &#123;      resolve(id)    &#125; else &#123;      reject(id)    &#125;  &#125;);&#125;);Promise.all(promises).then(function(post) &#123;  console.log(&#39;全部通过&#39;)&#125;).catch(function(reason)&#123;  console.log(&#39;未全部通过，有问题id：&#39;+reason)&#125;);</code></pre><p>执行结果</p><pre><code class="javascript">未全部通过，有问题id：2</code></pre><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise">mozilla web docs</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、Promise-是什么&quot;&gt;&lt;a href=&quot;#一、Promise-是什么&quot; class=&quot;headerlink&quot; title=&quot;一、Promise 是什么&quot;&gt;&lt;/a&gt;一、Promise 是什么&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Promise&lt;/code&gt; 是 &lt;co</summary>
      
    
    
    
    <category term="大前端" scheme="http://yelog.org/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="javascript" scheme="http://yelog.org/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Docker 技术整理</title>
    <link href="http://yelog.org/2020/09/01/Docker-summary/"/>
    <id>http://yelog.org/2020/09/01/Docker-summary/</id>
    <published>2020-09-01T14:11:00.000Z</published>
    <updated>2024-08-12T09:33:11.794Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><h3 id="1-1-什么是docker"><a href="#1-1-什么是docker" class="headerlink" title="1.1 什么是docker"></a>1.1 什么是docker</h3><p>Docker 诞生于 2013 年初，由 dotCloud 公司（后改名为 Docker Inc）基于 Go 语言实现并开源的项目。此项目后来加入 Linux基金会，遵从了 Apache 2.0 协议</p><p>Docker 项目的目标是实现轻量级的操作系统虚拟化解决方案。Docker 是在 Linux 容器技术（LXC）的基础上进行了封装，让用户可以快速并可靠的将应用程序从一台运行到另一台上。</p><p>使用容器部署应用被称为<strong>容器化</strong>，容器化技术的几大优势：</p><ol><li><strong>灵活</strong>：甚至复杂的应用也可以被容器化</li><li><strong>轻量</strong>：容器利用和共享宿主机内核，从而在利用系统资源比虚拟机更加的有效</li><li><strong>可移植</strong>：你可以在本地构建，在云端部署并在任何地方运行</li><li><strong>松耦合</strong>：容器是高度封装和自给自足的，允许你在不破环其他容器的情况下替换或升级任何一个</li><li><strong>可扩展</strong>：你可以通过数据中心来新增和自动分发容器</li><li><strong>安全</strong>：容器依赖强约束和独立的进程</li></ol><h3 id="1-2-和传统虚拟机的区别"><a href="#1-2-和传统虚拟机的区别" class="headerlink" title="1.2 和传统虚拟机的区别"></a>1.2 和传统虚拟机的区别</h3><p>容器在Linux上本地运行，并与其他容器共享主机的内核。它运行一个离散进程，不占用任何其他可执行文件更多的内存，从而使其轻巧。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/93990/1598693996043-1d7fecba-79fd-489c-b933-2d23c37680a8.png" alt="image.png"></p><h3 id="1-3-相关链接"><a href="#1-3-相关链接" class="headerlink" title="1.3 相关链接"></a>1.3 相关链接</h3><p>官网：<a href="https://www.docker.com/">https://www.docker.com/</a></p><p>文档：<a href="https://docs.docker.com/">https://docs.docker.com/</a></p><h2 id="二、Image镜像"><a href="#二、Image镜像" class="headerlink" title="二、Image镜像"></a>二、Image镜像</h2><h3 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h3><p>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也<strong>不会被改变</strong>。</p><ol><li><strong>父镜像</strong>：每个镜像都可能依赖于有一个或多个下层组成的另一个镜像。下层那个镜像就是上层镜像的父镜像</li><li><strong>基础镜像</strong>：一个没有任何父镜像的镜像，被称为基础镜像</li><li><strong>镜像ID</strong>：所有镜像都是通过一个 64 位十六进制字符串（256 bit 的值）来标识的。为了简化使用，前 12 个自负可以组成一个短ID，可以在命令行中使用。短ID还是有一定的碰撞几率，所以服务器总是返回长ID</li></ol><h3 id="2-2-从仓库下载镜像"><a href="#2-2-从仓库下载镜像" class="headerlink" title="2.2 从仓库下载镜像"></a>2.2 从仓库下载镜像</h3><p>可以通过 <code>docker pull</code> 命令从仓库获取所需要的镜像</p><pre><code>docker pull [选项] [Docker Registry 地址]&lt;镜像名&gt;:&lt;标签&gt;</code></pre><p><strong>选项:</strong></p><ol><li>–all-tags,-a : 拉去所有 tagged 镜像</li><li>–disable-content-trust：忽略镜像的校验，默认</li><li>–platform：如果服务器是开启多平台支持的，则需要设置平台</li><li>–quiet,-q：静默执行，不打印详细信息</li></ol><p>标签： 下载指定标签的镜像，默认 <code>latest</code></p><p><strong>示例</strong></p><pre><code># 从 Docker Hub 下载最新的 debian 镜像docker pull debian# 从 Docker Hub 下载 jessie 版 debian 镜像docker pull debian:jessie# 下载指定摘要(sha256)的镜像docker pull ubuntu@sha256:45b23dee08af5e43a7fea6c4cf9c25ccf269ee113168c19722f87876677c5cb2</code></pre><h3 id="2-3-列出本地镜像"><a href="#2-3-列出本地镜像" class="headerlink" title="2.3 列出本地镜像"></a>2.3 列出本地镜像</h3><pre><code># 列出已下载的镜像 image_name: 指定列出某个镜像docker images [选项] [image_name]</code></pre><p><strong>选项</strong></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>–all, -a</td><td>展示所有镜像(包括 intermediate 镜像)</td></tr><tr><td>–digests</td><td>展示摘要</td></tr><tr><td>–filter, -f</td><td>添加过滤条件</td></tr><tr><td>–format</td><td>使用 Go 模版更好的展示</td></tr><tr><td>–no-trunc</td><td>不删减输出</td></tr><tr><td>–quiet, -q</td><td>静默输出，仅仅展示 IDs</td></tr></tbody></table><p><strong>示例</strong></p><pre><code># 展示本地所有下载的镜像docker images# 在本地查找镜像名是 &quot;java&quot; 标签是 &quot;8&quot; 的 奖项docker images: java:8# 查找悬挂镜像docker images --filter &quot;dangling=true&quot;# 过滤 lable 为 &quot;com.example.version&quot; 的值为 0.1 的镜像docker images --filter &quot;label=com.example.version=0.1&quot;</code></pre><h3 id="2-4-Dockerfile创建镜像"><a href="#2-4-Dockerfile创建镜像" class="headerlink" title="2.4 Dockerfile创建镜像"></a>2.4 Dockerfile创建镜像</h3><p>为了方便分享和快速部署，我们可以使用 <code>docker build</code> 来创建一个新的镜像，首先创建一个文件 Dockerfile，如下</p><pre><code># This is a commentFROM ubuntu:14.04MAINTAINER Chris &lt;jaytp@qq.com&gt;RUN apt-get -qq updateRUN apt-get -qqy install ruby ruby-devRUN gem install sinatra</code></pre><p>然后在此 Dockerfile 所在目录执行 <code>docker build -t yelog/ubuntu:v1 .</code> 来生成镜像，所属组织&#x2F;镜像名:标签</p><h3 id="2-5-上传镜像"><a href="#2-5-上传镜像" class="headerlink" title="2.5 上传镜像"></a>2.5 上传镜像</h3><p>用户可以通过 <code>docker push</code> 命令，把自己创建的镜像上传到仓库中来共享。例如，用户在 Docker Hub 上完成注册后，可以推送自己的镜像到仓库中。</p><pre><code>docker push yelog/ubuntu</code></pre><h3 id="2-6-导出和载入镜像"><a href="#2-6-导出和载入镜像" class="headerlink" title="2.6 导出和载入镜像"></a>2.6 导出和载入镜像</h3><p>docker 支持将镜像导出为文件，然后可以再从文件导入到本地镜像仓库</p><pre><code># 导出docker load --input yelog_ubuntu_v1.tar# 载入docker load &lt; yelog_ubuntu_v1.tar</code></pre><h3 id="2-7-移除本地镜像"><a href="#2-7-移除本地镜像" class="headerlink" title="2.7 移除本地镜像"></a>2.7 移除本地镜像</h3><pre><code># -f 强制删除docker rmi [-f] yelog/ubuntu:v1# 删除悬挂镜像docker rmi $(docker images -f &quot;dangling=true&quot; -q)# 删除所有未被容器使用的镜像docker image prune -a</code></pre><h2 id="三、容器"><a href="#三、容器" class="headerlink" title="三、容器"></a>三、容器</h2><h3 id="3-1-介绍"><a href="#3-1-介绍" class="headerlink" title="3.1 介绍"></a>3.1 介绍</h3><p>容器和镜像，就像面向对象中的 <strong>类</strong> 和 <strong>示例</strong> 一样，镜像是静态的定义，容器是镜像运行的实体，容器可以被创建、启动、停止、删除和暂停等</p><p>容器的实质是进城，耽于直接的宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。因此容器可以拥有自己的 root 文件系统、网络配置和进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。</p><h3 id="3-2-创建容器"><a href="#3-2-创建容器" class="headerlink" title="3.2 创建容器"></a>3.2 创建容器</h3><p>我们可以通过命令 <code>docker run</code> 命令创建容器</p><p>如下，启动一个容器，执行命令输出 “Hello word”，之后终止容器</p><pre><code>docker run ubuntu:14.04 /bin/echo &#39;Hello world&#39;</code></pre><p>下面的命令则是启动一个 bash 终端，允许用户进行交互</p><pre><code>docker run -t -i ubuntu:14.04 /bin/bash</code></pre><p><code>-t</code> 让 Dcoker 分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上</p><p><code>-i</code> 责让容器的标准输入保持打开</p><p>更多参数可选</p><table><thead><tr><th>-a stdin</th><th>指定标准输入输出内容类型</th></tr></thead><tbody><tr><td>-d</td><td>后台运行容器，并返回容器ID</td></tr><tr><td>-i</td><td>以交互模式运行容器，通常与 -t 同时使用</td></tr><tr><td>-P</td><td>随机端口映射，容器端口内部随即映射到宿主机的端口上</td></tr><tr><td>-p</td><td>指定端口映射， -p 宿主机端口:容器端口</td></tr><tr><td>-t</td><td>为容器重新分配一个伪输入终，通常与 -i 同时使用</td></tr><tr><td>–name&#x3D;”gate”</td><td>为容器指定一个名称</td></tr><tr><td>–dns 8.8.8.8</td><td>指定容器的 DNS 服务器，默认与宿主机一致</td></tr><tr><td>–dns-search example.com</td><td>指定容器 DNS 搜索域名，默认与宿主机一致</td></tr><tr><td>-h “gate”</td><td>指定容器的 hostname</td></tr><tr><td>-e username&#x3D;’gate’</td><td>设置环境变量</td></tr><tr><td>–env-file&#x3D;[]</td><td>从指定文件读入环境变量</td></tr><tr><td>–cpuset&#x3D;”0-2” or –cpuset&#x3D;”0,1,2”</td><td>绑定容器到指定 CPU 运行</td></tr><tr><td>-m</td><td>设置容器使用内存最大值</td></tr><tr><td>–net&#x3D;”bridge”</td><td>指定容器的网络连接类型支持 bridge&#x2F;host&#x2F;none&#x2F;container</td></tr><tr><td>–link&#x3D;[]</td><td>添加链接到另一个容器</td></tr><tr><td>–expose&#x3D;[]</td><td>开放一个端口或一组端口</td></tr><tr><td>–volume,-v</td><td>绑定一个卷</td></tr></tbody></table><p>当利用 <code>docker run</code> 来创建容器时，Dcoker 在后台运行的标准操作包括：</p><ul><li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li><li>利用镜像创建并启动一个容器</li><li>分配一个文件系统，并在只读的镜像外面挂在一层可读写层</li><li>从宿主主机配置的网桥接口中桥接一个虚拟借口到容器中去</li><li>从地址池配置一个 ip 地址给容器</li><li>执行用户指定的应用程序</li><li>执行用户指定的应用程序</li><li>执行完毕后容器被终止</li></ul><h3 id="3-3-启动容器"><a href="#3-3-启动容器" class="headerlink" title="3.3 启动容器"></a>3.3 启动容器</h3><pre><code># 创建一个名为 test 的容器，容器任务是：打印一行 Hello worddocker run --name=&#39;test&#39; ubuntu:14.04 /bin/echo &#39;Hello world&#39;# 查看所有可用容器 [-a]包括终止在内的所有容器docker ps -a# 启动指定 name 的容器docker start test# 重启指定 name 的容器docker restart test# 查看日志运行日志（每次启动的日志均被查询出来）$ docker logs testHello worldHello world</code></pre><h3 id="3-4-守护态运行"><a href="#3-4-守护态运行" class="headerlink" title="3.4 守护态运行"></a>3.4 守护态运行</h3><p>前面创建的容器都是执行任务（打印Hello world）后，容器就终止了。更多的时候，我们需要让 Docker 容器在后台以守护态（Daemonized）形式运行。此时，可以通过添加 <code>-d</code> 参数来实现</p><blockquote><p>注意：docker是否会长久运行，和 docker run 指定的命令有关</p></blockquote><pre><code># 创建 docker 后台守护进程的容器docker run --name=&#39;test2&#39; -d ubuntu:14.04 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;# 查看容器$ docker psCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                               NAMES237e555d4457        ubuntu:14.04        &quot;/bin/sh -c &#39;while t…&quot;   52 seconds ago      Up 51 seconds                                           test2# 获取容器的输出信息$ docker logs test2hello worldhello worldhello world</code></pre><h3 id="3-5-进入容器"><a href="#3-5-进入容器" class="headerlink" title="3.5 进入容器"></a>3.5 进入容器</h3><p>上一步我们已经实现了容器守护态长久运行，某些时候需要进入容器进行操作，可以使用 <code>attach</code> 、<code>exec</code> 进入容器。</p><pre><code># 不安全的，ctrl+d 退出时容器也会终止docker attach [容器Name]# 以交互式命令行进入，安全的，推荐使用docker exec -it [容器Name] /bin/bash</code></pre><p><strong>命令优化</strong></p><ol><li>使用 <code>docker exec</code> 命令时，好用，但是命令过长，我们可以通过自定义命令来简化使用</li><li>创建文件 <code>/user/bin/ctn</code> 命令文件，内容如下</li></ol><pre><code>docker exec -it $1 /bin/bash</code></pre><ol><li>检查环境变量有没有配置目录 <code>/usr/bin</code> （一般是有配置在环境变量里面的，不过最好再确认一下）</li></ol><pre><code>$PATHbash: /usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games: No such file or directory</code></pre><ol><li>完成上面步骤后，就可以直接通过命令 <code>ctn</code> 来进入容器</li></ol><blockquote><p>注意：如果是使用非 root 账号创建的命令，而 docker 命令是 root 权限，可能存在权限问题，可以通过设置 <code>chmod 777 /usr/bin/ctn</code> 设置权限，使用 <code>sudo ctn [容器Name]</code> 即可进入容器</p></blockquote><pre><code>$ ctn [容器Name]</code></pre><ol><li>使用上面命令时，容器Name 需要手动输入，容器出错。我们可以借助 <code>complete</code> 命令来补全 容器Name，在 <code>~/.bashrc</code> （作用于当前用户，如果想要所要用户上校，可以修改 <code>/etc/bashrc</code>）文件中添加一行，内容如下。保存后执行 <code>source ~/.bashrc</code> 使之生效，之后我们输入 <code>ctn</code> 后，按 <code>tab</code> 就会提示或自动补全容器名了了</li></ol><pre><code># ctn auto completecomplete -W &quot;$(docker ps --format&quot;&#123;&#123;.Names&#125;&#125;&quot;)&quot; ctn</code></pre><blockquote><p>注意： 由于提示的 容器Name 是 <code>~/.bashrc</code> 生效时的列表，所有如果之后 docker 容器列表有变动，需要重新执行 <code>source ~/.bashrc</code> 使之更新提示列表</p></blockquote><h3 id="3-6-终止容器"><a href="#3-6-终止容器" class="headerlink" title="3.6 终止容器"></a>3.6 终止容器</h3><p>通过 <code>docker stop [容器Name]</code> 来终止一个<strong>运行中</strong>的容器</p><pre><code># 终止容器名为 test2 的容器docker stop test2# 查看正在运行中的容器docker ps# 查看所有容器（包括终止的）docker ps -a</code></pre><h3 id="3-7-将容器保存为镜像"><a href="#3-7-将容器保存为镜像" class="headerlink" title="3.7 将容器保存为镜像"></a>3.7 将容器保存为镜像</h3><p>我们修改一个容器后，可以经当前容器状态打包成镜像，方便下次直接通过镜像仓库生成当前状态的容器。</p><pre><code># 创建容器docker run -t -i training/sinatra /bin/bash# 添加两个应用gem install json# 将修改后的容器打包成新的镜像docker commit -m &quot;Added json gem&quot; -a &quot;Docker Newbee&quot; 0b2616b0e5a8 ouruser/sinatra:v2</code></pre><h3 id="3-8-导出-导入容器"><a href="#3-8-导出-导入容器" class="headerlink" title="3.8 导出&#x2F;导入容器"></a>3.8 导出&#x2F;导入容器</h3><p>容器 -&gt;导出&gt; 容器快照文件 -&gt;导入&gt; 本地镜像仓库 -&gt;新建&gt; 容器</p><pre><code>$ docker ps -aCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                               NAMES2a8bffa405c8        ubuntu:14.04        &quot;/bin/sh -c &#39;while t…&quot;   About an hour ago   Up 3 seconds                                            test2# 导出$ docker export 2a8bffa405c8 &gt; ubuntu.tar# 导入为镜像$ docker ubuntu.tar | docker import - test/ubuntu:v1.0# 从指定 URL 或者某个目录导入$ docker import http://example.com/exampleimage.tgz example/imagerepo</code></pre><blockquote><p>注意：用户既可以通过 <code>docker load</code> 来导入镜像存储文件到本地镜像仓库，也可以使用 <code>docker import</code> 来导入一个容器快找到本地镜像仓库，两者的区别在于容器快照将丢失所有的历史记录和元数据信息，仅保存容器当时的状态，而镜像存储文件将保存完成的记录，体积要更大。所有容器快照文件导入时需要重新指定标签等元数据信息。</p></blockquote><h3 id="3-9-删除容器"><a href="#3-9-删除容器" class="headerlink" title="3.9 删除容器"></a>3.9 删除容器</h3><p>可以使用 <code>docker rm [容器Name]</code> 来删除一个终止状态的容器，如果容器还未终止，可以先使用 <code>docker stop [容器Name]</code> 来终止容器，再进行删除操作</p><pre><code>docker rm test2# 删除容器 -f: 强制删除，无视是否运行$ docker [-f] rm myubuntu# 删除所有已关闭的容器$ docker rm $(docker ps -a -q)</code></pre><h3 id="3-10-查看容器状态"><a href="#3-10-查看容器状态" class="headerlink" title="3.10 查看容器状态"></a>3.10 查看容器状态</h3><pre><code>docker stats $(docker ps --format=&#123;&#123;.Names&#125;&#125;)</code></pre><h2 id="四、数据卷"><a href="#四、数据卷" class="headerlink" title="四、数据卷"></a>四、数据卷</h2><h3 id="4-1-介绍"><a href="#4-1-介绍" class="headerlink" title="4.1 介绍"></a>4.1 介绍</h3><p>数据卷是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多特性：</p><ul><li>数据卷可以在容器之间共享和重用</li><li>对数据卷的修改会立马生效</li><li>对数据卷的更新，不会影响镜像</li><li>卷会一直存在，直到没有容器使用</li></ul><blockquote><p>数据卷类似于 Linux 下对目录或文件进行 mount</p></blockquote><h3 id="4-2-创建数据卷"><a href="#4-2-创建数据卷" class="headerlink" title="4.2 创建数据卷"></a>4.2 创建数据卷</h3><p>在用 <code>docker run</code> 命令的时候，使用 <code>-v</code> 标记来创建一个数据卷并挂在在容器里，可同时挂在多个。</p><pre><code># 创建一个 web 容器，并加载一个数据卷到容器的 /webapp 目录docker run -d -P --name web -v /webapp training/webapp python app.py# 挂载一个宿主机目录 /data/webapp 到容器中的 /opt/webappdocker run -d -P --name web -v /src/webapp:/opt/webapp training/webapp python app.py# 默认是读写权限，也可以指定为只读docker run -d -P --name web -v /src/webapp:/opt/webapp:ro# 挂载单个文件docker run --rm -it -v ~/.bash_history:/.bash_history ubuntu /bin/bash</code></pre><h3 id="4-3-数据卷容器"><a href="#4-3-数据卷容器" class="headerlink" title="4.3 数据卷容器"></a>4.3 数据卷容器</h3><p>如果需要多个容器共享数据，最好创建数据卷容器，就是一个正常的容器，撰文用来提供数据卷供其他容器挂载的</p><pre><code># 创建一个数据卷容器 dbdatadocker run -d -v /dbdata --name dbdata training/postgres echo Data-only container for postgres# 其他容器挂载 dbdata 容器的数据卷docker run -d --volumes-from dbdata --name db1 training/postgresdocker run -d --volumes-from dbdata --name db2 training/postgres</code></pre><h2 id="五、网络"><a href="#五、网络" class="headerlink" title="五、网络"></a>五、网络</h2><h3 id="5-1-外部访问容器"><a href="#5-1-外部访问容器" class="headerlink" title="5.1 外部访问容器"></a>5.1 外部访问容器</h3><p>在容器内运行一些服务，需要外部可以访问到这些服务，可以通过 <code>-P</code> 或 <code>-p</code> 参数来指定端口映射。</p><p>当使用 <code>-P</code> 标记时，Docker 会随即映射一个 <code>49000～49900</code> 的端口到内部容器开放的网络端口。</p><p>使用 <code>docker ps</code> 可以查看端口映射情况</p><pre><code>$ docker psCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                               NAMES7f43807dc042        training/webapp     &quot;python app.py&quot;          3 seconds ago       Up 2 seconds        0.0.0.0:32770-&gt;5000/tcp             amazing_liskov</code></pre><p>-p 指定端口映射，支持格式 <code>ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort</code></p><pre><code># 不限制ip访问docker run -d -p 5000:5000 training/webapp python app.py# 只允许宿主机回环地址访问docker run -d -p 127.0.0.1:5000:5000 training/webapp python app.py# 宿主机自动分配绑定端口docker run -d -p 127.0.0.1::5000 training/webapp python app.py# 指定 udp 端口docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py# 指定多个端口映射docker run -d -p 5000:5000  -p 3000:80 training/webapp python app.py# 查看映射端口配置$ docker port amazing_liskov5000/tcp -&gt; 0.0.0.0:32770</code></pre><h3 id="5-2-容器互联"><a href="#5-2-容器互联" class="headerlink" title="5.2 容器互联"></a>5.2 容器互联</h3><p>容器除了跟宿主机端口映射外，还有一种容器间交互的方式，可以在源&#x2F;目标容器之间建立一个隧道，目标容器可以看到源容器指定的信息。</p><p>可以通过 <code>--link name:alias</code> 来连接容器，下面就是 “web容器连接db容器” 的例子</p><pre><code># 创建 容器dbdocker run -d --name db training/postgres# 创建 容器web 并连接到 容器dbdocker run -d -P --name web --link db:db training/webapp python app.py# 进入 容器web，测试连通性$ ctn web$ ping dbPING db (172.17.0.3) 56(84) bytes of data.64 bytes from db (172.17.0.3): icmp_seq=1 ttl=64 time=0.254 ms64 bytes from db (172.17.0.3): icmp_seq=2 ttl=64 time=0.190 ms64 bytes from db (172.17.0.3): icmp_seq=3 ttl=64 time=0.389 ms</code></pre><h3 id="5-3-访问控制"><a href="#5-3-访问控制" class="headerlink" title="5.3 访问控制"></a>5.3 访问控制</h3><p>容器想要访问外部网络，需要宿主机的转发支持。在 Linux 系统中，通过以下命令检查是否打开</p><pre><code>$ sysctl net.ipv4.ip_forwardnet.ipv4.ip_forward = 1</code></pre><p>如果是 0，说明没有开启转发，则需要手动打开。</p><pre><code>$ sysctl -w net.ipv4.ip_forward=1</code></pre><h3 id="5-4-配置-docker0-桥接"><a href="#5-4-配置-docker0-桥接" class="headerlink" title="5.4 配置 docker0 桥接"></a>5.4 配置 docker0 桥接</h3><p>Docker 服务默认会创建一个 <code>docker0</code> 网桥，他在内核层连通了其他物理或虚拟网卡，这就将容器和主机都放在同一个物理网络。</p><p>Docker 默认制定了 <code>docker0</code> 接口的IP地址和子网掩码，让主机和容器间可以通过网桥相互通信，他还给了 MTU（接口允许接收的最大单元），通常是 1500 Bytes，或宿主机网络路由上支持的默认值。这些都可以在服务启动的时候进行配置。</p><ul><li><code>--bip=CIDR</code> ip地址加子网掩码格式，如 192.168.1.5&#x2F;24</li><li><code>--mtu=BYTES</code> 覆盖默认的 Docker MTU 配置</li></ul><p>可以通过 <code>brctl show</code> 来查看网桥和端口连接信息</p><h3 id="5-5-网络配置文件"><a href="#5-5-网络配置文件" class="headerlink" title="5.5 网络配置文件"></a>5.5 网络配置文件</h3><p>Docker 1.2.0 开始支持在运行中的容器里编辑 <code>/etc/hosts</code> 、<code>/etc/hostsname</code> 和 <code>/etc/resolve.conf</code> 文件，修改都是临时的，重新容器将会丢失修改，通过 <code>docker commit</code> 也不会被提交。</p><h2 id="六、Dockerfile"><a href="#六、Dockerfile" class="headerlink" title="六、Dockerfile"></a>六、Dockerfile</h2><h3 id="6-1-介绍"><a href="#6-1-介绍" class="headerlink" title="6.1 介绍"></a>6.1 介绍</h3><p>Dockerfile 是由一行行命令组成的命令集合，分为四个部分：</p><ol><li>基础镜像信息</li><li>维护着信息</li><li>镜像操作指令</li><li>容器启动时执行指令</li></ol><p>如下：</p><pre><code># 最前面一般放这个 Dockerfile 的介绍、版本、作者及使用说明等# This dockerfile uses the ubuntu image# VERSION 2 - EDITION 1# Author: docker_user# Command format: Instruction [arguments / command] ..# 使用的基础镜像，必须放在非注释第一行FROM ubuntu# 维护着信息信息： 名字 联系方式MAINTAINER docker_user docker_user@email.com# 构建镜像的命令：对镜像做的调整都在这里RUN echo &quot;deb http://archive.ubuntu.com/ubuntu/ raring main universe&quot; &gt;&gt; /etc/apt/sources.listRUN apt-get update &amp;&amp; apt-get install -y nginxRUN echo &quot;\ndaemon off;&quot; &gt;&gt; /etc/nginx/nginx.conf# 创建/运行 容器时的操作指令 # 可以理解为 docker run 后跟的运行指令CMD /usr/sbin/nginx</code></pre><h3 id="6-2-指令"><a href="#6-2-指令" class="headerlink" title="6.2 指令"></a>6.2 指令</h3><p>指令一般格式为 <code>INSTRUCTION args</code>，包括 <code>FORM</code> 、 <code>MAINTAINER</code> 、<code>RUN</code> 等</p><table><thead><tr><th>FORM</th><th>第一条指令必须是 <code>FORM</code> 指令，并且如果在同一个<code>Dockerfile</code> 中创建多个镜像，可以使用多个 <code>FROM</code> 指令（每个镜像一次）</th><th>FORM ubuntuFORM ubuntu:14.04</th></tr></thead><tbody><tr><td>MAINTAINER</td><td>维护者信息</td><td>MAINTAINER Chris <a href="mailto:&#x78;&#x78;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;">&#x78;&#x78;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;</a></td></tr><tr><td>RUN</td><td>每条 RUN 指令在当前镜像基础上执行命令，并提交为新的镜像。当命令过长时可以使用 <code>\</code> 来换行</td><td>在 shell 终端中运行命令<code>RUN apt-get update &amp;&amp; apt-get install -y nginx</code>在 <code>exec</code> 中执行:<code>RUN [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;echo hello&quot;]</code></td></tr><tr><td>CMD</td><td>指定启动容器时执行的命令，每个 Dockerfile 只能有一条 CMD 命令。如果指定了多条命令，只有最后一条会被执行。</td><td><code>CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]</code> 使用 <code>exec</code> 执行，推荐方式；<code>CMD command param1 param2</code> 在 <code>/bin/sh</code> 中执行，提供给需要交互的应用；<code>CMD [&quot;param1&quot;,&quot;param2&quot;]</code> 提供给 <code>ENTRYPOINT</code> 的默认参数；</td></tr><tr><td>EXPOSE</td><td>告诉服务端容器暴露的端口号，</td><td>EXPOSE <port></td></tr><tr><td>ENV</td><td>指定环境变量</td><td>ENV PG_MAJOR 9.3ENV PATH &#x2F;usr&#x2F;local&#x2F;postgres-$PG_MAJOR&#x2F;bin:$PATH</td></tr><tr><td>ADD</td><td><code>ADD  </code>该命令将复制指定的 <code> </code>到容器中的 <code>。其中 </code> 可以是 <code>Dockerfile</code> 所在目录的一个相对路径，也可以是一个<code>URL</code>；还可以是一个 tar文件（自动解压为目录）</td><td></td></tr><tr><td>COPY</td><td>格式为 <code>COPY  </code>复制本地主机的 <code>（为 Dockerfile 所在目录的相对路径）到容器中的</code> 。当使用本地目录为源目录时，推荐使用 <code>COPY</code></td><td></td></tr><tr><td>ENTRYPOINT</td><td>配置容器启动执行的命令，并且不可被 <code>docker run</code> 提供的参数覆盖每个Docekrfile 中只能有一个 <code>ENTRYPOINT</code> ，当指定多个时，只有最后一个起效</td><td>两种格式<code>ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]``ENTRYPOINT command param1 param2</code>（shell中执行）</td></tr><tr><td>VOLUME</td><td>创建一个可以从本地主机或其他容器挂载的挂载点，一般用来存放数据库和需要保持的数据等。</td><td>VOLUME [“&#x2F;data”]</td></tr><tr><td>USER</td><td>指定运行容器时的用户名或 UID，后续的 <code>RUN</code> 也会使用指定用户</td><td>USER daemon</td></tr><tr><td>WORKDIR</td><td>为后续的 <code>RUN</code>、<code>CMD</code>、<code>ENTRYPOINT</code> 指令配置工作目录。可以使用多个 <code>WORKDIR</code> 指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径。</td><td>格式为 <code>WORKDIR /path/to/workdir</code>。 WORKDIR &#x2F;aWORKDIR bWORKDIR cRUN pwd最后的路径为 &#x2F;a&#x2F;b&#x2F;c</td></tr><tr><td>ONBUILD</td><td>配置当所创建的镜像作为其它新创建镜像的基础镜像时，所执行的操作指令。</td><td>格式为 <code>ONBUILD [INSTRUCTION]</code>。</td></tr></tbody></table><h3 id="6-3-创建镜像"><a href="#6-3-创建镜像" class="headerlink" title="6.3 创建镜像"></a>6.3 创建镜像</h3><p>编写完成 Dockerfile 之后，可以通过 <code>docker build</code> 命令来创建镜像</p><p><code>docker build [选项] 路径</code> 该命令江都区指定路径下（包括子目录）的Dockerfile，并将该路径下所有内容发送给 Docker 服务端，有服务端来创建镜像。可以通过 <code>.dockerignore</code> 文件来让 Docker 忽略路径下的目录与文件</p><pre><code># 使用 -t 指定镜像的标签信息docker build -t myrepo/myimage .</code></pre><h2 id="七、Docker-Compose"><a href="#七、Docker-Compose" class="headerlink" title="七、Docker Compose"></a>七、Docker Compose</h2><h3 id="7-1-介绍"><a href="#7-1-介绍" class="headerlink" title="7.1 介绍"></a>7.1 介绍</h3><p>Docker Compose 是 Docker 官方编排项目之一，负责快速在集群中部署分布式应用。维护地址：<a href="https://github.com/docker/compose%EF%BC%8C%E7%94%B1">https://github.com/docker/compose，由</a> Python 编写，实际调用 Docker提供的API实现。</p><p>Dockerfile 可以让用户管理一个单独的应用容器，而 Compose 则允许用户在一个模版（YAML格式）中定义一组相关联的应用容器（被称为一个project&#x2F;项目），例如一个 web容器再加上数据库、redis等。</p><h3 id="7-2-安装"><a href="#7-2-安装" class="headerlink" title="7.2 安装"></a>7.2 安装</h3><pre><code># 使用 pip 进行安装pip install -U docker-compose# 查看用法docker-ompose -h# 添加 bash 补全命令curl -L https://raw.githubusercontent.com/docker/compose/1.2.0/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose</code></pre><h3 id="7-3-使用"><a href="#7-3-使用" class="headerlink" title="7.3 使用"></a>7.3 使用</h3><p>术语</p><ul><li>服务&#x2F;service： 一个应用容器，实际上可以运行多个相同镜像的实例</li><li>项目&#x2F;project： 有一组关联的应用容器组成的完成业务单元</li></ul><p>示例：创建一个 Haproxy 挂载三个 Web 容器</p><p>创建一个 <code>compose-haproxy-web</code> 目录，作为项目工作目录，并在其中分别创建两个子目录： <code>haproxy</code> 和 <code>web</code> 。</p><pre><code>compose-haproxy-webcompose-haproxy-webgit clone https://github.com/yelog/compose-haproxy-web.git</code></pre><p>目录长这样：</p><pre><code>compose-haproxy-web├── docker-compose.yml├── haproxy│   └── haproxy.cfg└── web    ├── Dockerfile    ├── index.html    └── index.py</code></pre><p>在该目录执行 <code>docker-compose up</code> 命令，会整合输出所有容器的输出</p><pre><code>$ docker-compose upStarting compose-haproxy-web_webb_1 ... doneStarting compose-haproxy-web_webc_1 ... doneStarting compose-haproxy-web_weba_1 ... doneRecreating compose-haproxy-web_haproxy_1 ... doneAttaching to compose-haproxy-web_webb_1, compose-haproxy-web_weba_1, compose-haproxy-web_webc_1, compose-haproxy-web_haproxy_1haproxy_1  | [NOTICE] 244/131022 (1) : haproxy version is 2.2.2haproxy_1  | [NOTICE] 244/131022 (1) : path to executable is /usr/local/sbin/haproxyhaproxy_1  | [ALERT] 244/131022 (1) : parsing [/usr/local/etc/haproxy/haproxy.cfg:14] : &#39;listen&#39; cannot handle unexpected argument &#39;:70&#39;.haproxy_1  | [ALERT] 244/131022 (1) : parsing [/usr/local/etc/haproxy/haproxy.cfg:14] : please use the &#39;bind&#39; keyword for listening addresses.haproxy_1  | [ALERT] 244/131022 (1) : Error(s) found in configuration file : /usr/local/etc/haproxy/haproxy.cfghaproxy_1  | [ALERT] 244/131022 (1) : Fatal errors found in configuration.compose-haproxy-web_haproxy_1 exited with code 1</code></pre><p>此时访问本地的 80 端口，会经过 haproxy 自动转发到后端的某个 web 容器上，刷新页面，可以观察到访问的容器地址的变化。</p><h3 id="7-4-命令说明"><a href="#7-4-命令说明" class="headerlink" title="7.4 命令说明"></a>7.4 命令说明</h3><p>大部分命令都可以运行在一个或多个服务上。如果没有特别的说明，命令则应用在项目所有的服务上。</p><p>执行 <code>docker-compose [COMMAND] --help</code> 查看具体某个命令的使用说明</p><p>使用格式</p><pre><code>docker-compose [options] [COMMAND] [ARGS...]</code></pre><table><thead><tr><th>build</th><th>构建&#x2F;重建服务服务一旦构建后，将会带上一个标记名，例如 web_db可以随时在项目目录运行 <code>docker-compose build</code> 来重新构建服务</th></tr></thead><tbody><tr><td>help</td><td>获得一个命令的信息</td></tr><tr><td>kill</td><td>通过发送 <code>SIGKILL</code> 信号来强制停止服务容器，支持通过参数来指定发送信号，例如<code>docker-compose kill -s SIGINT</code></td></tr><tr><td>logs</td><td>查看服务的输出</td></tr><tr><td>port</td><td>打印绑定的公共端口</td></tr><tr><td>ps</td><td>列出所有容器</td></tr><tr><td>pull</td><td>拉去服务镜像</td></tr><tr><td>rm</td><td>删除停止的服务容器</td></tr><tr><td>run</td><td>在一个服务上执行一个命令<code>docker-compose run ubuntu ping docker.com</code></td></tr><tr><td>scale</td><td>设置同一个服务运行的容器个数通过 <code>service=num</code> 的参数来设置数量<code>docker-compose scale web=2 worker=3</code></td></tr><tr><td>start</td><td>启动一个已经存在的服务容器</td></tr><tr><td>stop</td><td>停止一个已经运行的容器，但不删除。可以通过 <code>docker-compose start</code> 再次启动</td></tr><tr><td>up</td><td>构建、创建、启动、链接一个服务相关的容器链接服务都将被启动，除非他们已经运行<code>docker-compose up -d</code> 将后台运行并启动<code>docker-compose up</code> 已存在容器将会重新创建<code>docker-compose up --no-recreate</code> 将不会重新创建容器</td></tr></tbody></table><h3 id="7-5-环境变量"><a href="#7-5-环境变量" class="headerlink" title="7.5 环境变量"></a>7.5 环境变量</h3><p>环境变量可以用来配置 Compose 的行为</p><p>以 <code>Docker_</code> 开头的变量用来配置 Docker 命令行客户端使用的一样</p><table><thead><tr><th>COMPOSE_PROJECT_NAME</th><th>设置通过 Compose 启动的每一个容器前添加的项目名称，默认是当前工作目录的名字。</th></tr></thead><tbody><tr><td>COMPOSE_FILE</td><td>设置要使用的 <code>docker-compose.yml</code> 的路径。默认路径是当前工作目录。</td></tr><tr><td>DOCKER_HOST</td><td>设置 Docker daemon 的地址。默认使用 <code>unix:///var/run/docker.sock</code>，与 Docker 客户端采用的默认值一致。</td></tr><tr><td>DOCKER_TLS_VERIFY</td><td>如果设置不为空，则与 Docker daemon 交互通过 TLS 进行。</td></tr><tr><td>DOCKER_CERT_PATH</td><td>配置 TLS 通信所需要的验证（<code>ca.pem</code>、<code>cert.pem</code> 和 <code>key.pem</code>）文件的路径，默认是 <code>~/.docker</code> 。</td></tr></tbody></table><h3 id="7-6-docker-compose-yml"><a href="#7-6-docker-compose-yml" class="headerlink" title="7.6 docker-compose.yml"></a>7.6 docker-compose.yml</h3><p>默认模版文件是 <code>docker-compose.yml</code> ，启动定义了每个服务都必须经过 <code>image</code> 指令指定镜像或 <code>build</code> 指令（需要 Dockerfile) 来自动构建。</p><p>其他大部分指令跟 <code>docker run</code> 类似</p><p>如果使用 <code>build</code> 指令，在 Dockerfile 中设置的选项（如 <code>CMD</code> 、<code>EXPOSE</code> 等）将会被自动获取，无需在 <code>docker-compose.yml</code> 中再次设置。</p><pre><code>**image**</code></pre><p>指定镜像名称或镜像ID，如果本地仓库不存在，将尝试从远程仓库拉去此镜像</p><pre><code>image: ubuntuimage: orchardup/postgresqlimage: a4bc65fd**build**</code></pre><p>指定 <code>Dockerfile</code> 所在文件的路径。<code>Compose</code> 将利用它自动构建这个镜像，然后使用这个镜像。</p><pre><code>build: /path/to/build/dir**command**</code></pre><p>覆盖容器启动默认执行命令</p><pre><code>command: bundle exec thin -p 3000**links**</code></pre><p>链接到其他服务中的容器，使用服务名称或别名</p><pre><code>links:    - db  - db:database  - redis</code></pre><p>别名会自动在服务器中的 <code>/etc/hosts</code> 里创建。例如：</p><pre><code>172.17.2.186  db172.17.2.186  database172.17.2.187  redis**external_links**</code></pre><p>连接到 <code>docker-compose.yml</code> 外部的容器，甚至并非 <code>Compose</code> 管理的容器。</p><pre><code>external_links: - redis_1 - project_db_1:mysql - project_db_1:postgresql</code></pre><p><strong><code>ports</code></strong></p><p>暴露端口信息 <code>HOST:CONTAINER</code></p><p>格式或者仅仅指定容器的端口（宿主机会随机分配端口）</p><pre><code>ports: - &quot;3000&quot; - &quot;8000:8000&quot; - &quot;49100:22&quot; - &quot;127.0.0.1:8001:8001&quot;</code></pre><blockquote><p><em>注：当使用 <code>HOST:CONTAINER</code> 格式来映射端口时，如果你使用的容器端口小于 60 你可能会得到错误得结果，因为 <code>YAML</code> 将会解析 <code>xx:yy</code> 这种数字格式为 60 进制。所以建议采用字符串格式。</em></p></blockquote><pre><code>**expose**</code></pre><p>暴露端口，但不映射到宿主机，只被连接的服务访问</p><pre><code>expose: - &quot;3000&quot; - &quot;8000&quot;</code></pre><p><strong><code>volumes</code></strong></p><p>卷挂载路径设置。可以设置宿主机路径 （<code>HOST:CONTAINER</code>） 或加上访问模式 （<code>HOST:CONTAINER:ro</code>）。</p><pre><code>volumes: - /var/lib/mysql - cache/:/tmp/cache - ~/configs:/etc/configs/:ro</code></pre><p>**<br>**</p><p><strong><code>volumes_from</code></strong></p><p>从另一个服务或容器挂载它的所有卷。</p><pre><code>volumes_from: - service_name - container_name</code></pre><pre><code>environment</code></pre><p>设置环境变量。你可以使用数组或字典两种格式。</p><p>只给定名称的变量会自动获取它在 Compose 主机上的值，可以用来防止泄露不必要的数据。</p><pre><code>environment:  RACK_ENV: development  SESSION_SECRET:environment:  - RACK_ENV=development  - SESSION_SECRET</code></pre><p><strong><code>env_file</code></strong></p><p>从文件中获取环境变量，可以为单独的文件路径或列表。</p><p>如果通过 <code>docker-compose -f FILE</code> 指定了模板文件，则 <code>env_file</code> 中路径会基于模板文件路径。</p><p>如果有变量名称与 <code>environment</code> 指令冲突，则以后者为准。</p><pre><code>env_file: .envenv_file:  - ./common.env  - ./apps/web.env  - /opt/secrets.env</code></pre><p>环境变量文件中每一行必须符合格式，支持 <code>#</code> 开头的注释行。</p><pre><code># common.env: Set Rails/Rack environmentRACK_ENV=development</code></pre><p><strong><code>extends</code></strong></p><p>基于已有的服务进行扩展。例如我们已经有了一个 webapp 服务，模板文件为 <code>common.yml</code>。</p><pre><code># common.ymlwebapp:  build: ./webapp  environment:    - DEBUG=false    - SEND_EMAILS=false</code></pre><p>编写一个新的 <code>development.yml</code> 文件，使用 <code>common.yml</code> 中的 webapp 服务进行扩展。</p><pre><code># development.ymlweb:  extends:    file: common.yml    service: webapp  ports:    - &quot;8000:8000&quot;  links:    - db  environment:    - DEBUG=truedb:  image: postgres</code></pre><p>后者会自动继承 common.yml 中的 webapp 服务及相关环节变量。</p><p>**<br>**</p><p><strong><code>net</code></strong></p><p>设置网络模式。使用和 <code>docker client</code> 的 <code>--net</code> 参数一样的值。</p><pre><code>net: &quot;bridge&quot;net: &quot;none&quot;net: &quot;container:[name or id]&quot;net: &quot;host&quot;</code></pre><p>**<br>**</p><p><strong><code>pid</code></strong></p><p>跟主机系统共享进程命名空间。打开该选项的容器可以相互通过进程 ID 来访问和操作。</p><pre><code>pid: &quot;host&quot;</code></pre><p><strong><code>dns</code></strong></p><p>配置 DNS 服务器。可以是一个值，也可以是一个列表。</p><pre><code>dns: 8.8.8.8dns:  - 8.8.8.8  - 9.9.9.9</code></pre><p><strong><code>cap_add, cap_drop</code></strong></p><p>添加或放弃容器的 Linux 能力（Capabiliity）。</p><pre><code>cap_add:  - ALLcap_drop:  - NET_ADMIN  - SYS_ADMIN</code></pre><p>**<br>**</p><p><strong><code>dns_search</code></strong></p><p>配置 DNS 搜索域。可以是一个值，也可以是一个列表。</p><pre><code class="yaml">dns_search: example.comdns_search:  - domain1.example.com  - domain2.example.com</code></pre><p>**<br>**</p><p><strong><code>working_dir, entrypoint, user, hostname, domainname, mem_limit, privileged, restart, stdin_open, tty, cpu_shares</code></strong></p><p>这些都是和 <code>docker run</code> 支持的选项类似。</p><h2 id="八、安全"><a href="#八、安全" class="headerlink" title="八、安全"></a>八、安全</h2><h3 id="8-1-内核命名空间"><a href="#8-1-内核命名空间" class="headerlink" title="8.1 内核命名空间"></a>8.1 内核命名空间</h3><p>当使用 <code>docker run</code> 启动一个容器时，在后台 Docker 为容器创建一个独立的命名空间和控制集合。命名空间踢空了最基础的也是最直接的隔离，在容器中运行的进程不会被运行在主机上的进程和其他容器发现和作用。</p><h3 id="8-2-控制组"><a href="#8-2-控制组" class="headerlink" title="8.2 控制组"></a>8.2 控制组</h3><p>控制组是 Linux 容器机制的另一个关键组件，负责实现资源的审计和限制。</p><p>它提供了很多特性，确保哥哥容器可以公平地分享主机的内存、CPU、磁盘IO等资源；当然，更重要的是，控制组确保了当容器内的资源使用产生压力时不会连累主机系统。</p><h3 id="8-3-内核能力机制"><a href="#8-3-内核能力机制" class="headerlink" title="8.3 内核能力机制"></a>8.3 内核能力机制</h3><p>能力机制是 Linux 内核的一个强大特性，可以提供细粒度的权限访问控制。 可以作用在进程上，也可以作用在文件上。</p><p>例如一个服务需要绑定低于 1024 的端口权限，并不需要 root 权限，那么它只需要被授权 <code>net_bind_service</code> 能力即可。</p><p>默认情况下， Docker 启动的容器被严格限制只允许使用内核的一部分能力。</p><p>使用能力机制加强 Docker 容器的安全有很多好处，可以按需分配给容器权限，这样，即便攻击者在容器中取得了 root 权限，也不能获取宿主机较高权限，能进行的破坏也是有限的。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://docs.docker.com/engine/reference/commandline/images/">https://docs.docker.com/engine/reference/commandline/images/</a></p><p><a href="http://www.dockerinfo.net/">http://www.dockerinfo.net/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h2&gt;&lt;h3 id=&quot;1-1-什么是docker&quot;&gt;&lt;a href=&quot;#1-1-什么是docker&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="运维" scheme="http://yelog.org/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
    <category term="docker" scheme="http://yelog.org/tags/docker/"/>
    
    <category term="linux" scheme="http://yelog.org/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>3-hexo评论设置</title>
    <link href="http://yelog.org/2020/05/23/3-hexo-comment/"/>
    <id>http://yelog.org/2020/05/23/3-hexo-comment/</id>
    <published>2020-05-23T14:26:23.000Z</published>
    <updated>2024-08-12T09:33:12.062Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>目前 <code>3-hexo</code> 已经集成了评论系统有 <code>gitalk</code> 、<code>gitment</code>、 <code>disqus</code> 、<code>来必力</code>、<code>utteranc</code></p><h2 id="一、gitalk"><a href="#一、gitalk" class="headerlink" title="一、gitalk"></a>一、gitalk</h2><p>gitalk 是一款基于 Github Issue 和 Preact 开发的评论插件 官网: <a href="https://gitalk.github.io/">https://gitalk.github.io/</a></p><h3 id="1-登录-github-，注册应用"><a href="#1-登录-github-，注册应用" class="headerlink" title="1. 登录 github ，注册应用"></a>1. 登录 github ，注册应用</h3><p><a href="https://github.com/settings/applications/new">点击进行注册</a> ，如下</p><p><img src="https://i.loli.net/2020/05/23/6BmnUbX5gzPHqk1.png" alt="注册应用"></p><p>注册完后，可得到 <code>Client ID</code> 和 <code>Client Secret</code></p><h3 id="2-新建存放评论的仓库"><a href="#2-新建存放评论的仓库" class="headerlink" title="2. 新建存放评论的仓库"></a>2. 新建存放评论的仓库</h3><p>因为 <code>gitalk</code> 是基于 Github 的 Issue 的，所以需要指定一个仓库，用来承接 gitalk 的评论，我们一般使用 Github Page 来做我们博客的评论，所以，新建仓库名为 <code>xxx.github.io</code>，其中 xxx 为你的 Github 用户名</p><h3 id="3-配置主题"><a href="#3-配置主题" class="headerlink" title="3. 配置主题"></a>3. 配置主题</h3><p>在主题下 <code>_config.yml</code> 中找到如下配置，启用评论，并使用 <code>gitalk</code></p><pre><code class="yaml">##########评论设置#############comment:  on: true  type: gitalk</code></pre><p>在主题下 <code>_config.yml</code> 中找到 gitalk 配置，将 第1步 得到的  <code>Client ID</code> 和 <code>Client Secret</code> 复制到如下位置</p><pre><code class="yaml">gitalk:  githubID:    # 填你的 github 用户名  repo:  xxx.github.io # 承载评论的仓库，一般使用 Github Page 仓库  ClientID:   # 第1步获得 Client ID  ClientSecret:  # 第1步获得 Client Secret  adminUser:     # Github 用户名  distractionFreeMode: true  language: zh-CN  perPage: 10</code></pre><h2 id="二、来必力"><a href="#二、来必力" class="headerlink" title="二、来必力"></a>二、来必力</h2><h3 id="1-创建来必力账号，并选择-City-免费版"><a href="#1-创建来必力账号，并选择-City-免费版" class="headerlink" title="1. 创建来必力账号，并选择 City 免费版"></a>1. 创建来必力账号，并选择 City 免费版</h3><p>官网<a href="http://livere.com/">http://livere.com/</a> ，创建账号，点击上面的安装，选择 City 免费版</p><p><img src="https://i.loli.net/2020/05/23/mLYfjrJ1UgOIpiD.png" alt="选择 city 免费版"></p><p>复制获取到的代码中的 <code>data-uid</code></p><p><img src="http://yelog-img.test.upcdn.net/447D431A-998C-4327-9463-A51D7CE91CE3.png" alt="复制 data-uid"></p><h3 id="2-主题选择使用来必力评论"><a href="#2-主题选择使用来必力评论" class="headerlink" title="2. 主题选择使用来必力评论"></a>2. 主题选择使用来必力评论</h3><p>在主题下 <code>_config.yml</code>  </p><p>在找到来必力配置如下，第一步中复制的 <code>data-uid</code> 粘贴到下面 <code>data_uid</code> 处</p><pre><code class="yaml">livere:  data_uid: xxxxxx</code></pre><p>找到以下代码， 开启并选择 livere (来必力)</p><pre><code class="yaml">##########评论设置#############comment:  on: true  type: livere</code></pre><h2 id="三、utteranc"><a href="#三、utteranc" class="headerlink" title="三、utteranc"></a>三、utteranc</h2><p>官网地址：<a href="https://utteranc.es/">https://utteranc.es/</a></p><h3 id="1-安装-utterances"><a href="#1-安装-utterances" class="headerlink" title="1. 安装 utterances"></a>1. 安装 utterances</h3><p><a href="https://github.com/apps/utterances">点我进行安装</a></p><h3 id="2-配置主题"><a href="#2-配置主题" class="headerlink" title="2. 配置主题"></a>2. 配置主题</h3><p>在主题下 <code>_config.yml</code> 中找到 <code>utteranc</code> 的配置 ，修改 <code>repo</code> 为自己的仓库名</p><pre><code class="yaml">utteranc:  repo: xxx/xxx.github.io # 承载评论的仓库，填上自己的仓库  issue_term: pathname    # Issue 与 博客文章 之间映射关系  label: utteranc         # 创建的 Issue 添加的标签  theme: github-light     # 主题，可选主题请查看官方文档 https://utteranc.es/#heading-theme# 官方文档 https://utteranc.es/# 使用说明 https://yelog.org//2020/05/23/3-hexo-comment/</code></pre><p>在主题下 <code>_config.yml</code> 中找到如下配置，启用评论，并使用 <code>utteranc</code></p><pre><code class="yaml">comment:  on: true  type: utteranc</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;目前 &lt;code&gt;3-hexo&lt;/code&gt; 已经集成了评论系统有 &lt;code&gt;gitalk&lt;/code&gt; 、&lt;code&gt;gitment&lt;/</summary>
      
    
    
    
    <category term="工具" scheme="http://yelog.org/categories/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="hexo" scheme="http://yelog.org/categories/%E5%B7%A5%E5%85%B7/hexo/"/>
    
    
    <category term="3-hexo" scheme="http://yelog.org/tags/3-hexo/"/>
    
  </entry>
  
  <entry>
    <title>3-hexo支持mermaid图表</title>
    <link href="http://yelog.org/2019/11/12/3-hexo-support-mermaid/"/>
    <id>http://yelog.org/2019/11/12/3-hexo-support-mermaid/</id>
    <published>2019-11-12T01:55:37.000Z</published>
    <updated>2024-08-12T09:33:12.135Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、说明"><a href="#一、说明" class="headerlink" title="一、说明"></a>一、说明</h2><h3 id="开启"><a href="#开启" class="headerlink" title="开启"></a>开启</h3><ol><li>安装hexo插件</li></ol><pre><code class="bash">npm install hexo-filter-mermaid-diagrams</code></pre><ol start="2"><li>修改<code>themes/3-hexo/_config.yml</code> 的 <code>mermaid.on</code>，开启主题支持</li></ol><pre><code class="yml"># Mermaid 支持mermaid:  on: true  cdn: //cdn.jsdelivr.net/npm/mermaid@8.4.2/dist/mermaid.min.js  #cdn: //cdnjs.cloudflare.com/ajax/libs/mermaid/8.3.1/mermaid.min.js  options: # 更多配置信息可以参考 https://mermaidjs.github.io/#/mermaidAPI    theme: &#39;default&#39;    startOnLoad: true    flowchart:      useMaxWidth: false      htmlLabels: true</code></pre><ol start="3"><li>在markdown中，像写代码块一样写图表<br><img src="//img.saodiyang.com/FuBTJvG5xIOIcKZPnO9UX5GCwthK.png"></li></ol><h2 id="二、示例"><a href="#二、示例" class="headerlink" title="二、示例"></a>二、示例</h2><p>以下示例源码可以在这边查看 <a href="https://github.com/yelog/blog/blob/master/source/_posts/tools/3-hexo%E6%94%AF%E6%8C%81mermaid%E5%9B%BE%E8%A1%A8.md">本文源码</a><br>更多示例可以查看官网：<a href="https://mermaidjs.github.io/">https://mermaidjs.github.io</a></p><h3 id="1-flowchart"><a href="#1-flowchart" class="headerlink" title="1. flowchart"></a>1. flowchart</h3><pre class="mermaid">graph TD;    A-->B;    A-->C;    B-->D;    C-->D;</pre><pre class="mermaid">graph TB    c1-->a2    subgraph one    a1-->a2    end    subgraph two    b1-->b2    end    subgraph three    c1-->c2    end</pre><h3 id="2-Sequence-diagrams"><a href="#2-Sequence-diagrams" class="headerlink" title="2.Sequence diagrams"></a>2.Sequence diagrams</h3><pre class="mermaid">sequenceDiagram    participant Alice    participant Bob    Alice->>John: Hello John, how are you?    loop Healthcheck        John->>John: Fight against hypochondria    end    Note right of John: Rational thoughts <br/>prevail!    John-->>Alice: Great!    John->>Bob: How about you?    Bob-->>John: Jolly good!</pre><h3 id="3-Class-diagrams"><a href="#3-Class-diagrams" class="headerlink" title="3.Class diagrams"></a>3.Class diagrams</h3><pre class="mermaid">classDiagram     Animal <|-- Duck     Animal <|-- Fish     Animal <|-- Zebra     Animal : +int age     Animal : +String gender     Animal: +isMammal()     Animal: +mate()     class Duck{         +String beakColor         +swim()         +quack()     }     class Fish{         -int sizeInFeet         -canEat()     }     class Zebra{         +bool is_wild         +run()     }</pre><h3 id="4-State-diagrams"><a href="#4-State-diagrams" class="headerlink" title="4.State diagrams"></a>4.State diagrams</h3><pre class="mermaid">stateDiagram       [*] --> Active       state Active {           [*] --> NumLockOff           NumLockOff --> NumLockOn : EvNumLockPressed           NumLockOn --> NumLockOff : EvNumLockPressed           --           [*] --> CapsLockOff           CapsLockOff --> CapsLockOn : EvCapsLockPressed           CapsLockOn --> CapsLockOff : EvCapsLockPressed           --           [*] --> ScrollLockOff           ScrollLockOff --> ScrollLockOn : EvCapsLockPressed           ScrollLockOn --> ScrollLockOff : EvCapsLockPressed       }</pre><h3 id="5-Gantt-diagrams"><a href="#5-Gantt-diagrams" class="headerlink" title="5.Gantt diagrams"></a>5.Gantt diagrams</h3><pre class="mermaid">gantt       dateFormat  YYYY-MM-DD       title Adding GANTT diagram functionality to mermaid       section A section       Completed task            :done,    des1, 2014-01-06,2014-01-08       Active task               :active,  des2, 2014-01-09, 3d       Future task               :         des3, after des2, 5d       Future task2              :         des4, after des3, 5d       section Critical tasks       Completed task in the critical line :crit, done, 2014-01-06,24h       Implement parser and jison          :crit, done, after des1, 2d       Create tests for parser             :crit, active, 3d       Future task in critical line        :crit, 5d       Create tests for renderer           :2d       Add to mermaid                      :1d       section Documentation       Describe gantt syntax               :active, a1, after des1, 3d       Add gantt diagram to demo page      :after a1  , 20h       Add another diagram to demo page    :doc1, after a1  , 48h       section Last section       Describe gantt syntax               :after doc1, 3d       Add gantt diagram to demo page      :20h       Add another diagram to demo page    :48h</pre><h3 id="6-Pie-chart-diagrams"><a href="#6-Pie-chart-diagrams" class="headerlink" title="6.Pie chart diagrams"></a>6.Pie chart diagrams</h3><pre class="mermaid">pie    "Dogs" : 386    "Cats" : 85    "Rats" : 15</pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、说明&quot;&gt;&lt;a href=&quot;#一、说明&quot; class=&quot;headerlink&quot; title=&quot;一、说明&quot;&gt;&lt;/a&gt;一、说明&lt;/h2&gt;&lt;h3 id=&quot;开启&quot;&gt;&lt;a href=&quot;#开启&quot; class=&quot;headerlink&quot; title=&quot;开启&quot;&gt;&lt;/a&gt;开启&lt;/h</summary>
      
    
    
    
    <category term="工具" scheme="http://yelog.org/categories/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="hexo" scheme="http://yelog.org/categories/%E5%B7%A5%E5%85%B7/hexo/"/>
    
    
    <category term="3-hexo" scheme="http://yelog.org/tags/3-hexo/"/>
    
    <category term="hexo" scheme="http://yelog.org/tags/hexo/"/>
    
  </entry>
  
</feed>
